#!/usr/bin/perl

use strict;
use warnings;
use Data::Dumper;

use Math::Complex;
use Math::Algebra::Symbols;

use lib "../../lib/perl";
use CifParser;
use AlterMolecule;

#
# Constants
#

my $PI = 4 * atan( 1, 1 );

#
# Test program, as argv, uses both attribute filter, attribute data selection
# info and mmCIF. In order test to be flexible, attribute information is
# entered in string form:
#
# "label_atom_id CA,CB & id 147, 148"
#
# and then parsed to such form:
#
# [ "label_atom_id" => [ "CA",  "CB"  ],
#   "id"            => [ "147", "148" ] ].
#
# Attribute data is selected in such form:
#
# "Cartn_x,Cartn_y,Cartn_z"
#
# The third argument is mmCIF format stdin.
#

my $attribute_filter = shift;
my $attribute_select = shift;
my $rotational_angle = shift;

# Parses selector argument from string  to proper array.
my @attribute_filter = [ map { $_->[0] => [ split( ",", @$_[1] ) ] }
                         map { [ split( " ", $_ ) ] }
                         split( "&", $attribute_filter ) ];
my @attribute_select = [ split( ",", $attribute_select ) ];
my @selected_atom_data = @{ CifParser::select_atom_data( @attribute_filter,
							 @attribute_select,
							 <> ) };

# Rotates once along chi angle.
my $rotated_atom_coord = AlterMolecule::rotate_bond( $selected_atom_data[0],
						     $selected_atom_data[1],
						     $selected_atom_data[2],
						     $selected_atom_data[3] );

# Evaluates symbolic expression.
my $pi = $PI;
my $chi = eval( $rotational_angle );
my $eval_expression;

# Rotates again along chi angle. The result should match the initial
# coordinates.
foreach( @$rotated_atom_coord ) {
    foreach( @$_ ) {
	foreach( @$_ ) {
	    $eval_expression = eval( $_ );
	    printf( "%.3f\n", $eval_expression );
	}
    }
}

#!/usr/bin/perl

use strict;
use warnings;
use Data::Dumper;

use lib "../../lib/perl";
use CifParser;
use LinearAlgebra;

my $attribute_filter = shift;
my $attribute_select = shift;
my @cif = <>;

# Parses selector argument from string  to proper array.
my @attribute_filter = [ map { $_->[0] => [ split( ",", @$_[1] ) ] }
                         map { [ split( " ", $_ ) ] }
                         split( "&", $attribute_filter ) ];
my @attribute_select = [ split( ",", $attribute_select ) ];
my @selected_atom_data =
    @{ CifParser::select_atom_data( @attribute_filter,
				    @attribute_select,
				    @cif ) };

# Prepares selected atom data for Jmol. First, brings atoms to the start (0,0,0)
# of reference frame and draws them.
# print( "data \"model\"\n" );
# print( scalar( grep { /ATOM/ } @cif ), "\n" );
# print( "testing\n" );

# map { print( $_->[2], " ",
# 	     $_->[10] - $selected_atom_data[1][0], " ",
# 	     $_->[11] - $selected_atom_data[1][1], " ",
# 	     $_->[12] - $selected_atom_data[1][2], "\n" ) }
# map { [ split( " ", $_ ) ] }
# grep { $_ =~ /ATOM/ }
# @cif;

# print( "end \"model\"\n" );

# Adds reference frame.
my @mid_atom_coord =  ( $selected_atom_data[1][0],
		        $selected_atom_data[1][1],
			$selected_atom_data[1][2] );
my @up_atom_coord =   ( $selected_atom_data[2][0],
			$selected_atom_data[2][1],
			$selected_atom_data[2][2] );
my @side_atom_coord = ( $selected_atom_data[0][0],
			$selected_atom_data[0][1],
			$selected_atom_data[0][2] );
my @local_ref_frame =
    LinearAlgebra::create_ref_frame( @mid_atom_coord,
				     @up_atom_coord,
				     @side_atom_coord );

# Finds Euler angles necessary for rotation matrix.
my ( $alpha, $beta, $gamma ) =
    LinearAlgebra::find_euler_angles( @mid_atom_coord,
				      @up_atom_coord,
				      @side_atom_coord );
my @rot_matrix_z = ( [ cos( $gamma ), - sin( $gamma ), 0, 0 ],
		     [ sin( $gamma ),   cos( $gamma ), 0, 0 ],
		     [ 0, 0, 1, 0 ],
		     [ 0, 0, 0, 1 ] );
my @rot_matrix_x = ( [ 1, 0, 0, 0 ],
		     [ 0, cos( $beta ), - sin( $beta ), 0 ],
		     [ 0, sin( $beta ),   cos( $beta ), 0 ],
		     [ 0, 0, 0, 1 ] );
my @rot_matrix_z_prime = ( [ cos( $alpha ), - sin( $alpha ), 0, 0 ],
			   [ sin( $alpha ),   cos( $alpha ), 0, 0 ],
			   [ 0, 0, 1, 0 ],
			   [ 0, 0, 0, 1 ] );

# Prepares reference frame coordinates for transformation.
my @symbols = ( "i" );

my @x_local_axis = 
    map { $_ }
    map { @$_ }
    $local_ref_frame[0];
my @y_local_axis = 
    map { $_ }
    map { @$_ }
    $local_ref_frame[1];
my @z_local_axis = 
    map { $_ }
    map { @$_ }
    $local_ref_frame[2];

push( @x_local_axis, 1 );
push( @y_local_axis, 1 );
push( @z_local_axis, 1 );

@x_local_axis = 
    map { [ $_ ] }
    @x_local_axis;
@y_local_axis = 
    map { [ $_ ] }
    @y_local_axis;
@z_local_axis = 
    map { [ $_ ] }
    @z_local_axis;

# Performs transformation.
@x_local_axis =
    LinearAlgebra::mult_matrix_product( \@symbols,
					\@rot_matrix_z_prime,
					\@rot_matrix_x,
					\@rot_matrix_z,
					\@x_local_axis );
@y_local_axis =
    LinearAlgebra::mult_matrix_product( \@symbols,
					\@rot_matrix_z_prime,
					\@rot_matrix_x,
					\@rot_matrix_z,
					\@y_local_axis );
@z_local_axis =
    LinearAlgebra::mult_matrix_product( \@symbols,
					\@rot_matrix_z_prime,
					\@rot_matrix_x,
					\@rot_matrix_z,
					\@z_local_axis );

# Draws atoms at the end of both local and global axes.
print( "data \"model\"\n"
       . "8\n"
       . "testing\n"
       . "X 0 0 0\n"
       . "O $x_local_axis[0][0][0] "
       . "$x_local_axis[0][1][0] "
       . "$x_local_axis[0][2][0]\n"
       . "N $y_local_axis[0][0][0] "
       . "$y_local_axis[0][1][0] "
       . "$y_local_axis[0][2][0]\n"
       . "MG $z_local_axis[0][0][0] "
       . "$z_local_axis[0][1][0] "
       . "$z_local_axis[0][2][0]\n"
       . "X 0 0 0\n"
       . "O 1 0 0\n"
       . "N 0 1 0\n"
       . "MG 0 0 1\n"
       . "end \"model\"\n" );

# Draws local axes.
print( "draw x_axis vector "
       . "{0 0 0} "
       . "{$x_local_axis[0][0][0],"
       . "$x_local_axis[0][1][0],"
       . "$x_local_axis[0][2][0]}\n" );
print( "draw y_axis vector "
       . "{0 0 0} "
       . "{$y_local_axis[0][0][0],"
       . "$y_local_axis[0][1][0],"
       . "$y_local_axis[0][2][0]}\n" );
print( "draw z_axis vector "
       . "{0 0 0} "
       . "{$z_local_axis[0][0][0],"
       . "$z_local_axis[0][1][0],"
       . "$z_local_axis[0][2][0]}\n" );

# Draws global axes.
print( "draw global_x_axis vector "
       . "{0 0 0} "
       . "{1 0 0}\n" );
print( "draw global_y_axis vector "
       . "{0 0 0} "
       . "{0 1 0}\n" );
print( "draw global_z_axis vector "
       . "{0 0 0} "
       . "{0 0 1}\n" );

# Turns off bond visualization.
print( "hide bonds\n" );

# Decreses size of atoms.
print( "spacefill 0.1\n" );


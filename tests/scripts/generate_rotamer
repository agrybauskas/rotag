#!/usr/bin/perl

use strict;
use warnings;

use LinearAlgebra qw( pi );
use PseudoAtoms qw( generate_rotamer );

#
# Unit test: PseudoAtoms::generate_rotamer
#                    residue_id angle_value
# Example: ./generate_pseudo 12 "chi0 0" structure.dump
#

my ( $residue_id, $angle_values, $pdbx_dump_file ) = @ARGV;

my $atom_site;
open( my $fh, "<", $pdbx_dump_file );
while( <$fh> ) {
    $atom_site .= "$_" ;
}
close( $fh );
$atom_site = eval( $atom_site );

# Parses angles for pseudo-rotamers.
my %angle_values = ( map { $_->[0] => $_->[1] }
		     map { [ split( " ", $_ ) ] }
		     split( "&", $angle_values ) );
for my $angle_value ( keys %angle_values ) {
    $angle_values{$angle_value} =~ s/pi/pi()/g;
    $angle_values{$angle_value} = eval( $angle_values{$angle_value} );
}
generate_rotamer( $atom_site, \%angle_values );
# %{ $atom_site } =
#     ( %{ $atom_site },
#       %{ generate_rotamer( $atom_site, \%angle_values ) } );

# # Prints out count of atoms and arbitrary word that are neccessary for Jmol.
# print( scalar( keys %{ $atom_site } ), "\n" );
# print( "testing\n" );

# # Prints out pseudo-atom coordinates.
# for my $atom_id ( sort { $a <=> $b } keys %{ $atom_site } ) {
#     printf( "$atom_site->{$atom_id}{\"type_symbol\"}" .
# 	    "\t%.3f\t%.3f\t%.3f\n",
# 	    $atom_site->{$atom_id}{"Cartn_x"},
# 	    $atom_site->{$atom_id}{"Cartn_y"},
# 	    $atom_site->{$atom_id}{"Cartn_z"} );
# }

#!/usr/bin/perl

use strict;
use warnings;

use lib "../../lib/perl";
use AlterMolecule qw( bond_stretching );
use LinearAlgebra qw( evaluate_matrix matrix_product vectorize );

use lib "../lib";
use Utils qw( select_atom_data );

#
# Unit test: AlterMolecule::bond_stretching.
#
# In Jmol, generates pseudo-atoms which represent positions of atom
# after the resize of the bond.
#
# Example: ./change_bond_length "label_atom_id CA,N,CB,OG" \
#                               "Cartn_x,Cartn_y,Cartn_z" \
#                               2.0 10 example.cif
#

my ( $atom_specifier,
     $data_specifier,
     $bond_min_max,
     $num_of_atoms,
     $pdbx_file ) = @ARGV;

# Selects atom's data for further analysis.
my $atom_coord = select_atom_data( $pdbx_file,
				   $atom_specifier,
				   $data_specifier );

# Prints out count of atoms and arbitrary word that are neccessary for Jmol.
open( my $fh, "<", $pdbx_file );
chomp( my @pdbx_lines = <$fh> );
close( $fh );

print( scalar( grep { /ATOM/ } @pdbx_lines ) + $num_of_atoms - 1, "\n" );
print( "testing\n" );

# Prepares selected atom data for Jmol.
map { print( $_->[2], "\t", $_->[10], "\t", $_->[11], "\t", $_->[12], "\n" ) }
map { [ split( " ", $_ ) ] }
grep { $_ =~ /ATOM/ }
@pdbx_lines;

# # Changes bond by certain distance.
# my $transl_atom_coord =
#     matrix_product( bond_stretching( $atom_coord->[1],
# 				     $atom_coord->[2],
# 				     $atom_coord->[0],
# 				     "r" ),
# 		    vectorize( $atom_coord->[3] ) );

# # Smallest change in bond length by given num_of_points and bond_min_max.
# my $smallest_length = $bond_min_max / $num_of_points;

# # Calculates the distance of the bond that will be translated along.
# my $r;

# my @delta_lengths =
#     map { $_ * $smallest_length, - ( $_ * $smallest_length ) }
#         ( 1..( $num_of_points - 1 ) / 2 );

# # Evaluates symbolic expression.
# my $eval_expression;

# # Translates along the bond and creates Jmol readable structure file.
# my %symbols;
# my $evaluated_matrix;

# for my $delta ( @delta_lengths ) {
#     $symbols{"r"} = "$delta";
#     $evaluated_matrix =
# 	evaluate_matrix( \%symbols,
# 			 &matrix_product( $transl_atom_coord ) );

#     for my $row ( $evaluated_matrix ) {
# 	print( "X\t" );
# 	for my $item ( @$row[0..2] ) {
# 	    printf( "%.3f\t", @$item );
# 	}
# 	print( "\n" );
#     }
# }

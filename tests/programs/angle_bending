#!/usr/bin/perl

use strict;
use warnings;

use lib "../../lib/perl";
use AlterMolecule qw( angle_bending );
use LinearAlgebra qw( evaluate_matrix matrix_product vectorize );

use lib "../lib";
use Utils qw( select_atom_data );

#
# Unit test: AlterMolecule::angle_bending.
#
# In Jmol, generates pseudo-atoms which represent positions of atom
# after the change of the angle between atoms.
#
# Example: ./change_bond_angle "label_atom_id CA,N,CB,OG" \
#                              "Cartn_x,Cartn_y,Cartn_z" \
#                              1.0 27 example.cif
#

my ( $atom_specifier,
     $data_specifier,
     $angle_min_max,
     $num_of_atoms,
     $pdbx_file ) = @ARGV;

# Selects atom's data for further analysis.
my $atom_coord = select_atom_data( $pdbx_file,
				   $atom_specifier,
				   $data_specifier );

# Prints out count of atoms and arbitrary word that are neccessary for Jmol.
open( my $fh, "<", $pdbx_file );
chomp( my @pdbx_lines = <$fh> );
close( $fh );

print( scalar( grep { /ATOM/ } @pdbx_lines ) + $num_of_atoms - 2, "\n" );
print( "testing\n" );

# Prepares selected atom data for Jmol.
map { print( $_->[2], "\t", $_->[10], "\t", $_->[11], "\t", $_->[12], "\n" ) }
map { [ split( " ", $_ ) ] }
grep { $_ =~ /ATOM/ }
@pdbx_lines;

# Creates transformation matrix that describes angle bending between two atoms.
my $transf_matrix =
    matrix_product( angle_bending( $atom_coord->[1],
				   $atom_coord->[2],
				   $atom_coord->[0],
				   "theta",
				   "psi" ),
		    vectorize( $atom_coord->[3] ) );

# Calculates angles that will be gradually changed.
my $small_angle = $angle_min_max / sqrt( $num_of_atoms );
my @angles =
    map { $_ * $small_angle, - ( $_ * $small_angle ) }
        ( 1..(sqrt($num_of_atoms)/2) );
push( @angles, 0 );

# Changes angle between two atoms by theta and psi angles numerically and creates
# Jmol readable file.
my %symbols;
my $eval_matrix;

for my $theta ( @angles ) {
    for my $psi ( @angles ) {
	%symbols = ( "theta" => $theta, "psi" => $psi );
	$eval_matrix = evaluate_matrix( $transf_matrix, \%symbols );
	printf( "X\t%.3f\t%.3f\t%.3f\n",
		$eval_matrix->[0][0],
		$eval_matrix->[1][0],
		$eval_matrix->[2][0] );
    }
}

#!/usr/bin/perl

use strict;
use warnings;

use Math::Trig;

use lib "../../lib/perl";
use AtomClashes qw( radius_only );
use CifParser qw( obtain_atom_site );
use PseudoAtoms qw( generate_pseudo );
use SidechainModels qw( rotation_only );

use lib "../lib";
use Utils qw( select_atom_data );
use Data::Dumper;
my ( $atom_specifier,
     $clash_specifier, # Selects atoms that will be filtered out, if clashes are
                       # detected.
     $angle_ranges,
     $num_of_angles,
     $cif_file ) = @ARGV;

# Selects atom's data for further analysis.
my $atom_site = obtain_atom_site( $cif_file );
my $target_atom_id = select_atom_data( $atom_specifier, "id", $cif_file );
$target_atom_id = $target_atom_id->[0][0];

# Parses selector argument from string  to proper array.
my %atom_specifier = ( map { $_->[0] => [ split( ",", @$_[1] ) ] }
		       map { [ split( " ", $_ ) ] }
		       split( "&", $atom_specifier ) );


# Parses selector argument from string  to proper array.
my %clash_specifier = ( map { $_->[0] => [ split( ",", @$_[1] ) ] }
		       map { [ split( " ", $_ ) ] }
		       split( "&", $clash_specifier ) );

# Parses angle ranges for
my %angle_ranges = ( map { $_->[0] => [ split( "-", @$_[1] ) ] }
		     map { [ split( " ", $_ ) ] }
		     split( "&", $angle_ranges ) );

# Parsed number of rotations that will be done for each dihedral angle.
my %num_of_angles = ( map { $_->[0] => $_->[1] }
		      map { [ split( " ", $_ ) ] }
		      split( "&", $num_of_angles ) );

# Calculates angles that will be rotated along.
my $pi = 4 * atan( 1, 1 );

my $min_angle;
my $max_angle;
my %num_angle_values;
my $small_change; # Change of angle in each rotation step.

for my $dihedral_angle ( sort keys %angle_ranges ) {
    $min_angle = $angle_ranges{"$dihedral_angle"}[0];
    $max_angle = $angle_ranges{"$dihedral_angle"}[1];
    $min_angle =~ s/pi/\$pi/g;
    $max_angle =~ s/pi/\$pi/g;
    $min_angle = eval( $min_angle );
    $max_angle = eval( $max_angle );
    if( $max_angle - $min_angle eq 0 ) {
	$small_change = 0;
	$num_angle_values{"$dihedral_angle"} = [ $min_angle ];
    } else {
	$small_change =
	    ( $max_angle - $min_angle ) / $num_of_angles{"$dihedral_angle"};
	for( my $angle = $min_angle;
	     $angle < $max_angle;
	     $angle = $angle + $small_change ) {
	    if( defined $num_angle_values{"$dihedral_angle"} ) {
		push( @{ $num_angle_values{"$dihedral_angle"} }, $angle );
	    } else {
		$num_angle_values{"$dihedral_angle"} = [ $angle ];
	    }
	}
    }
}

# In Jmol, generates pseudo-atoms which represent positions of atom
# after rotation along dihedral angle.
open( my $fh, "<", $cif_file );
chomp( my @cif_lines = <$fh> );
close( $fh );

# Creates pseudo-atoms for given analytical equation that describes conformation
# of atom. Atom clashes are flagged.
my $pseudo_atom_site =
    radius_only( generate_pseudo( rotation_only( $atom_site, \%atom_specifier ),
				  \%atom_specifier,
				  \%num_angle_values ), \%clash_specifier );

# Remove atoms that are flagged with clashes.
print Dumper $pseudo_atom_site;
# # Prints out count of atoms and arbitrary word that are neccessary for Jmol.
# print( scalar( keys %{ $pseudo_atom_site->{"data"} } ), "\n" );
# print( "testing\n" );

# # Prints out pseudo-atom coordinates.
# for my $id ( sort { $a <=> $b } keys %{ $pseudo_atom_site->{"data"} } ) {
#     printf( "$pseudo_atom_site->{\"data\"}{$id}{\"type_symbol\"}" .
# 	    "\t%.3f\t%.3f\t%.3f\n",
# 	    $pseudo_atom_site->{"data"}{$id}{"Cartn_x"},
# 	    $pseudo_atom_site->{"data"}{$id}{"Cartn_y"},
# 	    $pseudo_atom_site->{"data"}{$id}{"Cartn_z"} );
# }

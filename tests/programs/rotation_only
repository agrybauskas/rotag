#!/usr/bin/perl

use strict;
use warnings;

use lib "../../lib/perl";
use Combinatorics qw( permutation );
use LinearAlgebra qw( evaluate_matrix matrix_product pi );
use PDBxParser qw( filter_atoms obtain_atom_site );
use Sampling qw( sample_angles );
use SidechainModels qw( rotation_only );
use PseudoAtoms qw( generate_pseudo );

use lib "../lib";
use Utils qw( select_atom_data );

my ( $atom_specifier, $angle_ranges, $num_of_angles, $pdbx_file ) = @ARGV;

# Selects atom's data for further analysis.
my $atom_site = obtain_atom_site( $pdbx_file );
my $target_atom_id =
    select_atom_data( $pdbx_file, $atom_specifier, "id" )->[0][0];

# Parses selector argument from string  to proper array.
my %atom_specifier = ( map { $_->[0] => [ split( ",", @$_[1] ) ] }
		       map { [ split( " ", $_ ) ] }
		       split( "&", $atom_specifier ) );

# Parses angle ranges for dihedral angle of side-chain.
my %angle_ranges = ( map { $_->[0] => [ split( ",", @$_[1] ) ] }
		     map { [ split( " ", $_ ) ] }
		     split( "&", $angle_ranges ) );

# Parses number of rotations that will be done for each dihedral angle.
my %num_of_angles = ( map { $_->[0] => $_->[1] }
		      map { [ split( " ", $_ ) ] }
		      split( "&", $num_of_angles ) );

# Calculates angles that will be rotated along.
my $pi = pi();

my $min_angle;
my $max_angle;
my %num_angle_values; # Numeric angle values.
my $small_angle; # Change of angle in each rotation step.

for my $dihedral_angle ( sort keys %angle_ranges ) {
    $min_angle = $angle_ranges{"$dihedral_angle"}[0];
    $max_angle = $angle_ranges{"$dihedral_angle"}[1];
    $min_angle =~ s/pi/\$pi/g;
    $max_angle =~ s/pi/\$pi/g;
    $min_angle = eval( $min_angle );
    $max_angle = eval( $max_angle );
    $small_angle =
	2 * pi() / $num_of_angles{$dihedral_angle};
    $num_angle_values{"$dihedral_angle"} =
	sample_angles( [ [ $min_angle, $max_angle ] ], $small_angle );
}

# In Jmol, generates pseudo-atoms which represent positions of atom
# after rotation along dihedral angle.
open( my $fh, "<", $pdbx_file );
chomp( my @pdbx_lines = <$fh> );
close( $fh );

# Creates pseudo-atoms for given analytical equation that describes conformation
# of atom.
my $pseudo_atom_site =
    generate_pseudo( $atom_site, \%atom_specifier, \%num_angle_values );

# Prints out count of atoms and arbitrary word that are neccessary for Jmol.
print( scalar( keys %{ $pseudo_atom_site } ), "\n" );
print( "testing\n" );

# Prints out pseudo-atom coordinates.
for my $atom_id ( sort { $a <=> $b } keys %{ $pseudo_atom_site } ) {
    printf( "$pseudo_atom_site->{$atom_id}{\"type_symbol\"}" .
	    "\t%.3f\t%.3f\t%.3f\n",
	    $pseudo_atom_site->{$atom_id}{"Cartn_x"},
	    $pseudo_atom_site->{$atom_id}{"Cartn_y"},
	    $pseudo_atom_site->{$atom_id}{"Cartn_z"} );
}

#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;

use ForceField::Parameters;
use LinearAlgebra qw( create_ref_frame
                      find_euler_angles
                      mult_matrix_product
                      normalize
                      vector_cross
                      vector_length );
use Measure qw( bond_length
                bond_angle
                dihedral_angle );
use PDBxParser qw( extract
                   filter_new
                   obtain_atom_site );

#
# Unit test: LinearAlgebra::create_ref_frame
#            LinearAlgebra::find_euler_angles.
#
# Bring molecule's local frame of reference to global and visualizes it.
#
# Example: ./check_ref_frame -t 'label_atom_id N,CA,CB' example.cif
#

my %options;
my $to_query;
my $from_query = '';
my $bond_angle_query = '';
my $dihedral_angle_query = '';
my $bond_length_query = '';

GetOptions(
    "t=s" => \$to_query,
    "f=s" => \$from_query,
    "a=s" => \$bond_angle_query,
    "d=s" => \$dihedral_angle_query,
    "l=s" => \$bond_length_query,
) or die "Error in command line argument.";

@ARGV = ( "-" ) unless @ARGV;

my $parameters = Parameters->new();
my $sig_figs_max = $parameters->{'_[local]_constants'}{'sig_figs_max'};
my $pi = $parameters->{'_[local]_constants'}{'pi'};

$bond_angle_query =~ s/ //g;
$dihedral_angle_query =~ s/ //g;
$bond_length_query =~ s/ //g;

my ( $to_bond_angle, $from_bond_angle ) = split /;/, $bond_angle_query;
my ( $to_dihedral_angle, $from_dihedral_angle ) = split /;/, $dihedral_angle_query;
my ( $to_bond_length, $from_bond_length ) = split /;/, $bond_length_query;

$to_bond_angle //= 0.0;
$to_dihedral_angle //= 0.0;
$to_bond_length //= 0.0;
$from_bond_angle //= 0.0;
$from_dihedral_angle //= 0.0;
$from_bond_length //= 0.0;

foreach my $pdbx_file ( @ARGV ) {
    my $atom_site = obtain_atom_site( $pdbx_file );

    # Defines starting reference frame.
    my @from_mid_atom_coord =  ( 0.0, 0.0, 0.0 );
    my @from_up_atom_coord = ( 0.0, 0.0, 1.0 );
    my @from_side_atom_coord = ( 1.0, 0.0, 0.0 );

    if( $from_query ) {
        my %from_atom_specifier = ();
        foreach ( split '&', $from_query ) {
            my ( $label, $data ) = split ' ', $_;
            $from_atom_specifier{$label} = [ split ',', $data ];
        }

        my $from_atom_data =
            extract( filter_new( $atom_site,
                                 { 'include' => \%from_atom_specifier } ),
                     { 'data' => [ 'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );

        @from_mid_atom_coord =  ( $from_atom_data->[1][0],
                                  $from_atom_data->[1][1],
                                  $from_atom_data->[1][2] );
        @from_up_atom_coord =   ( $from_atom_data->[2][0],
                                  $from_atom_data->[2][1],
                                  $from_atom_data->[2][2] );
        @from_side_atom_coord = ( $from_atom_data->[0][0],
                                  $from_atom_data->[0][1],
                                  $from_atom_data->[0][2] );
    }

    # Selects atom's data for further analysis.
    my %to_atom_specifier = ();
    foreach ( split '&', $to_query ) {
        my ( $label, $data ) = split ' ', $_;
        $to_atom_specifier{$label} = [ split ',', $data ];
    }

    my $to_atom_data =
        extract( filter_new( $atom_site, { 'include' => \%to_atom_specifier } ),
                 { 'data' => [ 'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );

    # Finds Euler angles and makes rotational matrices.
    my @to_mid_atom_coord =  ( $to_atom_data->[1][0],
                               $to_atom_data->[1][1],
                               $to_atom_data->[1][2] );
    my @to_up_atom_coord =   ( $to_atom_data->[2][0],
                               $to_atom_data->[2][1],
                               $to_atom_data->[2][2] );
    my @to_side_atom_coord = ( $to_atom_data->[0][0],
                               $to_atom_data->[0][1],
                               $to_atom_data->[0][2] );

    print( "data \"model\"\n" );
    print( scalar( keys %{ $atom_site } ) + 4, "\n" );
    print( "testing\n" );

    for my $atom_id ( sort { $a <=> $b } keys %{ $atom_site } ) {
        my @atom_data = ( $atom_site->{$atom_id}{'type_symbol'},
                          $atom_site->{$atom_id}{'Cartn_x'},
                          $atom_site->{$atom_id}{'Cartn_y'},
                          $atom_site->{$atom_id}{'Cartn_z'} );
        my $atom_name = $atom_data[0];
        my @atom_coord = ( [ $atom_data[1] ],
                           [ $atom_data[2] ],
                           [ $atom_data[3] ] );
        printf( "%s $sig_figs_max $sig_figs_max $sig_figs_max\n",
                $atom_name,
                $atom_coord[0][0],
                $atom_coord[1][0],
                $atom_coord[2][0] );
    }

    my $from_local_ref_frame =
        create_ref_frame( \@from_mid_atom_coord,
                          \@from_up_atom_coord,
                          \@from_side_atom_coord );
    my $to_local_ref_frame =
        create_ref_frame( \@to_mid_atom_coord,
                          \@to_up_atom_coord,
                          \@to_side_atom_coord );

    my @origin_coord = ( [ $from_mid_atom_coord[0] ],
                         [ $from_mid_atom_coord[1] ],
                         [ $from_mid_atom_coord[2] ],
                         [ 1 ] );
    my @x_axis_coord = ( [ $from_mid_atom_coord[0] + $from_local_ref_frame->[0][0] ],
                         [ $from_mid_atom_coord[1] + $from_local_ref_frame->[0][1] ],
                         [ $from_mid_atom_coord[2] + $from_local_ref_frame->[0][2] ],
                         [ 1 ] );
    my @y_axis_coord = ( [ $from_mid_atom_coord[0] + $from_local_ref_frame->[1][0] ],
                         [ $from_mid_atom_coord[1] + $from_local_ref_frame->[1][1] ],
                         [ $from_mid_atom_coord[2] + $from_local_ref_frame->[1][2] ],
                         [ 1 ] );
    my @z_axis_coord = ( [ $from_mid_atom_coord[0] + $from_local_ref_frame->[2][0] ],
                         [ $from_mid_atom_coord[1] + $from_local_ref_frame->[2][1] ],
                         [ $from_mid_atom_coord[2] + $from_local_ref_frame->[2][2] ],
                         [ 1 ] );

    @origin_coord =
        @{ transform_coord(
               $parameters,
               \@origin_coord,
               \@from_mid_atom_coord, \@to_mid_atom_coord,
               $from_local_ref_frame, $to_local_ref_frame,
               $from_bond_angle, $from_dihedral_angle, $from_bond_length,
               $to_bond_angle, $to_dihedral_angle, $to_bond_length )->[0] };
    @x_axis_coord =
        @{ transform_coord(
               $parameters,
               \@x_axis_coord,
               \@from_mid_atom_coord, \@to_mid_atom_coord,
               $from_local_ref_frame, $to_local_ref_frame,
               $from_bond_angle, $from_dihedral_angle, $from_bond_length,
               $to_bond_angle, $to_dihedral_angle, $to_bond_length )->[0] };
    @y_axis_coord =
        @{ transform_coord(
               $parameters,
               \@y_axis_coord,
               \@from_mid_atom_coord, \@to_mid_atom_coord,
               $from_local_ref_frame, $to_local_ref_frame,
               $from_bond_angle, $from_dihedral_angle, $from_bond_length,
               $to_bond_angle, $to_dihedral_angle, $to_bond_length )->[0] };
    @z_axis_coord =
        @{ transform_coord(
               $parameters,
               \@z_axis_coord,
               \@from_mid_atom_coord, \@to_mid_atom_coord,
               $from_local_ref_frame, $to_local_ref_frame,
               $from_bond_angle, $from_dihedral_angle, $from_bond_length,
               $to_bond_angle, $to_dihedral_angle, $to_bond_length )->[0] };

    # Draws atoms on the end of axes.
    print( "X $origin_coord[0][0] $origin_coord[1][0] $origin_coord[2][0]\n" .
           "X $x_axis_coord[0][0] $x_axis_coord[1][0] $x_axis_coord[2][0]\n" .
           "X $y_axis_coord[0][0] $y_axis_coord[1][0] $y_axis_coord[2][0]\n" .
           "X $z_axis_coord[0][0] $z_axis_coord[1][0] $z_axis_coord[2][0]\n" );

    print( "end \"model\"\n" );

    # Draws global axes.
    print( "draw global_x_axis arrow "
           . "{$origin_coord[0][0] $origin_coord[1][0] $origin_coord[2][0]} "
           . "{$x_axis_coord[0][0] $x_axis_coord[1][0] $x_axis_coord[2][0]}\n" );
    print( "draw global_y_axis arrow "
           . "{$origin_coord[0][0] $origin_coord[1][0] $origin_coord[2][0]} "
           . "{$y_axis_coord[0][0] $y_axis_coord[1][0] $y_axis_coord[2][0]}\n" );
    print( "draw global_z_axis arrow "
           . "{$origin_coord[0][0] $origin_coord[1][0] $origin_coord[2][0]} "
           . "{$z_axis_coord[0][0] $z_axis_coord[1][0] $z_axis_coord[2][0]}\n" );

    # Colors axes.
    print( "color \$global_x_axis red\n" );
    print( "color \$global_y_axis green\n" );
    print( "color \$global_z_axis blue\n" );
}

sub transform_coord
{
    my ( $parameters, $atom_coord,
         $from_mid_atom_coord, $to_mid_atom_coord,
         $from_local_ref_frame, $to_local_ref_frame,
         $from_bond_angle, $from_dihedral_angle, $from_bond_length,
         $to_bond_angle, $to_dihedral_angle, $to_bond_length ) = @_;

    my $pi = $parameters->{'_[local]_constants'}{'pi'};
    my $epsilon = $parameters->{'_[local]_constants'}{'epsilon'};

    my ( $from_alpha, $from_beta, $from_gamma ) =
        @{ find_euler_angles( $parameters,
                              $from_mid_atom_coord,
                              $from_local_ref_frame->[2],
                              $from_local_ref_frame->[1] ) };
    my ( $to_alpha, $to_beta, $to_gamma ) =
        @{ find_euler_angles( $parameters,
                              $to_mid_atom_coord,
                              $to_local_ref_frame->[2],
                              $to_local_ref_frame->[1] ) };

    my $a = 0.0;
    my $d = 0.0;

    my ( $cn_start, $cn_end ) =
        common_normal( $from_mid_atom_coord,
                       $from_local_ref_frame->[2],
                       $to_mid_atom_coord,
                       $to_local_ref_frame->[2] );

    # my $alpha = $to_alpha - $from_alpha;
    # my $theta = $to_beta - $from_beta;
    my $alpha =
        dihedral_angle( [ [ $from_local_ref_frame->[0][0] + $from_mid_atom_coord->[0],
                            $from_local_ref_frame->[0][1] + $from_mid_atom_coord->[1],
                            $from_local_ref_frame->[0][2] + $from_mid_atom_coord->[2] ],
                          $from_mid_atom_coord,
                          $to_mid_atom_coord,
                          [ $to_local_ref_frame->[0][0] + $to_mid_atom_coord->[0],
                            $to_local_ref_frame->[0][1] + $to_mid_atom_coord->[1],
                            $to_local_ref_frame->[0][2] + $to_mid_atom_coord->[2] ] ] );
    my $theta =
        bond_angle( [ $from_mid_atom_coord,
                      $to_mid_atom_coord,
                      [ $to_local_ref_frame->[2][0] + $to_mid_atom_coord->[0],
                        $to_local_ref_frame->[2][1] + $to_mid_atom_coord->[1],
                        $to_local_ref_frame->[2][2] + $to_mid_atom_coord->[2] ] ] );

    # Homogeneous transformation:
    # H = Rot_{x,\alpha} \cdot Trans_{x,a} \cdot Rot_{z,\theta}
    my @transformed_atom_coord =
        @{ mult_matrix_product(
               # [ [ [ 1.0, 0.0, 0.0, $to_mid_atom_coord->[0] - $from_mid_atom_coord->[0] ],
               #     [ 0.0, 1.0, 0.0, $to_mid_atom_coord->[1] - $from_mid_atom_coord->[1] ],
               #     [ 0.0, 0.0, 1.0, $to_mid_atom_coord->[2] - $from_mid_atom_coord->[2] ],
               #     [ 0.0, 0.0, 0.0, 1.0 ] ],
               # [ [ [ cos( $theta ),
               #       - sin( $theta ) * cos( $alpha ),
               #       sin( $theta ) * sin( $alpha ),
               #       $a * cos( $theta ) ],
               #     [ sin( $theta ),
               #       cos( $theta ) * cos( $alpha ),
               #       - cos( $theta ) * sin( $alpha ),
               #       $a * sin( $theta ) ],
               #     [ 0,
               #       sin( $alpha ),
               #       cos( $alpha ),
               #       $d ],
               #     [ 0.0,
               #       0.0,
               #       0.0,
               #       1.0 ] ],
               [ [ [ cos( $theta ),
                     - sin( $theta ),
                     0.0,
                     $a ],
                   [ sin( $theta ) * cos( $alpha ),
                     cos( $theta ) * cos( $alpha ),
                     - sin( $alpha ),
                     - $d * sin( $alpha ) ],
                   [ sin( $theta ) * sin( $alpha ),
                     cos( $theta ) * sin( $alpha ),
                     cos( $alpha ),
                     $d * cos( $alpha ) ],
                   [ 0.0,
                     0.0,
                     0.0,
                     1.0 ] ],
                 $atom_coord ] ) };
    return \@transformed_atom_coord;
}

# We are trying to find a vector that is perpendicular to both A and B
# vectors.

sub common_normal
{
    my ( $A_0, $A, $B_0, $B ) = @_;

    # In order to get DH parameters the system of equations has to be solved in
    # order to get common normal vector.
    #
    # A_i = A_0 + a * A
    # B_i = B_0 + b * B
    # A * (B_i - A_i) = 0
    # B * (B_i - A_i) = 0
    #

    # Precalculating parameters for efficiency.
    my $dot_A_B = $A->[0] * $B->[0] + $A->[1] * $B->[1] + $A->[2] * $B->[2];
    my $beta = ( $A->[0]**2 + $A->[1]**2 + $A->[1]**2 ) / $dot_A_B;
    my $gamma = ( $A->[0] * $A_0->[0] - $A->[0] * $B_0->[0] +
                  $A->[1] * $A_0->[1] - $A->[1] * $B_0->[1] +
                  $A->[2] * $A_0->[2] - $A->[2] * $B_0->[2] ) / $dot_A_B;

    my $a =
        ( - $B->[0] * $B_0->[0] - $gamma * ( $B->[0]**2 ) + $B->[0] * $A_0->[0] -
            $B->[1] * $B_0->[1] - $gamma * ( $B->[1]**2 ) + $B->[1] * $A_0->[1] -
            $B->[2] * $B_0->[2] - $gamma * ( $B->[2]**2 ) + $B->[2] * $A_0->[2] ) /
        ( $beta * ( $B->[0]**2 ) - $B->[0] * $A->[0] +
          $beta * ( $B->[1]**2 ) - $B->[1] * $A->[1] +
          $beta * ( $B->[2]**2 ) - $B->[2] * $A->[2] );
    my $b = $a * $beta + $gamma;

    my $A_i = [ $A_0->[0] + $a * $A->[0],
                $A_0->[1] + $a * $A->[1],
                $A_0->[2] + $a * $A->[2] ];
    my $B_i = [ $B_0->[0] + $b * $B->[0],
                $B_0->[1] + $b * $B->[1],
                $B_0->[2] + $b * $B->[2] ];

    return $A_i, $B_i;
}

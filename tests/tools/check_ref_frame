#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;

use ForceField::Parameters;
use LinearAlgebra qw( create_ref_frame
                      find_euler_angles
                      mult_matrix_product
                      normalize
                      vector_cross
                      vector_length );
use PDBxParser qw( extract
                   filter_new
                   obtain_atom_site );

#
# Unit test: LinearAlgebra::create_ref_frame
#            LinearAlgebra::find_euler_angles.
#
# Bring molecule's local frame of reference to global and visualizes it.
#
# Example: ./check_ref_frame -t 'label_atom_id N,CA,CB' example.cif
#

my %options;
my $to_query;
my $from_query = '';
my $bond_angle_query = '';
my $dihedral_angle_query = '';
my $bond_length_query = '';

GetOptions(
    "t=s" => \$to_query,
    "f=s" => \$from_query,
    "a=s" => \$bond_angle_query,
    "d=s" => \$dihedral_angle_query,
    "l=s" => \$bond_length_query,
) or die "Error in command line argument.";

@ARGV = ( "-" ) unless @ARGV;

my $parameters = Parameters->new();
my $sig_figs_max = $parameters->{'_[local]_constants'}{'sig_figs_max'};
my $pi = $parameters->{'_[local]_constants'}{'pi'};

$bond_angle_query =~ s/ //g;
$dihedral_angle_query =~ s/ //g;
$bond_length_query =~ s/ //g;

my ( $to_bond_angle, $from_bond_angle ) = split /;/, $bond_angle_query;
my ( $to_dihedral_angle, $from_dihedral_angle ) = split /;/, $dihedral_angle_query;
my ( $to_bond_length, $from_bond_length ) = split /;/, $bond_length_query;

$to_bond_angle //= 0.0;
$to_dihedral_angle //= 0.0;
$to_bond_length //= 0.0;
$from_bond_angle //= 0.0;
$from_dihedral_angle //= 0.0;
$from_bond_length //= 0.0;

foreach my $pdbx_file ( @ARGV ) {
    my $atom_site = obtain_atom_site( $pdbx_file );

    my @origin_coord = ( [ 0.0 ], [ 0.0 ], [ 0.0 ], [ 1 ] );
    my @x_axis_coord = ( [ 2.0 ], [ 0.0 ], [ 0.0 ], [ 1 ] );
    my @y_axis_coord = ( [ 0.0 ], [ 2.0 ], [ 0.0 ], [ 1 ] );
    my @z_axis_coord = ( [ 0.0 ], [ 0.0 ], [ 2.0 ], [ 1 ] );

    # Defines starting reference frame.
    my @from_mid_atom_coord =  ( 0.0, 0.0, 0.0 );
    my @from_up_atom_coord = ( 0.0, 0.0, 1.0 );
    my @from_side_atom_coord = ( 1.0, 0.0, 0.0 );

    if( $from_query ) {
        my %from_atom_specifier = ();
        foreach ( split '&', $from_query ) {
            my ( $label, $data ) = split ' ', $_;
            $from_atom_specifier{$label} = [ split ',', $data ];
        }

        my $from_atom_data =
            extract( filter_new( $atom_site,
                                 { 'include' => \%from_atom_specifier } ),
                     { 'data' => [ 'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );

        @from_mid_atom_coord =  ( $from_atom_data->[1][0],
                                  $from_atom_data->[1][1],
                                  $from_atom_data->[1][2] );
        @from_up_atom_coord =   ( $from_atom_data->[2][0],
                                  $from_atom_data->[2][1],
                                  $from_atom_data->[2][2] );
        @from_side_atom_coord = ( $from_atom_data->[0][0],
                                  $from_atom_data->[0][1],
                                  $from_atom_data->[0][2] );
    }

    # Selects atom's data for further analysis.
    my %to_atom_specifier = ();
    foreach ( split '&', $to_query ) {
        my ( $label, $data ) = split ' ', $_;
        $to_atom_specifier{$label} = [ split ',', $data ];
    }

    my $to_atom_data =
        extract( filter_new( $atom_site, { 'include' => \%to_atom_specifier } ),
                 { 'data' => [ 'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );

    # Finds Euler angles and makes rotational matrices.
    my @to_mid_atom_coord =  ( $to_atom_data->[1][0],
                               $to_atom_data->[1][1],
                               $to_atom_data->[1][2] );
    my @to_up_atom_coord =   ( $to_atom_data->[2][0],
                               $to_atom_data->[2][1],
                               $to_atom_data->[2][2] );
    my @to_side_atom_coord = ( $to_atom_data->[0][0],
                               $to_atom_data->[0][1],
                               $to_atom_data->[0][2] );

    print( "data \"model\"\n" );
    print( scalar( keys %{ $atom_site } ) + 4, "\n" );
    print( "testing\n" );

    for my $atom_id ( sort { $a <=> $b } keys %{ $atom_site } ) {
        my @atom_data = ( $atom_site->{$atom_id}{'type_symbol'},
                          $atom_site->{$atom_id}{'Cartn_x'},
                          $atom_site->{$atom_id}{'Cartn_y'},
                          $atom_site->{$atom_id}{'Cartn_z'} );
        my $atom_name = $atom_data[0];
        my @atom_coord = ( [ $atom_data[1] ],
                           [ $atom_data[2] ],
                           [ $atom_data[3] ] );
        printf( "%s $sig_figs_max $sig_figs_max $sig_figs_max\n",
                $atom_name,
                $atom_coord[0][0],
                $atom_coord[1][0],
                $atom_coord[2][0] );
    }

    my $from_local_ref_frame =
        create_ref_frame( \@from_mid_atom_coord,
                          \@from_up_atom_coord,
                          \@from_side_atom_coord );
    my $to_local_ref_frame =
        create_ref_frame( \@to_mid_atom_coord,
                          \@to_up_atom_coord,
                          \@to_side_atom_coord );

    @origin_coord =
        @{ transform_coord(
               $parameters,
               \@origin_coord,
               $from_local_ref_frame, $to_local_ref_frame,
               $from_bond_angle, $from_dihedral_angle, $from_bond_length,
               $to_bond_angle, $to_dihedral_angle, $to_bond_length )->[0] };
    @x_axis_coord =
        @{ transform_coord(
               $parameters,
               \@x_axis_coord,
               $from_local_ref_frame, $to_local_ref_frame,
               $from_bond_angle, $from_dihedral_angle, $from_bond_length,
               $to_bond_angle, $to_dihedral_angle, $to_bond_length )->[0] };
    @y_axis_coord =
        @{ transform_coord(
               $parameters,
               \@y_axis_coord,
               $from_local_ref_frame, $to_local_ref_frame,
               $from_bond_angle, $from_dihedral_angle, $from_bond_length,
               $to_bond_angle, $to_dihedral_angle, $to_bond_length )->[0] };
    @z_axis_coord =
        @{ transform_coord(
               $parameters,
               \@z_axis_coord,
               $from_local_ref_frame, $to_local_ref_frame,
               $from_bond_angle, $from_dihedral_angle, $from_bond_length,
               $to_bond_angle, $to_dihedral_angle, $to_bond_length )->[0] };

    # Draws atoms on the end of axes.
    print( "X $origin_coord[0][0] $origin_coord[1][0] $origin_coord[2][0]\n" .
           "X $x_axis_coord[0][0] $x_axis_coord[1][0] $x_axis_coord[2][0]\n" .
           "X $y_axis_coord[0][0] $y_axis_coord[1][0] $y_axis_coord[2][0]\n" .
           "X $z_axis_coord[0][0] $z_axis_coord[1][0] $z_axis_coord[2][0]\n" );

    print( "end \"model\"\n" );

    # Draws global axes.
    print( "draw global_x_axis arrow "
           . "{$origin_coord[0][0] $origin_coord[1][0] $origin_coord[2][0]} "
           . "{$x_axis_coord[0][0] $x_axis_coord[1][0] $x_axis_coord[2][0]}\n" );
    print( "draw global_y_axis arrow "
           . "{$origin_coord[0][0] $origin_coord[1][0] $origin_coord[2][0]} "
           . "{$y_axis_coord[0][0] $y_axis_coord[1][0] $y_axis_coord[2][0]}\n" );
    print( "draw global_z_axis arrow "
           . "{$origin_coord[0][0] $origin_coord[1][0] $origin_coord[2][0]} "
           . "{$z_axis_coord[0][0] $z_axis_coord[1][0] $z_axis_coord[2][0]}\n" );

    # Colors axes.
    print( "color \$global_x_axis red\n" );
    print( "color \$global_y_axis green\n" );
    print( "color \$global_z_axis blue\n" );
}

sub transform_coord
{
    my ( $parameters, $atom_coord, $from_local_ref_frame, $to_local_ref_frame,
         $from_bond_angle, $from_dihedral_angle, $from_bond_length,
         $to_bond_angle, $to_dihedral_angle, $to_bond_length ) = @_;

    my $pi = $parameters->{'_[local]_constants'}{'pi'};
    my $epsilon = $parameters->{'_[local]_constants'}{'epsilon'};

    my $common_normal =
        vector_cross( $from_local_ref_frame->[2], $to_local_ref_frame->[2] );
    my $common_normal_normalized =
        normalize( [ [ $common_normal->[0] ],
                     [ $common_normal->[1] ],
                     [ $common_normal->[2] ] ] );

    my $alpha = 0.0;
    my $theta = 0.0;
    my $a = vector_length( [ [ $common_normal->[0] ],
                             [ $common_normal->[1] ],
                             [ $common_normal->[2] ] ] );
    my $d = 0.0;
    my @transformed_atom_coord =
        @{ mult_matrix_product(
               [ [ [ cos( $theta ),
                     - sin( $theta ),
                     0.0,
                     $a ],
                   [ sin( $theta ) * cos( $alpha ),
                     cos( $theta ) * cos( $alpha ),
                     - sin( $alpha ),
                     - $d * sin( $alpha ) ],
                   [ sin( $theta ) * sin( $alpha ),
                     cos( $theta ) * sin( $alpha ),
                     cos( $alpha ),
                     $d * cos( $alpha ) ],
                   [ 0.0,
                     0.0,
                     0.0,
                     1.0 ] ],
                 $atom_coord ] ) };
    return \@transformed_atom_coord;
}

#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;

use ForceField::Parameters;
use LinearAlgebra qw( find_euler_angles
                      mult_matrix_product
                      translation
                      x_axis_rotation
                      y_axis_rotation
                      z_axis_rotation );
use PDBxParser qw( extract
                   filter_new
                   obtain_atom_site );

#
# Unit test: LinearAlgebra::create_ref_frame
#            LinearAlgebra::find_euler_angles.
#
# Bring molecule's local frame of reference to global and visualizes it.
#
# Example: ./check_ref_frame -t 'label_atom_id N,CA,CB' example.cif
#

my %options;
my $to_query;
my $from_query = '';
my $bond_angle_query = '';
my $dihedral_angle_query = '';
my $bond_length_query = '';

GetOptions(
    "t=s" => \$to_query,
    "f=s" => \$from_query,
    "a=s" => \$bond_angle_query,
    "d=s" => \$dihedral_angle_query,
    "l=s" => \$bond_length_query,
) or die "Error in command line argument.";

@ARGV = ( "-" ) unless @ARGV;

my $parameters = Parameters->new();
my $sig_figs_max = $parameters->{'_[local]_constants'}{'sig_figs_max'};
my $pi = $parameters->{'_[local]_constants'}{'pi'};

$bond_angle_query =~ s/ //g;
$dihedral_angle_query =~ s/ //g;
$bond_length_query =~ s/ //g;

my ( $to_bond_angle, $from_bond_angle ) = split /;/, $bond_angle_query;
my ( $to_dihedral_angle, $from_dihedral_angle ) = split /;/, $dihedral_angle_query;
my ( $to_bond_length, $from_bond_length ) = split /;/, $bond_length_query;

$to_bond_angle //= 0.0;
$to_dihedral_angle //= 0.0;
$to_bond_length //= 0.0;
$from_bond_angle //= 0.0;
$from_dihedral_angle //= 0.0;
$from_bond_length //= 0.0;

foreach my $pdbx_file ( @ARGV ) {
    my $atom_site = obtain_atom_site( $pdbx_file );

    # Origin reference frame.
    my @from_mid_atom_coord =  ( 0.0, 0.0, 0.0 );
    my @from_up_atom_coord = ( 0.0, 0.0, 1.0 );
    my @from_side_atom_coord = ( 1.0, 0.0, 0.0 );

    my @from_origin_coord = ( [ 0.0 ], [ 0.0 ], [ 0.0 ], [ 1 ] );
    my @from_x_axis_coord = ( [ 2.0 ], [ 0.0 ], [ 0.0 ], [ 1 ] );
    my @from_y_axis_coord = ( [ 0.0 ], [ 2.0 ], [ 0.0 ], [ 1 ] );
    my @from_z_axis_coord = ( [ 0.0 ], [ 0.0 ], [ 2.0 ], [ 1 ] );

    # Determines the references frame where transformations might happen.
    my $from_alpha = 0.0;
    my $from_beta = 0.0;
    my $from_gamma = 0.0;

    if( $from_query ) {
        my %from_atom_specifier = ();
        foreach ( split '&', $from_query ) {
            my ( $label, $data ) = split ' ', $_;
            $from_atom_specifier{$label} = [ split ',', $data ];
        }

        my $from_atom_data =
            extract( filter_new( $atom_site,
                                 { 'include' => \%from_atom_specifier } ),
                     { 'data' => [ 'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );

        @from_mid_atom_coord =  ( $from_atom_data->[1][0],
                                  $from_atom_data->[1][1],
                                  $from_atom_data->[1][2] );
        @from_up_atom_coord =   ( $from_atom_data->[2][0],
                                  $from_atom_data->[2][1],
                                  $from_atom_data->[2][2] );
        @from_side_atom_coord = ( $from_atom_data->[0][0],
                                  $from_atom_data->[0][1],
                                  $from_atom_data->[0][2] );

        ( $from_alpha, $from_beta, $from_gamma ) =
            @{ find_euler_angles( $parameters,
                                  \@from_mid_atom_coord,
                                  \@from_up_atom_coord,
                                  \@from_side_atom_coord ) };

        @from_origin_coord =
            @{ transform_coord( \@from_origin_coord,
                                \@from_mid_atom_coord,
                                [ 0.0, 0.0, 0.0 ],
                                $from_alpha, $from_beta, $from_gamma,
                                0.0, 0.0, 0.0,
                                0.0, 0.0, 0.0 )->[0] };
        @from_x_axis_coord =
            @{ transform_coord( \@from_x_axis_coord,
                                \@from_mid_atom_coord,
                                [ 0.0, 0.0, 0.0 ],
                                $from_alpha, $from_beta, $from_gamma,
                                0.0, 0.0, 0.0,
                                0.0, 0.0, 0.0 )->[0] };
        @from_y_axis_coord =
            @{ transform_coord( \@from_y_axis_coord,
                                \@from_mid_atom_coord,
                                [ 0.0, 0.0, 0.0 ],
                                $from_alpha, $from_beta, $from_gamma,
                                0.0, 0.0, 0.0,
                                0.0, 0.0, 0.0 )->[0] };
        @from_z_axis_coord =
            @{ transform_coord( \@from_z_axis_coord,
                                \@from_mid_atom_coord,
                                [ 0.0, 0.0, 0.0 ],
                                $from_alpha, $from_beta, $from_gamma,
                                0.0, 0.0, 0.0,
                                0.0, 0.0, 0.0 )->[0] };
    }

    # Selects atom's data for further analysis.
    my %to_atom_specifier = ();
    foreach ( split '&', $to_query ) {
        my ( $label, $data ) = split ' ', $_;
        $to_atom_specifier{$label} = [ split ',', $data ];
    }

    my $to_atom_data =
        extract( filter_new( $atom_site, { 'include' => \%to_atom_specifier } ),
                 { 'data' => [ 'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );

    # Finds Euler angles and makes rotational matrices.
    my @to_mid_atom_coord =  ( $to_atom_data->[1][0],
                               $to_atom_data->[1][1],
                               $to_atom_data->[1][2] );
    my @to_up_atom_coord =   ( $to_atom_data->[2][0],
                               $to_atom_data->[2][1],
                               $to_atom_data->[2][2] );
    my @to_side_atom_coord = ( $to_atom_data->[0][0],
                               $to_atom_data->[0][1],
                               $to_atom_data->[0][2] );

    my ( $to_alpha, $to_beta, $to_gamma ) =
        @{ find_euler_angles( $parameters,
                              \@to_mid_atom_coord,
                              \@to_up_atom_coord,
                              \@to_side_atom_coord ) };

    print( "data \"model\"\n" );
    print( scalar( keys %{ $atom_site } ) + 8, "\n" );
    print( "testing\n" );

    for my $atom_id ( sort { $a <=> $b } keys %{ $atom_site } ) {
        my @atom_data = ( $atom_site->{$atom_id}{'type_symbol'},
                          $atom_site->{$atom_id}{'Cartn_x'},
                          $atom_site->{$atom_id}{'Cartn_y'},
                          $atom_site->{$atom_id}{'Cartn_z'});
        my $atom_name = $atom_data[0];
        my @atom_coord = ( [ $atom_data[1] ],
                           [ $atom_data[2] ],
                           [ $atom_data[3] ] );
        printf( "%s $sig_figs_max $sig_figs_max $sig_figs_max\n",
                $atom_name,
                $atom_coord[0][0],
                $atom_coord[1][0],
                $atom_coord[2][0] );
    }

    my @to_origin_coord =
        @{ transform_coord( \@from_origin_coord,
                            \@to_mid_atom_coord,
                            [ 0.0, 0.0, 0.0 ],
                            $to_alpha, $to_beta, $to_gamma,
                            $from_alpha, $from_beta, $from_gamma,
                            $to_bond_angle, $to_dihedral_angle, $to_bond_length )->[0] };
    my @to_x_axis_coord =
        @{ transform_coord( \@from_x_axis_coord,
                            \@to_mid_atom_coord,
                            [ 0.0, 0.0, 0.0 ],
                            $to_alpha, $to_beta, $to_gamma,
                            $from_alpha, $from_beta, $from_gamma,
                            $to_bond_angle, $to_dihedral_angle, $to_bond_length )->[0] };
    my @to_y_axis_coord =
        @{ transform_coord( \@from_y_axis_coord,
                            \@to_mid_atom_coord,
                            [ 0.0, 0.0, 0.0 ],
                            $to_alpha, $to_beta, $to_gamma,
                            $from_alpha, $from_beta, $from_gamma,
                            $to_bond_angle, $to_dihedral_angle, $to_bond_length )->[0] };
    my @to_z_axis_coord =
        @{ transform_coord( \@from_z_axis_coord,
                            \@to_mid_atom_coord,
                            [ 0.0, 0.0, 0.0 ],
                            $to_alpha, $to_beta, $to_gamma,
                            $from_alpha, $from_beta, $from_gamma,
                            $to_bond_angle, $to_dihedral_angle, $to_bond_length )->[0] };

    # Draws atoms on the end of axes.
    print( "X $from_origin_coord[0][0] $from_origin_coord[1][0] $from_origin_coord[2][0]\n" .
           "X $from_x_axis_coord[0][0] $from_x_axis_coord[1][0] $from_x_axis_coord[2][0]\n" .
           "X $from_y_axis_coord[0][0] $from_y_axis_coord[1][0] $from_y_axis_coord[2][0]\n" .
           "X $from_z_axis_coord[0][0] $from_z_axis_coord[1][0] $from_z_axis_coord[2][0]\n" );
    print( "X $to_origin_coord[0][0] $to_origin_coord[1][0] $to_origin_coord[2][0]\n" .
           "X $to_x_axis_coord[0][0] $to_x_axis_coord[1][0] $to_x_axis_coord[2][0]\n" .
           "X $to_y_axis_coord[0][0] $to_y_axis_coord[1][0] $to_y_axis_coord[2][0]\n" .
           "X $to_z_axis_coord[0][0] $to_z_axis_coord[1][0] $to_z_axis_coord[2][0]\n" );

    print( "end \"model\"\n" );

    # Draws global axes.
    print( "draw from_global_x_axis arrow "
           . "{$from_origin_coord[0][0] $from_origin_coord[1][0] $from_origin_coord[2][0]} "
           . "{$from_x_axis_coord[0][0] $from_x_axis_coord[1][0] $from_x_axis_coord[2][0]}\n" );
    print( "draw from_global_y_axis arrow "
           . "{$from_origin_coord[0][0] $from_origin_coord[1][0] $from_origin_coord[2][0]} "
           . "{$from_y_axis_coord[0][0] $from_y_axis_coord[1][0] $from_y_axis_coord[2][0]}\n" );
    print( "draw from_global_z_axis arrow "
           . "{$from_origin_coord[0][0] $from_origin_coord[1][0] $from_origin_coord[2][0]} "
           . "{$from_z_axis_coord[0][0] $from_z_axis_coord[1][0] $from_z_axis_coord[2][0]}\n" );
    print( "draw to_global_x_axis arrow "
           . "{$to_origin_coord[0][0] $to_origin_coord[1][0] $to_origin_coord[2][0]} "
           . "{$to_x_axis_coord[0][0] $to_x_axis_coord[1][0] $to_x_axis_coord[2][0]}\n" );
    print( "draw to_global_y_axis arrow "
           . "{$to_origin_coord[0][0] $to_origin_coord[1][0] $to_origin_coord[2][0]} "
           . "{$to_y_axis_coord[0][0] $to_y_axis_coord[1][0] $to_y_axis_coord[2][0]}\n" );
    print( "draw to_global_z_axis arrow "
           . "{$to_origin_coord[0][0] $to_origin_coord[1][0] $to_origin_coord[2][0]} "
           . "{$to_z_axis_coord[0][0] $to_z_axis_coord[1][0] $to_z_axis_coord[2][0]}\n" );

    # Colors axes.
    print( "color \$from_global_x_axis red\n" );
    print( "color \$from_global_y_axis green\n" );
    print( "color \$from_global_z_axis blue\n" );
    print( "color \$to_global_x_axis red\n" );
    print( "color \$to_global_y_axis green\n" );
    print( "color \$to_global_z_axis blue\n" );
}

sub transform_coord
{
    my ( $atom_coord,
         $to_mid_atom_coord,
         $from_mid_atom_coord,
         $to_alpha, $to_beta, $to_gamma,
         $from_alpha, $from_beta, $from_gamma,
         $to_bond_angle, $to_dihedral_angle, $to_bond_length ) = @_;
    my @transformed_atom_coord =
        @{ mult_matrix_product(
               [ translation( $to_mid_atom_coord->[0],
                              $to_mid_atom_coord->[1],
                              $to_mid_atom_coord->[2] ),
                 z_axis_rotation( - $to_gamma + $from_gamma ),
                 # x_axis_rotation( $pi * $ref_bond_angle / 180.0 ),
                 x_axis_rotation( - $to_beta + $from_beta ),
                 # z_axis_rotation( $pi * $ref_dihedral_angle / 180.0 ),
                 z_axis_rotation( - $to_alpha + $from_alpha ),
                 # translation( 0.0, 0.0, $ref_bond_length ),
                 translation( $from_mid_atom_coord->[0],
                              $from_mid_atom_coord->[1],
                              $from_mid_atom_coord->[2] ),
                 $atom_coord ] ) };
    return \@transformed_atom_coord;
}

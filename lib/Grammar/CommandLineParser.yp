#!perl
%{
    use warnings;

    use List::MoreUtils qw( uniq );
    use List::Util qw( any );

    use ConnectAtoms qw( around_distance );
    use PDBxParser qw( filter );
%}

%left ','
%left '-'
%left 'around'
%left '!'
%left '|' '&'

%%

line
    : exp
        {
	    if( ! $_[1]->[0] ) { return []; }

            if( $_[1]->[0] eq '!' ) {
		return [];
	    } else {
		return [ uniq( @{ $_[1] } ) ];
	    }
        }
;

exp
    : exp '&' exp
        {
	    my @joint_ids;

	    if( ! @{ $_[1] } || ! @{ $_[3] } ) { return []; }

	    my @first_ids = @{ $_[1] };
	    my @second_ids = @{ $_[3] };

	    if( $first_ids[0] ne '!' && $second_ids[0] ne '!' ) {
		for my $id ( @first_ids ) {
		    push( @joint_ids, $id ) if any { $id eq $_ } @second_ids;
		}
		return \@joint_ids;
	    } elsif( $first_ids[0] ne '!' && $second_ids[0] eq '!' ) {
		for my $id ( @first_ids ) {
		    push( @joint_ids, $id ) if ! any { $id eq $_ } @second_ids;
		}
		return \@joint_ids;
	    } elsif( $first_ids[0] eq '!' && $second_ids[0] ne '!' ) {
		for my $id ( @second_ids ) {
		    push( @joint_ids, $id ) if ! any { $id eq $_ } @first_ids;
		}
		return \@joint_ids;
	    } else {
		shift( @first_ids );
		shift( @second_ids );
		return [ '!', uniq( @first_ids, @second_ids ) ];
	    }
        }
    | exp '|' exp
        {
	    if( ! @{ $_[1] } || ! @{ $_[3] } ) {
	    	return [ @{ $_[1] }, @{ $_[3] } ];
	    }

	    if( $_[1]->[0] ne '!' && $_[3]->[0] ne '!' ) {
		return [ uniq( @{ $_[1] }, @{ $_[3] } ) ];
	    } else {
		die( 'Negation (!) with or operator (|) has no valuable ' .
		     'meaning when selecting atoms' );
	    }
        }
    | '(' exp ')'
        {
            $_[2];
        }
    | '!' exp
        {
	    my @ids = @{ $_[2] };
            if( $ids[0] eq '!' ) {
		shift( @ids );
		return \@ids;
	    } else {
		unshift( @ids, '!' );
		return \@ids;
	    }
        }
    | exp 'around' NUM
        {
	    my @ids = @{ $_[1] };
	    my $around_atom_site;
	    my $atom_specifier;
            if( $ids[0] eq '!' ) {
	    # 	shift( @ids );
	    # 	return \@ids;
	    } else {
	    	unshift( @ids, '!' );
		$around_atom_site =
		    around_distance( $_[0]->{USER}{ATOM_SITE},
				     { $_[0]->{USER}{BY_ATTRIBUTE} => $_[1] },
				     $_[3] );
		return filter( { 'atom_site' => $around_atom_site,
				 'data' => [ $_[0]->{USER}{BY_ATTRIBUTE} ],
				 'is_list' => 1 } );
	    }
        }
    | 'chain' str_ope
        {
	    filter( { 'atom_site' => $_[0]->{USER}{ATOM_SITE},
		      'include' => { 'label_asym_id' => $_[2] },
		      'data' => [ $_[0]->{USER}{BY_ATTRIBUTE} ],
		      'is_list' => 1 } );
        }
    | 'resid' num_ope
        {
	    filter( { 'atom_site' => $_[0]->{USER}{ATOM_SITE},
		      'include' => { 'label_seq_id' => $_[2] },
		      'data' => [ $_[0]->{USER}{BY_ATTRIBUTE} ],
		      'is_list' => 1 } );
        }
    | 'resname' str_ope
        {
	    filter( { 'atom_site' => $_[0]->{USER}{ATOM_SITE},
		      'include' => { 'label_comp_id' => $_[2] },
		      'data' => [ $_[0]->{USER}{BY_ATTRIBUTE} ],
		      'is_list' => 1 } );
        }
    | 'atoid' num_ope
        {
	    filter( { 'atom_site' => $_[0]->{USER}{ATOM_SITE},
		      'include' => { 'id' => $_[2] },
		      'data' => [ $_[0]->{USER}{BY_ATTRIBUTE} ],
		      'is_list' => 1 } );
        }
    | 'atoname' str_ope
        {
	    filter( { 'atom_site' => $_[0]->{USER}{ATOM_SITE},
		      'include' => { 'label_atom_id' => $_[2] },
		      'data' => [ $_[0]->{USER}{BY_ATTRIBUTE} ],
		      'is_list' => 1 } );
        }
    | 'atotype' str_ope
        {
	    filter( { 'atom_site' => $_[0]->{USER}{ATOM_SITE},
		      'include' => { 'type_symbol' => $_[2] },
		      'data' => [ $_[0]->{USER}{BY_ATTRIBUTE} ],
		      'is_list' => 1 } );
        }
;

num_ope
    : num_ope ',' num_ope { [ @{ $_[1] }, @{ $_[3] } ]; }
    | num_ope '-' num_ope { [ $_[1]->[0]..$_[3]->[0] ]; }
    | NUM                 { [ int( $_[1] ) ]; }
;

str_ope
    : str_ope ',' str_ope { [ @{ $_[1] }, @{ $_[3] } ]; }
    | STR                 { [ $_[1] ]; }
;

%%

sub lexer # Universal lexer.
{
    my( $parser ) = shift;

    $parser->YYData->{INPUT} || return( '',undef );
    $parser->YYData->{INPUT} =~ s/^[ \t]//;

    # Returns tokens to parser.
    for( $parser->YYData->{INPUT} ){
        if( s/^(resid)// ) {
            return ( 'resid', $1 );
	} elsif(s/^(chain)//) {
            return ( 'chain', $1 );
        } elsif(s/^(resname)//) {
            return ( 'resname', $1 );
        } elsif(s/^(atoid)//) {
            return ( 'atoid', $1 );
        } elsif(s/^(atoname)//) {
            return ( 'atoname', $1 );
        } elsif(s/^(atotype)//) {
            return ( 'atotype', $1 );
        } elsif(s/^(around)//) {
            return ( 'around', $1 );
	} elsif( s/^([0-9]+)// ) {
            return ( 'NUM', $1 );
	} elsif( s/^(\w+)// ) {
            return ( 'STR', $1 );
	} elsif( s/^(,)// ) {
            return ( ',', $1 );
	} elsif( s/^(-)// ) {
            return ( '-', $1 );
	} elsif( s/^(\|)// ) {
            return ( '|', $1 );
	} elsif( s/^(&)// ) {
            return ( '&', $1 );
	} elsif( s/^(\()// ) {
            return ( '(', $1 );
	} elsif( s/^(\))// ) {
            return ( ')', $1 );
	} elsif( s/^(\!)// ) {
            return ( '!', $1 );
	}
    }
}

sub lexer_residue # Only for residue data.
{
    my( $parser ) = shift;

    $parser->YYData->{INPUT} || return( '',undef );
    $parser->YYData->{INPUT} =~ s/^[ \t]//;

    # Returns tokens to parser.
    for( $parser->YYData->{INPUT} ){
        if( s/^(resid)// ) {
            return ( 'resid', $1 );
	} elsif(s/^(chain)//) {
            return ( 'chain', $1 );
	} elsif(s/^(resname)//) {
            return ( 'resname', $1 );
        } elsif(s/^(around)//) {
            return ( 'around', $1 );
	} elsif( s/^([0-9]+)// ) {
            return ( 'NUM', $1 );
	} elsif( s/^(\w+)// ) {
            return ( 'STR', $1 );
	} elsif( s/^(,)// ) {
            return ( ',', $1 );
	} elsif( s/^(-)// ) {
            return ( '-', $1 );
	} elsif( s/^(\|)// ) {
            return ( '|', $1 );
	} elsif( s/^(&)// ) {
            return ( '&', $1 );
	} elsif( s/^(\()// ) {
            return ( '(', $1 );
	} elsif( s/^(\))// ) {
            return ( ')', $1 );
	} elsif( s/^(\!)// ) {
            return ( '!', $1 );
	}
    }
}

sub debugger
{
    exists $_[0]->YYData->{ERRMSG}

    and do {
        print $_[0]->YYData->{ERRMSG};
        return;
    };

    print "Syntax error\n";
}

sub parser
{
    my ( $self, $atom_site, $input, $by_attribute, $lexer ) = @_;

    $self->YYData->{INPUT} = $input;
    $self->YYData->{ATOM_SITE} = $atom_site;
    $self->YYData->{BY_ATTRIBUTE} = $by_attribute;

    my $selected_atom_data;
    if( $lexer && $lexer eq "residue"  ) {
	$selected_atom_data = $self->YYParse( yylex => \&lexer_residue,
					      yyerror => \&debugger,
					      yydebug=>0x00 );
    } else {
	$selected_atom_data = $self->YYParse( yylex => \&lexer,
					      yyerror => \&debugger,
					      yydebug=>0x00 );
    }

    my $selected_atom_site =
	filter( { "atom_site" => $atom_site,
		  "include" => { $by_attribute => $selected_atom_data } } );

    return $selected_atom_site;
}

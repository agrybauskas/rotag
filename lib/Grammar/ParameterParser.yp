#!perl
%{
    use warnings;
%}

%left ','

%%

list:
    | '[' list ']' { return [ $_[2] ]; }
    | list ',' list { return [ @{ $_[1] }, @{ $_[3] } ]; }
    | STR { return [ $_[1] ]; }
    ;

%%

sub lexer
{
    my( $parser ) = shift;

    $parser->YYData->{INPUT} || return( '',undef );
    $parser->YYData->{INPUT} =~ s/^\s?//;

    # Returns tokens to parser.
    for( $parser->YYData->{INPUT} ){
        if( s/^(\[)// ) {
            return ( '[', $1 );
        } elsif( s/^(\])// ) {
            return ( ']', $1 );
        } elsif( s/^(,)// ) {
            return ( ',', $1 );
        } elsif( s/^(=)// ) {
            return ( '=', $1 );
        } elsif( s/^(\w+)// ) {
            return ( 'STR', $1 );
        }
        # if( s/^(=)// ) {
        #     return ( '=', $1 );
        # } elsif( s/^(,)// ) {
        #     return ( ',', $1 );
        # } elsif( s/^(\{)// ) {
        #     return ( '{', $1 );
        # } elsif( s/^(\})// ) {
        #     return ( '}', $1 );
        # } elsif( s/^(\[)// ) {
        #     return ( '[', $1 );
        # } elsif( s/^(\])// ) {
        #     return ( ']', $1 );
        # } elsif( s/^(\w+)// ) {
        #     return ( 'STR', $1 );
        # }
    }
}

sub debugger
{
    exists $_[0]->YYData->{ERRMSG}

    and do {
        print $_[0]->YYData->{ERRMSG};
        return;
    };

    print "Syntax error\n";
}

sub parser
{
    my ( $self, $input ) = @_;

    $self->YYData->{INPUT} = $input;

    my $parameter_data =
        $self->YYParse( yylex => \&lexer,
                        yyerror => \&debugger,
                        yydebug=>0x00 );

    use Data::Dumper;
    print STDERR Dumper $parameter_data;

    # return $parameter_data;
}

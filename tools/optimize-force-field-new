#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Getopt::Long;
use List::MoreUtils qw( uniq );
Getopt::Long::Configure qw( gnu_getopt );
use Parallel::ForkManager;

use BondProperties qw( hybridization );
use Clone qw( clone );
use ConnectAtoms qw( connect_atoms );
use Combinatorics qw( adjacent
                      permutation );
use ForceField::Parameters;
use LinearAlgebra qw( evaluate_matrix_of_functions
                      flatten
                      matrix_of_functions );
use Logging qw( error
                warning );
use Measure qw( rmsd );
use Optimization::ParticleSwarm;
use PDBxParser qw( determine_residue_keys
                   filter
                   mark_selection
                   obtain_atom_site
                   split_by
                   to_pdbx );
use PseudoAtoms qw( generate_library
                    generate_rotamer );
use Sampling qw( sample_angles_qs_parsing );
use SidechainModels qw( rotation_only );
use Version qw( $VERSION );

our $VERSION = $VERSION;

#*optimize-force-field [options] <file>...
#*    optimize the parameters for the composite force-field potential function.
#*
#*Usage:
#*    optimize-force-field structure.cif > output.cif
#*
#*Options:
#*    -a, --angle-step <float>    angle that each dihedral angle is turned by
#*                                (default: 0.1).
#*
#*    -p, --parameters <str>      parameters and parameter steps that should be
#*                                used to explore the them.
#*                                Ex.: '_[local]_force_field:t_k=0.5..0.25..1.0'.
#*
#*    -i, --iterations <int>      number of iterations.
#*
#*    -n, --threads <int>         number of threads.
#*
#*    -v, --version               print version.

my $threads = 1;
my $angles = '-180.0..36.0..180.0';
my $parameters_cmd = '';
my $max_iterations = 1;
my $particle_num = 10;

local $SIG{__WARN__} = sub {
    # warning( { 'message' => @_ } );
};

local $SIG{__DIE__} = sub {
    # warning( { 'message' => @_ } );
};

GetOptions(
    'angles|a=s' => \$angles,
    'parameters|p=s@' => \$parameters_cmd,
    'particle_num|P=s' => \$particle_num,
    'iterations|i=s' => \$max_iterations,
    'threads|n=s' => \$threads,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'Error in command line argument.';

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

my $parameters = Parameters->new();
my %parameters = ();

if( $parameters_cmd ) {
    for my $parameter_cmd ( @{ $parameters_cmd } ) {
        my ( $key_path, $values ) = split /=/, $parameter_cmd;
        my ( $min, $max ) = split /,/, $values;
        $parameters{$key_path} = { 'min' => $min, 'max' => $max };
    }
}

my $ps = ParticleSwarm->new( \%parameters, $particle_num );
$ps->set_cost_function( \&run_calculations,
                        { 'parameters' => $parameters,
                          'pdbxs' => \@ARGV } );
$ps->optimize( $max_iterations );

my $global_optimal_param = $ps->global_optimal_param;
my $global_optimal_value = $ps->global_optimal_value;

if( %{ $global_optimal_param } ) {
    print join( ',', sort keys %{ $global_optimal_param } ), ',', 'rmsd', "\n";
    print join( ',', map { $global_optimal_param->{$_}->value }
                         ( sort keys %{ $global_optimal_param } ) ), ',',
        $global_optimal_value, "\n";
} else {
    print "rmsd\n";
    print $global_optimal_value, "\n";
}

sub run_calculations
{
    my ( $change_parameters, $options ) = @_;
    my ( $parameters, $pdbxs ) =
        ( $options->{'parameters'}, $options->{'pdbxs'} );
    my $current_parameters = clone $parameters;

    for my $full_key ( sort keys %{ $change_parameters } ) {
        my @keys = split /\./, $full_key;
        my $value = $change_parameters->{$full_key}->value;
        $current_parameters->set_parameter_values(
            $current_parameters,
            array2hash( \@keys, $value ),
            { 'is_long' => 1 }
        );
    }

    # Calculates RMSD for given parameters.
    my $sig_figs_max =
        $current_parameters->{'_[local]_constants'}{'sig_figs_max'};

    # Parses string describing angles.
    my %angles = %{ sample_angles_qs_parsing( $current_parameters, $angles ) };

    my $rmsd_sum = 0;
    my $energy_sum = 0;
    my $rotamer_number = 0;

    for my $pdbx_file ( @{ $pdbxs } ) {
                # Reads file path, stdin and '-' operator.
        my $atom_site;
        if( $pdbx_file ) {
            $atom_site = obtain_atom_site( $pdbx_file );
        } else {
            die "Use command \"rotag_library --help\" in order to see the manual.\n";
        }

        my $selected_atom_site =
            filter( { 'atom_site' => $atom_site,
                      'include' => { '[local]_selection_state' => [ 'T', 'S' ] } } );

        # Selects all atoms if no specific atoms are selected.
        if( ! %{ $selected_atom_site } ) {
            $selected_atom_site = $atom_site;
            mark_selection( $selected_atom_site,
                            { 'target' => [ keys %{ $selected_atom_site } ] } );
        }

        # Splits atom site into groups by its uniqueness.
        my $atom_site_groups = split_by( { 'atom_site' => $selected_atom_site,
                                           'attributes' => [ 'pdbx_PDB_model_num',
                                                             'label_alt_id' ],
                                           'append_dot' => 1 } );

        # Starts generating rotamer library.
        my %rotamer_library;
        for my $atom_site_identifier ( sort keys %{ $atom_site_groups } ) {
            my $current_atom_site =
                filter( { 'atom_site' => $atom_site,
                          'include' =>
                              { 'id' =>
                                    $atom_site_groups->{$atom_site_identifier} } } );
            my $current_target_site =
                filter( { 'atom_site' => $current_atom_site,
                          'include' => { '[local]_selection_state' => [ 'T' ] } } );

            my $residue_unique_keys =
                determine_residue_keys( $current_target_site,
                                        { 'exclude_dot' => 1 } );

            my $rotamer_library = {};
            eval{
                $rotamer_library = generate_library(
                    { 'parameters' => $current_parameters,
                      'atom_site' => $current_atom_site,
                      'residue_unique_keys' => $residue_unique_keys,
                      'include_interactions' =>
                          { 'id' => [ keys %{ $current_atom_site } ] },
                      'angles' => \%angles,
                      'rmsd' => 1,
                      'conf_model' => 'rotation_only',
                      'interactions' => 'composite'
                    } );
            };

            for my $residue_unique_key ( keys %{ $rotamer_library } ) {
                $rotamer_library{$residue_unique_key} =
                    $rotamer_library->{$residue_unique_key};
            }
        }

        next if ! %rotamer_library;

        for my $residue_unique_key ( sort { $a cmp $b } keys %rotamer_library ) {
            my ( $residue_id, $residue_chain, $residue_entity, $residue_alt ) =
                split /,/sxm, $residue_unique_key;

            # Chooses the rotamer with the lowest energy state.
            my $rotamers = $rotamer_library{$residue_unique_key};
            my ( $top_rotamer ) =
                sort { $a->{'potential_energy_value'} <=>
                       $b->{'potential_energy_value'} }
                    @{ $rotamers };

            $rmsd_sum += $top_rotamer->{'rmsd'};
            $energy_sum += $top_rotamer->{'potential_energy_value'};
            $rotamer_number++;
        }
    }

    return sprintf( $sig_figs_max, $rmsd_sum / $rotamer_number );
}

sub array2hash
{
    my ( $keys, $value ) = @_;
    my %hash;
    my $keys_count = scalar @{ $keys };
    if( $#{ $keys } > 0 ) {
        $hash{$keys->[0]} =
            array2hash( [ ( @{ $keys } )[1..$keys_count-1] ], $value );
    } else {
        $hash{$keys->[0]} = $value;
    }
    return \%hash;
}

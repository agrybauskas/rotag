#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Getopt::Long;
use List::MoreUtils qw( uniq );
Getopt::Long::Configure qw( gnu_getopt );

use BondProperties qw( hybridization );
use ConnectAtoms qw( connect_atoms );
use Combinatorics qw( permutation );
use ForceField::Parameters;
use Logging qw( error
                warning );
use Measure qw( rmsd );
use PDBxParser qw( filter
                   mark_selection
                   obtain_atom_site
                   to_pdbx );
use PseudoAtoms qw( generate_library
                    generate_rotamer );
use SidechainModels qw( rotation_only );
use Version qw( $VERSION );

our $VERSION = $VERSION;

#*optimize-force-field [options] <file>...
#*    optimize the parameters for the composite force-field potential function.
#*
#*Usage:
#*    optimize-force-field parameters.cif > output.cif
#*
#*Options:
#*    -a, --angle-step <float>    angle that each dihedral angle is turned by
#*                                (default: 0.1).
#*
#*    -p, --parameter-file <str>  specify the path of parameter file.
#*
#*    -n, --threads <int>         number of threads.
#*
#*    -v, --version               print version.

my $parameter_file;
my $threads = 1;
my $small_angle;

local $SIG{__WARN__} = sub {
    warning( { 'message' => @_ } );
};

local $SIG{__DIE__} = sub {
    error( { 'program' => $0, 'message' => @_ } );
};

GetOptions(
    'angle-step|a=s' => \$small_angle,
    'parameter-file|p=s' => \$parameter_file,
    'threads|n=s' => \$threads,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'Error in command line argument.';

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

my $params = Parameters->new();
my $multi_parameters =
    $params->explore_force_field_parameters( [ $parameter_file ] );


# Calculates RMSD for given parameters.
my %pdbx_loops;
$pdbx_loops{'_[local]_parameter_estimation'}{'attributes'} =
    [ 'id', 'label_seq_id', 'label_asym_id', 'label_entity_id',
      'label_alt_id', 'lj_k', 'c_k', 'h_k', 'cutoff_atom',
      'cutoff_start', 'cutoff_end', 'value' ];

for my $parameters ( @{ $multi_parameters } ) {
    my $PI = $parameters->{'_[local]_constants'}{'pi'};
    my $SIG_FIGS_MAX = $parameters->{'_[local]_constants'}{'sig_figs_max'};

    $small_angle //= 0.1 * $PI;

    for my $pdbx_file ( @ARGV ) {
        # Reads file path, stdin and '-' operator.
        my $atom_site;
        if( $pdbx_file ) {
            $atom_site = obtain_atom_site( $pdbx_file );
        } else {
            die "Use command \"rotag_library --help\" in order to see the manual.\n";
        }

        my $selected_atom_site =
            filter( { 'atom_site' => $atom_site,
                      'include' => { '[local]_selection_state' => [ 'T', 'S' ] } } );

        # Selects all atoms if no specific atoms are selected.
        if( ! %{ $selected_atom_site } ) {
            $selected_atom_site = $atom_site;
            mark_selection( $selected_atom_site,
                            { 'target' => [ keys %{ $selected_atom_site } ] } );
        }

        my @residue_unique_keys =
            uniq (
                map { join q{,}, @{ $_ } }
                @{ filter( { 'atom_site' => $selected_atom_site,
                             'include' => { '[local]_selection_state' => [ 'T' ] },
                             'data' =>
                                 [ 'label_seq_id', 'label_asym_id','label_entity_id',
                                   'label_alt_id' ] } ) } );

        hybridization( $selected_atom_site, $parameters );
        connect_atoms( $selected_atom_site, $parameters );

        rotation_only( $selected_atom_site, $parameters );

        # Starts generating rotamer library.
        my $rotamer_library;
        eval {
            $rotamer_library =
                generate_library(
                    { 'atom_site' => $selected_atom_site,
                      'residue_unique_keys' => \@residue_unique_keys,
                      'small_angle' => $small_angle * $PI * 2,
                      'conf_model' => 'rotation_only',
                      'interactions' => 'composite',
                      'PARAMETERS' => $parameters,
                      'threads' => $threads, } );
        };

        for my $residue_unique_key (sort { $a cmp $b } keys %{$rotamer_library}){
            my ( $residue_id, $residue_chain, $residue_entity, $residue_alt)=
                split /,/sxm, $residue_unique_key;
            my $residue_site =
                filter( { 'atom_site' => $selected_atom_site,
                          'include' =>
                              { 'label_seq_id' => [ $residue_id ],
                                'label_asym_id' => [ $residue_chain ],
                                'label_alt_id' => [ $residue_alt ],
                                'label_entity_id' => [$residue_entity] } } );
            my @residue_name =
                uniq( @{ filter( { 'atom_site' => $residue_site,
                                   'data' => [ 'label_comp_id' ],
                                   'is_list' => 1 } ) } );
            my $residue_coord =
                filter( { 'atom_site' => $residue_site,
                          'exclude' =>
                              { 'label_atom_id' =>
                                    $parameters->{'_[local]_interaction_atom_names'} },
                          'data' => [ 'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );

                    my $current_top_rank;
        if( $top_rank ) {
            $current_top_rank =
                $top_rank <= scalar @rotamer_ids ?
                $top_rank :
                scalar @rotamer_ids;
        } elsif( $top_ratio ) {
            $current_top_rank = int( scalar( @rotamer_ids ) * $top_ratio );
            $current_top_rank = $current_top_rank == 0 ? 1 : $current_top_rank;
        } else {
            push @rotamers, @rotamer_ids;
            next;
        }

        my @current_rotamers =
            sort { $rotamer_energy->{$a}{'value'} <=>
                   $rotamer_energy->{$b}{'value'} }
                 @rotamer_ids;
        push @rotamers, @current_rotamers[0..$current_top_rank-1];

    #                 # Checks if 'top' option is int or float and filters rotamers
    #                 # accordingly.
    #                 my @rotamers;
    #                 if( defined $top_rank ) {
    #                     $top_rank =
    #                         $top_rank <=
    #                             scalar @{$rotamer_library->{$residue_unique_key}} ?
    #                         $top_rank :
    #                         scalar @{ $rotamer_library->{$residue_unique_key} };
    #                     @rotamers =
    #                         sort { $a->{'potential_energy_value'} <=>
    #                                $b->{'potential_energy_value'} }
    #                         @{ $rotamer_library->{$residue_unique_key} };
    #                     @rotamers = @rotamers[0..$top_rank-1];
    #                 } elsif( defined $top_ratio ) {
    #                     $top_rank =
    #                         int( scalar( @{ $rotamer_library->{$residue_unique_key}})
    #                              * $top_ratio );
    #                     @rotamers =
    #                         sort { $a->{'potential_energy_value'} <=>
    #                                $b->{'potential_energy_value'} }
    #                         @{ $rotamer_library->{$residue_unique_key} };
    #                     @rotamers = @rotamers[0..$top_rank-1];
    #                 } else {
    #                     @rotamers = @{ $rotamer_library->{$residue_unique_key} };
    #                 }

    #                 # Generates rotamer and checks the angle with original
    #                 # side-chain.
    #                 for my $rotamer ( @rotamers ) {
    #                     my $rotamer_site =
    #                         generate_rotamer( { 'atom_site' => $selected_atom_site,
    #                                             'angle_values' =>
    #                                                 { $residue_unique_key =>
    #                                                       $rotamer->{'angles'} } } );
    #                     my $rotamer_coord =
    #                         filter( { 'atom_site' => $rotamer_site,
    #                                   'data' =>
    #                                       [ 'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );
    #                     push @{$pdbx_loops{'_[local]_parameter_estimation'}{'data'}},
    #                          $calculation_id, $residue_id, $residue_chain,
    #                          $residue_entity, $residue_alt,
    #                          $current_parameters{'lj_k'},
    #                          $current_parameters{'c_k'},
    #                          $current_parameters{'h_k'},
    #                          $current_parameters{'cutoff_atom'},
    #                          $current_parameters{'cutoff_start'},
    #                          $current_parameters{'cutoff_end'},
    #                          sprintf( $SIG_FIGS_MAX,
    #                                   rmsd( $residue_coord, $rotamer_coord ) );
    #                     $calculation_id++;
    #                 }
    #             }
    #         };
    #         if( $@ ) {
    #             push @{$pdbx_loops{'_[local]_parameter_estimation'}{'data'}},
    #             $calculation_id, 'NA', 'NA', 'NA', 'NA',
    #             $current_parameters{'lj_k'},
    #             $current_parameters{'c_k'},
    #             $current_parameters{'h_k'},
    #             $current_parameters{'cutoff_atom'},
    #             $current_parameters{'cutoff_start'},
    #             $current_parameters{'cutoff_end'},
    #             'NA';
    #             $calculation_id++;
    #         }
        }

    #     to_pdbx( { 'pdbx_loops' => \%pdbx_loops } );
    }
}

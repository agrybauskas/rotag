#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Getopt::Long;
use List::MoreUtils qw( uniq );
Getopt::Long::Configure qw( gnu_getopt );

use BondProperties qw( hybridization );
use ConnectAtoms qw( connect_atoms );
use Combinatorics qw( permutation );
use ForceField::Parameters;
use Logging qw( error
                warning );
use Measure qw( rmsd );
use PDBxParser qw( determine_residue_keys
                   filter
                   mark_selection
                   obtain_atom_site
                   split_by
                   to_pdbx );
use PseudoAtoms qw( generate_library
                    generate_rotamer );
use Sampling qw( sample_angles_qs_parsing );
use SidechainModels qw( rotation_only );
use Version qw( $VERSION );

our $VERSION = $VERSION;

#*optimize-force-field [options] <file>...
#*    optimize the parameters for the composite force-field potential function.
#*
#*Usage:
#*    optimize-force-field parameters.cif > output.cif
#*
#*Options:
#*    -a, --angle-step <float>    angle that each dihedral angle is turned by
#*                                (default: 0.1).
#*
#*    -p, --parameter-file <str>  specify the path of parameter file.
#*
#*    -n, --threads <int>         number of threads.
#*
#*    -v, --version               print version.

my $parameter_file;
my $threads = 1;
my $angles = '-180.0..36.0..180.0';

local $SIG{__WARN__} = sub {
    warning( { 'message' => @_ } );
};

local $SIG{__DIE__} = sub {
    error( { 'program' => $0, 'message' => @_ } );
};

GetOptions(
    'angles|a=s' => \$angles,
    'parameter-file|p=s' => \$parameter_file,
    'threads|n=s' => \$threads,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'Error in command line argument.';

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

my $params = Parameters->new();
my $multi_parameters =
    $params->explore_force_field_parameters( [ $parameter_file ] );

# Calculates RMSD for given parameters.
my %pdbx;
$pdbx{'_[local]_parameter_estimation'}{'metadata'}{'attributes'} =
    [ 'id', 'lj_k', 'c_k', 'h_k', 't_k', 'cutoff_atom', 'cutoff_start',
      'cutoff_end', 'rotamer_number', 'energy_average', 'rmsd_average' ];
$pdbx{'_[local]_parameter_estimation'}{'metadata'}{'is_loop'} = 1;
$pdbx{'_[local]_parameter_estimation'}{'metadata'}{'is_indexed'} = 0;

my $calculation_id = 1;
for my $parameters ( @{ $multi_parameters } ) {
    my $pi = $parameters->{'_[local]_constants'}{'pi'};
    my $sig_figs_max = $parameters->{'_[local]_constants'}{'sig_figs_max'};
    my $force_field = $parameters->{'_[local]_force_field'};

    # Parses string describing angles.
    my %angles = %{ sample_angles_qs_parsing( $parameters, $angles ) };

    my $rmsd_sum = 0;
    my $energy_sum = 0;
    my $rotamer_number = 0;

    for my $pdbx_file ( @ARGV ) {
        # Reads file path, stdin and '-' operator.
        my $atom_site;
        if( $pdbx_file ) {
            $atom_site = obtain_atom_site( $pdbx_file );
        } else {
            die "Use command \"rotag_library --help\" in order to see the manual.\n";
        }

        my $selected_atom_site =
            filter( { 'atom_site' => $atom_site,
                      'include' => { '[local]_selection_state' => [ 'T', 'S' ] } } );

        # Selects all atoms if no specific atoms are selected.
        if( ! %{ $selected_atom_site } ) {
            $selected_atom_site = $atom_site;
            mark_selection( $selected_atom_site,
                            { 'target' => [ keys %{ $selected_atom_site } ] } );
        }

        # Splits atom site into groups by its uniqueness.
        my $atom_site_groups = split_by( { 'atom_site' => $selected_atom_site,
                                           'attributes' => [ 'pdbx_PDB_model_num',
                                                             'label_alt_id' ],
                                           'append_dot' => 1 } );

        # Starts generating rotamer library.
        my %rotamer_library;
        for my $atom_site_identifier ( sort keys %{ $atom_site_groups } ) {
            my $current_atom_site =
                filter( { 'atom_site' => $atom_site,
                          'include' =>
                              { 'id' =>
                                    $atom_site_groups->{$atom_site_identifier} } } );
            my $current_target_site =
                filter( { 'atom_site' => $current_atom_site,
                          'include' => { '[local]_selection_state' => [ 'T' ] } } );

            my $residue_unique_keys =
                determine_residue_keys( $current_target_site,
                                        { 'exclude_dot' => 1 } );

            my $rotamer_library =
                generate_library(
                    { 'parameters' => $parameters,
                      'atom_site' => $current_atom_site,
                      'residue_unique_keys' => $residue_unique_keys,
                      'include_interactions' =>
                          { 'id' => [ keys %{ $current_atom_site } ] },
                      'angles' => \%angles,
                      'conf_model' => 'rotation_only',
                      'interactions' => 'composite',
                      'threads' => $threads,
                    } );

            for my $residue_unique_key ( keys %{ $rotamer_library } ) {
                $rotamer_library{$residue_unique_key} =
                    $rotamer_library->{$residue_unique_key};
            }
        }

        next if ! %rotamer_library;

        for my $residue_unique_key ( sort { $a cmp $b } keys %rotamer_library ) {
            my ( $residue_id, $residue_chain, $residue_entity, $residue_alt ) =
                split /,/sxm, $residue_unique_key;
            my $residue_site =
                filter( { 'atom_site' => $selected_atom_site,
                          'include' =>
                              { 'label_seq_id' => [ $residue_id ],
                                'label_asym_id' => [ $residue_chain ],
                                'label_alt_id' => [ $residue_alt ],
                                'label_entity_id' => [$residue_entity] } } );
            my @residue_name =
                uniq( @{ filter( { 'atom_site' => $residue_site,
                                   'data' => [ 'label_comp_id' ],
                                   'is_list' => 1 } ) } );
            my $residue_coord =
                filter( { 'atom_site' => $residue_site,
                          'exclude' =>
                              { 'label_atom_id' =>
                                    $parameters->{'_[local]_interaction_atom_names'} },
                          'data' => [ 'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );

            # Chooses the rotamer with the lowest energy state.
            my $rotamers = $rotamer_library{$residue_unique_key};
            my ( $top_rotamer ) =
                sort { $a->{'potential_energy_value'} <=>
                       $b->{'potential_energy_value'} }
                    @{ $rotamers };

            # Generates rotamer and checks the angle with original
            # side-chain.
            my $rotamer_site =
                generate_rotamer( { 'parameters' => $parameters,
                                    'atom_site' => $selected_atom_site,
                                    'angle_values' =>
                                        { $residue_unique_key =>
                                              $top_rotamer->{'angles'} } } );
            my $rotamer_coord =
                filter( { 'atom_site' => $rotamer_site,
                          'exclude' =>
                              { 'label_atom_id' =>
                                    $parameters->{'_[local]_interaction_atom_names'} },
                          'data' => [ 'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );

            $rmsd_sum += rmsd( $residue_coord, $rotamer_coord );
            $energy_sum += $top_rotamer->{'potential_energy_value'};
            $rotamer_number++;
        }
    }

    push @{ $pdbx{'_[local]_parameter_estimation'}{'data'} },
        $calculation_id, $force_field->{'lj_k'}, $force_field->{'c_k'},
        $force_field->{'h_k'}, $force_field->{'t_k'},
        $force_field->{'cutoff_atom'}, $force_field->{'cutoff_start'},
        $force_field->{'cutoff_end'}, $rotamer_number,
        sprintf( $sig_figs_max, $energy_sum / $rotamer_number ),
        sprintf( $sig_figs_max, $rmsd_sum / $rotamer_number );

    $calculation_id++;
}

to_pdbx( \%pdbx, { 'tags' => [ '_[local]_parameter_estimation' ] } );

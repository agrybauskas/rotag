#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use List::MoreUtils qw( any
                        uniq );

use AtomProperties qw( %ATOMS );
use ConnectAtoms qw( connect_atoms
                     grid_box
                     is_neighbour
                     is_second_neighbour );
use PDBxParser qw( filter
                   obtain_atom_site
                   to_pdbx );
use AtomInteractions qw( hard_sphere
                         soft_sphere
                         leonard_jones
                         coulomb
                         hbond
                         combined );

#*rotag_energy
#*    calculates potential energy of selected atoms.
#*
#*USAGE:
#*    rotag_energy --input input.cif > output.cif
#*    rotag_energy --potential hard_sphere --input input.cif > output.cif
#*
#*OPTIONS:
#*    --input <file> | <stdin>
#*        PDBx file.
#*    --potential (default: composite | hard_sphere | soft_sphere | leonard_jones
#*                          | coulomb | h_bond)
#*        uses potential energy function for determining interactions between
#*        selected residues and atoms that are reachable or described.
#*    --version
#*        print version.

# --------------------------------- Options ----------------------------------- #

my %options;
$options{"interactions"} = "leonard_jones";

my $version = "1.0.0";

GetOptions(
    "input=s" => \$options{"pdbx_file"},
    "potential=s" => \$options{"interactions"},
    "help" => sub { open( my $fh, "<", $0 );
                    while( <$fh> ) {
                        my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                        $help_message =~ s/^\*$/ /g if $help_message;
                        $help_message =~ s/^\*//g if $help_message;
                        print( $help_message, "\n" ) if $help_message; }
                    close( $fh );
                    exit; },
    "version" => sub { print $version, "\n";
                       exit; } )
    or die "Error in command line argument.";

# ----------------------------------- Main ------------------------------------ #

# Reads file path, stdin and "-" operator.
my $atom_site;
if( $options{"pdbx_file"} ) {
    $atom_site = obtain_atom_site( $options{"pdbx_file"} );
} elsif( ! defined $options{"pdbx_file"} && ! -t STDIN ) {
    $atom_site = obtain_atom_site( '-' );
} else {
    die( "Use command \"rotag_energy --help\" in order to see the manual.\n" );
}

# Calculates potential energy.
my $selected_atom_site =
    filter( { "atom_site" => $atom_site,
              "include" => { "[local]_selection_state" => [ "T", "S" ] } } );
my $target_atom_ids =
    filter( { "atom_site" => $selected_atom_site,
              "include" => { "[local]_selection_state" => [ "T" ] },
              "data" => [ "id" ],
              "is_list" => 1 } );

# TODO: look, how it will behave when pseudo atoms are introduced.
connect_atoms( $selected_atom_site );

# TODO: decide the maximum length of cell. It should be corresponding to
# PseudoAtoms::generate_library() and the cutoff of potential functions.
my ( $grid_box, undef ) =
    grid_box( $selected_atom_site,
                7 * $ATOMS{"C"}{"covalent_radius"}{"length"}->[0]
              + 2 * $ATOMS{"N"}{"covalent_radius"}{"length"}->[0]
              + 3 * $ATOMS{"C"}{"covalent_radius"}{"length"}->[1]
              + 3 * $ATOMS{"N"}{"covalent_radius"}{"length"}->[1]
              +     $ATOMS{"H"}{"covalent_radius"}{"length"}->[0] );

# Finds where target atoms are.
my %target_cell_idxs;
for my $cell_idx ( keys %{ $grid_box } ) {
    for my $atom_id ( @{ $grid_box->{"$cell_idx"} } ) {
        if( any { $atom_id eq $_ } @{ $target_atom_ids } ) {
            push( @{ $target_cell_idxs{$cell_idx} }, $atom_id );
        }
    }
}

# Calculates the sum of pairwise interactions.
my $potential_function;
$potential_function = \&combined if $options{"interactions"} eq "composite";
$potential_function = \&hard_sphere if $options{"interactions"} eq "hard_sphere";
$potential_function = \&soft_sphere if $options{"interactions"} eq "soft_sphere";
$potential_function = \&leonard_jones if $options{"interactions"} eq "leonard_jones";
$potential_function = \&coulomb if $options{"interactions"} eq "coulomb";
$potential_function = \&h_bond if $options{"interactions"} eq "h_bond";

my %pdbx_loops;
my $calculation_id = 1;

$pdbx_loops{"_[local]_energy"}{"attributes"} =
    [ "id", "atom_id", "residue_id", "chain", "model_num", "calculation_method",
      "value" ];

for my $cell_idxs ( sort { $a cmp $b } keys %target_cell_idxs ) {
    my @cell_idxs = split( ",", $cell_idxs );
    my @neighbour_atom_ids; # The array will contain all atoms of the
                            # neighbouring 26 cells.

    # $i represents x, $j - y, $k - z coordinates.
    for my $i ( ( $cell_idxs[0] - 1..$cell_idxs[0] + 1 ) ) {
    for my $j ( ( $cell_idxs[1] - 1..$cell_idxs[1] + 1 ) ) {
    for my $k ( ( $cell_idxs[2] - 1..$cell_idxs[2] + 1 ) ) {
        if( exists $grid_box->{"$i,$j,$k"} ) {
            push( @neighbour_atom_ids, @{ $grid_box->{"$i,$j,$k"} } ); } } } }

    for my $atom_id ( @{ $target_cell_idxs{$cell_idxs} } ) {
        my $residue_id = $selected_atom_site->{"$atom_id"}{"label_seq_id"};
        my $chain = $selected_atom_site->{"$atom_id"}{"label_asym_id"};
        my $model_num = $selected_atom_site->{"$atom_id"}{"pdbx_PDB_model_num"};
        # Change neighbour name, because it might be misinterpreted as connected
        # atoms.
        my $potential_energy = 0; # TODO: should here be 0 or undef?
        for my $neighbour_atom_id ( uniq @neighbour_atom_ids ) {
            # TODO: just in case, check if ignoring second neighbours are valid.
            if( ( $atom_id ne $neighbour_atom_id )
             && ( ! is_neighbour( $selected_atom_site,
                                  $atom_id,
                                  $neighbour_atom_id ) )
             && ( ! is_second_neighbour( $selected_atom_site,
                                         $atom_id,
                                         $neighbour_atom_id ) ) ) {
                $potential_energy +=
                    $potential_function->(
                        $selected_atom_site->{$atom_id},
                        $selected_atom_site->{$neighbour_atom_id} );
            }
        }

        push( @{ $pdbx_loops{"_[local]_energy"}{"data"} },
              $calculation_id, $atom_id, $residue_id, $chain, $model_num,
              $options{"interactions"}, sprintf( "%.3f", $potential_energy ) );
        $calculation_id++;
    }
}

to_pdbx( { "pdbx_loops" => \%pdbx_loops } );

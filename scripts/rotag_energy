#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Clone qw( clone );
use Getopt::Long;
use List::MoreUtils qw( any
                        uniq );

use Constants qw( $EDGE_LENGTH_INTERACTION
                  $SIG_FIGS_MIN
                  $SIG_FIGS_MAX );
use ConnectAtoms qw( connect_atoms
                     is_neighbour
                     is_second_neighbour );
use ForceField::Parameters;
use ForceField::NonBonded qw( coulomb
                              general
                              hard_sphere
                              h_bond
                              lennard_jones
                              soft_sphere );
use ForceField::Bonded qw( general
                           torsion);
use Grid qw( grid_box
             identify_neighbour_cells );
use BondProperties qw( hybridization );
use PDBxParser qw( filter
                   mark_selection
                   obtain_atom_site
                   pdbx_loop_to_csv
                   split_by
                   to_pdbx );
use Version qw( $VERSION );

Getopt::Long::Configure qw( gnu_getopt );

our $VERSION = $VERSION;

#*rotag_energy [options] <file>...
#*    calculate potential energy of selected atoms.
#*
#*Usage:
#*    rotag_energy input.cif > output.cif
#*    rotag_energy -u hard_sphere input.cif > output.cif
#*    rotag_energy input.cif -p 'lj_k=0.01, c_k=0.4' > output.cif
#*
#*Options:
#*    -u, --potential <potential> uses potential energy function for determining
#*                                interactions between selected residues and
#*                                atoms that are reachable or described.
#*                                (default: composite | hard_sphere | soft_sphere
#*                                | lennard_jones | coulomb | h_bond)
#*
#*    -p, --parameters <str>      parameter values.
#*
#*                                Parameters for composite potential energy
#*                                function:
#*                                    lj_k         - Lennard-Jones constant;
#*                                    c_k          - Coulomb constant;
#*                                    h_k          - hydrogen bond constant;
#*                                    cutoff_start - x VdW where energy starts
#*                                                   to go to zero;
#*                                    cutoff_end   - x VdW where energy is at
#*                                                   zero.
#*
#*                                Parameters for soft-sphere potential energy
#*                                function:
#*                                    soft_epsilon - soft sphere epsilon;
#*                                    soft_n       - soft sphere n.
#*
#*                                E.g.: 'lj_k=0.01, c_k=0.4'.
#*
#*    -S, --side-chains           calculate energy of the side-chain atoms for
#*                                each selected residue.
#*
#*    -d, --decompose             decompose composite energy values into their
#*                                constituent energy values.
#*
#*    -P, --pairwise              check energy of the atoms in pairwise fashion.
#*
#*    -b, --b-factor              adds 'B_iso_or_equiv' as energy value to the
#*                                PDBx 'atom_site' loop.
#*
#*    -F, --format <format>       output format (default: pdbx | csv).
#*
#*    -n, --threads <int>         number of threads.
#*
#*    -v, --version               print version.

# --------------------------------- Options ----------------------------------- #

my $interactions = 'composite';
my $parameters = '';
my $do_sidechain = 0;
my $do_pairwise = 0;
my $do_decompose = 0;
my $add_B_iso = 0;
my $output_format = 'pdbx';
my $threads = 1;

GetOptions(
    'potential|u=s' => \$interactions,
    'parameters|p=s' => \$parameters,
    'side-chains|S' => sub { $do_sidechain = 1 },
    'pairwise|P' => sub { $do_pairwise = 1 },
    'decompose|d' => sub { $do_decompose = 1 },
    'b-factor|b' => sub { $add_B_iso = 1 },
    'format|F=s' => \$output_format,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'Error in command line argument.';

# Defaults.
my %potential_functions = (
    'composite' => \&ForceField::NonBonded::general,
    'torsion' => \&torsion,
    'hard_sphere' => \&hard_sphere,
    'soft_sphere' => \&soft_sphere,
    'lennard_jones' => \&lennard_jones,
    'coulomb' => \&coulomb,
    'h_bond' => \&h_bond,
);

# Parses parameter string.
$parameters =~ s/\s//g;
$parameters = {
    map { $_->[0] => $_->[1] }
    map { [ split /=/sm, $_ ] }
    split /,/sxm, $parameters
};

# Checks the names of the parameters.
my @allowed_parameters =
    qw( lj_k c_k h_k t_k cutoff_start cutoff_end soft_epsilon soft_n);

for my $parameter ( keys %{ $parameters } ) {
    if( ! any { $parameter eq $_ } @allowed_parameters ) {
        die "'$parameter' argument is not valid.\n";
    }
}

if( $do_decompose ) {
    $parameters->{'decompose'} = 1;
}

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    if( $pdbx_file ) {
        $atom_site = obtain_atom_site( $pdbx_file );
    } else {
        die "Use command \"rotag_energy --help\" in order to see the manual.\n";
    }

    my $selected_atom_site =
        filter( { 'atom_site' => $atom_site,
                  'include' => { '[local]_selection_state' => [ 'T', 'S' ] } } );

    # Selects all atoms if no specific atoms are selected.
    if( ! %{ $selected_atom_site } ) {
        $selected_atom_site = $atom_site;
        mark_selection( $selected_atom_site,
                        { 'target' => [ keys %{ $selected_atom_site } ] } );
    }

    # Splits atom site into groups by its uniqueness.
    my $atom_site_groups = split_by( { 'atom_site' => $selected_atom_site,
                                       'attributes' => [ 'pdbx_PDB_model_num',
                                                         'label_alt_id',
                                                         'label_asym_id' ],
                                       'append_dot' => 1 } );

    my %pdbx_loops;
    if( $do_pairwise ) {
        $pdbx_loops{'_[local]_pairwise_energy'}{'attributes'} =
            [ 'id', 'atom_1_id', 'type_symbol_1', 'label_atom_1_id',
              'label_seq_1_id', 'label_comp_1_id', 'label_asym_1_id',
              'label_entity_1_id', 'label_alt_1_id',
              'atom_2_id', 'type_symbol_2', 'label_atom_2_id',
              'label_seq_2_id', 'label_comp_2_id', 'label_asym_2_id',
              'label_entity_2_id', 'label_alt_2_id', 'calculation_method',
              'value' ];
    } elsif( $do_sidechain ) {
        $pdbx_loops{'_[local]_rotamer_energy'}{'attributes'} =
            [ 'id', 'label_seq_id', 'label_asym_id', 'pdbx_PDB_model_num',
              'label_alt_id', 'calculation_method', 'value' ];
    } else {
        $pdbx_loops{'_[local]_energy'}{'attributes'} =
            [ 'id', 'atom_id', 'type_symbol', 'label_atom_id', 'label_seq_id',
              'label_comp_id', 'label_asym_id', 'pdbx_PDB_model_num',
              'label_alt_id', 'calculation_method', 'value' ];
    }

    my $calculation_id = 1;
    for my $atom_site_identifier ( sort keys %{ $atom_site_groups } ) {
        my $current_atom_site =
            clone( filter( { 'atom_site' => $atom_site,
                             'include' =>
                                 { 'id' =>
                                       $atom_site_groups->{$atom_site_identifier}
                                 } } ) );

        # Replace every alt id to one in order to determine which calculation
        # calculated what atom.
        my ( undef, $current_alt_id ) = split /,/, $atom_site_identifier;
        for my $atom_id ( keys %{ $current_atom_site } ) {
            $current_atom_site->{$atom_id}{'label_alt_id'} = $current_alt_id;
        }

        connect_atoms( $current_atom_site );
        hybridization( $current_atom_site );
        $parameters->{'atom_site'} = $current_atom_site;

        my $target_atom_ids =
            filter( { 'atom_site' => $current_atom_site,
                      'include' => { '[local]_selection_state' => [ 'T' ] },
                      'data' => [ 'id' ],
                      'is_list' => 1 } );

        my ( $grid_box, $target_cells ) =
            grid_box( $current_atom_site,
                      $EDGE_LENGTH_INTERACTION,
                      $target_atom_ids );

        my $neighbour_cells = identify_neighbour_cells($grid_box, $target_cells);

        my $potential_function = $potential_functions{$interactions};

        # Calculates the sum of pairwise interactions.
        my %residue_energy;
        for my $cell ( sort { $a cmp $b } keys %{ $target_cells } ) {
            for my $atom_id ( @{ $target_cells->{$cell} } ) {
                if( $do_sidechain ) {
                    next if any { $current_atom_site->{$atom_id}
                                                      {'label_atom_id'} eq $_ }
                                @Parameters::INTERACTION_ATOM_NAMES;
                }

                my ( $atom_symbol, $atom_name,
                     $atom_residue_id, $atom_residue_name,
                     $atom_chain, $atom_entity, $atom_alt ) =
                         map { $current_atom_site->{$atom_id}{$_} }
                             qw( type_symbol label_atom_id label_seq_id
                                 label_comp_id label_asym_id pdbx_PDB_model_num
                                 label_alt_id );

                my $residue_unique_key =
                    join q{,}, $atom_residue_id, $atom_chain, $atom_entity,
                    $atom_alt;

                my $potential_energy = 0;
                my %potential_energy; # Used when decomposing composite energy
                                      # values.

                # Adds bonded potential energy term.
                if( $interactions eq 'composite' ) {
                    $potential_energy = ForceField::Bonded::general(
                        $current_atom_site->{$atom_id},
                        $parameters
                    );
                }

                # Adds non-bonded potential energy term.
                for my $neighbour_atom_id ( uniq @{ $neighbour_cells->{$cell} }){
                    if( ( $atom_id ne $neighbour_atom_id )
                     && ( ! is_neighbour( $current_atom_site,
                                          $atom_id,
                                          $neighbour_atom_id ) )
                     && ( ! is_second_neighbour( $current_atom_site,
                                                 $atom_id,
                                                 $neighbour_atom_id ) ) ) {
                        my ( $neighbour_symbol, $neighbour_name,
                             $neighbour_residue_id, $neighbour_residue_name,
                             $neighbour_chain, $neighbour_entity, $neighbour_alt ) =
                            map { $current_atom_site->{$neighbour_atom_id}{$_} }
                                qw( type_symbol label_atom_id label_seq_id
                                    label_comp_id label_asym_id pdbx_PDB_model_num
                                    label_alt_id );

                        my $pairwise_potential_energy =
                            $potential_function->(
                                $current_atom_site->{$atom_id},
                                $current_atom_site->{$neighbour_atom_id},
                                $parameters );

                        if( $do_pairwise ) {
                            if( $do_decompose ) {
                                for my $interaction (
                                    grep { $_ ne 'composite' }
                                    sort keys %{ $pairwise_potential_energy } ){
                                    push @{ $pdbx_loops{'_[local]_pairwise_energy'}
                                                       {'data'} },
                                         $calculation_id, $atom_id, $atom_symbol,
                                         $atom_name, $atom_residue_id,
                                         $atom_residue_name, $atom_chain,
                                         $atom_entity, $atom_alt,
                                         $neighbour_atom_id, $neighbour_symbol,
                                         $neighbour_name, $neighbour_residue_id,
                                         $neighbour_residue_name,
                                         $neighbour_chain, $neighbour_entity,
                                         $neighbour_alt, $interaction,
                                         sprintf $SIG_FIGS_MAX,
                                                 $pairwise_potential_energy->{$interaction};
                                    $calculation_id++;
                                }
                            } else {
                                push @{ $pdbx_loops{'_[local]_pairwise_energy'}
                                                   {'data'} },
                                     $calculation_id, $atom_id, $atom_symbol,
                                     $atom_name, $atom_residue_id,
                                     $atom_residue_name, $atom_chain,
                                     $atom_entity, $atom_alt,
                                     $neighbour_atom_id, $neighbour_symbol,
                                     $neighbour_name, $neighbour_residue_id,
                                     $neighbour_residue_name, $neighbour_chain,
                                     $neighbour_entity, $neighbour_alt,
                                     $interactions,
                                     sprintf $SIG_FIGS_MAX,
                                             $pairwise_potential_energy;
                                $calculation_id++;
                            }
                        } elsif( $do_decompose ) {
                            for my $interaction (
                                grep { $_ ne 'composite' }
                                sort keys %{ $pairwise_potential_energy } ) {
                                if( $potential_energy{$interaction} ) {
                                    $potential_energy{$interaction} +=
                                        $pairwise_potential_energy->{$interaction};
                                } else {
                                    $potential_energy{$interaction} =
                                        $pairwise_potential_energy->{$interaction};
                                }
                            }
                        } else {
                            $potential_energy += $pairwise_potential_energy;
                        }
                    }
                }

                if( ! $do_pairwise && ! $do_decompose && ! $do_sidechain ) {
                    if( $add_B_iso ) {
                        $atom_site->{$atom_id}{'B_iso_or_equiv'} =
                            sprintf $SIG_FIGS_MIN, $potential_energy;
                        $calculation_id++;
                    } else {
                        push @{ $pdbx_loops{'_[local]_energy'}{'data'} },
                            $calculation_id, $atom_id, $atom_symbol, $atom_name,
                            $atom_residue_id, $atom_residue_name, $atom_chain,
                            $atom_entity, $atom_alt, $interactions,
                            sprintf $SIG_FIGS_MAX, $potential_energy;
                        $calculation_id++;
                    }
                }

                if( $do_decompose && ! $do_sidechain ) {
                    for my $interaction (
                        grep { $_ ne 'composite' } sort keys %potential_energy ){
                        push @{ $pdbx_loops{'_[local]_energy'}{'data'} },
                             $calculation_id, $atom_id, $atom_symbol, $atom_name,
                             $atom_residue_id, $atom_residue_name, $atom_chain,
                             $atom_entity, $atom_alt, $interaction,
                             sprintf $SIG_FIGS_MAX, $potential_energy{$interaction};
                        $calculation_id++;
                    }
                }

                if( $do_sidechain && ! $do_pairwise ) {
                    if( $do_decompose ) {
                        for my $interaction ( grep { $_ ne 'composite' }
                                              sort keys %potential_energy ) {
                            if( exists $residue_energy{$residue_unique_key} &&
                                exists $residue_energy{$residue_unique_key}
                                                      {$interaction} ) {
                                $residue_energy{$residue_unique_key}{$interaction} +=
                                    $potential_energy{$interaction};
                            } else {
                                $residue_energy{$residue_unique_key}{$interaction} =
                                    $potential_energy{$interaction};
                            }
                        }
                    } else {
                        if( exists $residue_energy{$residue_unique_key} &&
                            exists $residue_energy{$residue_unique_key}
                                                  {$interactions} ) {
                            $residue_energy{$residue_unique_key}
                                           {$interactions} += $potential_energy;
                        } else {
                            $residue_energy{$residue_unique_key}
                                           {$interactions} = $potential_energy;
                        }
                    }
                }
            }
        }

        if( $do_sidechain ) {
            $calculation_id = 1;
            for my $residue_unique_key ( sort keys %residue_energy ) {
                for my $interaction (
                    sort keys %{ $residue_energy{$residue_unique_key} } ) {
                    push @{ $pdbx_loops{'_[local]_rotamer_energy'}{'data'} },
                         $calculation_id, split( /,/sxm, $residue_unique_key ),
                         $interaction,
                         sprintf $SIG_FIGS_MAX,
                                 $residue_energy{$residue_unique_key}
                                                {$interaction};
                    $calculation_id++;
                }
            }
        }
    }

    if( $output_format eq 'pdbx' ) {
        if( $add_B_iso ) {
            to_pdbx( { 'atom_site' => $atom_site,
                       'add_atom_attributes' => [ 'B_iso_or_equiv' ] } );
        } else {
            to_pdbx( { 'pdbx_loops' => \%pdbx_loops } );
        }
    } elsif( $output_format eq 'csv' ) {
        if( $do_pairwise ) {
            pdbx_loop_to_csv( $pdbx_loops{'_[local]_pairwise_energy'} );
        } elsif( $do_sidechain ) {
            pdbx_loop_to_csv( $pdbx_loops{'_[local]_rotamer_energy'} );
        } else {
            pdbx_loop_to_csv( $pdbx_loops{'_[local]_energy'} );
        }
    }
}

#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use List::MoreUtils qw( any
                        uniq );

use AtomProperties qw( %ATOMS );
use AtomInteractions qw( hard_sphere
                         soft_sphere
                         leonard_jones
                         coulomb
                         h_bond
                         composite );
use ConnectAtoms qw( connect_atoms
                     is_neighbour
                     is_second_neighbour );
use Grid qw( grid_box
             identify_neighbour_cells );
use MoleculeProperties qw( hybridization );
use PDBxParser qw( filter
                   obtain_atom_site
                   to_pdbx );
use PseudoAtoms qw( add_hydrogens );

#*rotag_energy [options] file1 [file2, ...]
#*    calculates potential energy of selected atoms.
#*
#*USAGE:
#*    rotag_energy input.cif > output.cif
#*    rotag_energy -u hard_sphere input.cif > output.cif
#*
#*OPTIONS:
#*    -u, --potential (default: composite | hard_sphere | soft_sphere |
#*                              leonard_jones | coulomb | h_bond)
#*        uses potential energy function for determining interactions between
#*        selected residues and atoms that are reachable or described.
#*    -r, --rotamer
#*        calculate energy of the side-chain atoms for each selected residue.
#*    -d, --decompose
#*        decompose composite energy values into their constituent energy values.
#*    -p, --pairwise
#*        check energy of the atoms in pairwise fashion.
#*    -n, --threads
#*        number of threads.
#*    -v, --version
#*        print version.

# --------------------------------- Options ----------------------------------- #

my %options;

my $version = "1.0.0";
my $do_residue = 0;
my $do_pairwise = 0;
my $do_decompose = 0;

GetOptions(
    "potential|u=s" => \$options{"interactions"},
    "residue|r" => sub { $do_residue = 1 },
    "pairwise|p" => sub { $do_pairwise = 1 },
    "decompose|d" => sub { $do_decompose = 1 },
    "help|h" => sub { open( my $fh, "<", $0 );
                    while( <$fh> ) {
                        my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                        $help_message =~ s/^\*$/ /g if $help_message;
                        $help_message =~ s/^\*//g if $help_message;
                        print( $help_message, "\n" ) if $help_message; }
                    close( $fh );
                    exit; },
    "version|v" => sub { print $version, "\n";
                       exit; } )
    or die "Error in command line argument.";

# Defaults.
my %potential_functions = (
    "composite" => \&composite,
    "hard_sphere" => \&hard_sphere,
    "soft_sphere" => \&soft_sphere,
    "leonard_jones" => \&leonard_jones,
    "coulomb" => \&coulomb,
    "h_bond" => \&h_bond
);
$options{"interactions"} //= "composite";
$options{"threads"} //= 1;

# ----------------------------------- Main ------------------------------------ #

@ARGV = ( '-' ) unless @ARGV;

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and "-" operator.
    my $atom_site;
    if( $pdbx_file ) {
        $atom_site = obtain_atom_site( $pdbx_file );
    } else {
        die( "Use command \"rotag_energy --help\" in order to see the manual.\n" );
    }

    # Adds hydrogens for calculations where h_bond might be present.
    my %parameters;
    if( $options{"interactions"} eq 'composite'
     || $options{"interactions"} eq 'h_bond' ) {
        my %atom_site_with_hydrogens =
            ( %{ $atom_site },
              %{ add_hydrogens( $atom_site,
                                { 'add_only_clear_positions' => 1 } ) } );
        connect_atoms( \%atom_site_with_hydrogens );
        hybridization( \%atom_site_with_hydrogens );
        $parameters{'atom_site'} = \%atom_site_with_hydrogens;
    } else {
        # TODO: look, how it will behave when pseudo atoms are introduced.
        connect_atoms( $atom_site );
    }

    if( $do_decompose ) {
        $parameters{'decompose'} = 1;
    }

    my $selected_atom_site =
        filter( { "atom_site" => $atom_site,
                  "include" => { "[local]_selection_state" => [ "T", "S" ] } } );
    my $target_atom_ids =
        filter( { "atom_site" => $selected_atom_site,
                  "include" => { "[local]_selection_state" => [ "T" ] },
                  "data" => [ "id" ],
                  "is_list" => 1 } );

    # TODO: decide the maximum length of cell. It should be corresponding to
    # PseudoAtoms::generate_library() and the cutoff of potential functions.
    my ( $grid_box, $target_cells ) =
        grid_box( $selected_atom_site,
                  7 * $ATOMS{"C"}{"covalent_radius"}{"length"}->[0]
                + 2 * $ATOMS{"N"}{"covalent_radius"}{"length"}->[0]
                + 3 * $ATOMS{"C"}{"covalent_radius"}{"length"}->[1]
                + 3 * $ATOMS{"N"}{"covalent_radius"}{"length"}->[1]
                +     $ATOMS{"H"}{"covalent_radius"}{"length"}->[0],
                  $target_atom_ids );

    my $neighbour_cells = identify_neighbour_cells( $grid_box, $target_cells );

    my $potential_function = $potential_functions{$options{"interactions"}};

    my %pdbx_loops;
    my $calculation_id = 1;

    if( $do_pairwise ) {
        $pdbx_loops{"_[local]_pairwise_energy"}{"attributes"} =
            [ "id", "atom_1_id", "type_symbol_1", "label_atom_1_id",
              "label_seq_1_id", "label_comp_1_id", "label_asym_1_id",
              "label_entity_1_id", "label_alt_1_id",
              "atom_2_id", "type_symbol_2", "label_atom_2_id",
              "label_seq_2_id", "label_comp_2_id", "label_asym_2_id",
              "label_entity_2_id", "label_alt_2_id",
              "calculation_method", "value" ];
    } else {
        $pdbx_loops{"_[local]_energy"}{"attributes"} =
            [ "id", "atom_id", "type_symbol", "label_atom_id", "label_seq_id",
              "label_comp_id", "label_asym_id", "label_entity_id",
              "label_alt_id", "calculation_method", "value" ];
    }

    # Calculates the sum of pairwise interactions.
    for my $cell ( sort { $a cmp $b } keys %{ $target_cells } ) {
        for my $atom_id ( @{ $target_cells->{$cell} } ) {
            my ( $atom_symbol, $atom_name,
                 $atom_residue_id, $atom_residue_name,
                 $atom_chain, $atom_entity, $atom_alt ) =
                     map { $selected_atom_site->{"$atom_id"}{"$_"} }
                         ( "type_symbol", "label_atom_id", "label_seq_id",
                           "label_comp_id", "label_asym_id", "label_entity_id",
                           "label_alt_id" );

            my $potential_energy = 0;
            my %potential_energy; # Used when decomposing composite energy values.
            for my $neighbour_atom_id ( uniq @{ $neighbour_cells->{$cell} } ) {
                # TODO: just in case, check if ignoring second neighbours are valid.
                if( ( $atom_id ne $neighbour_atom_id )
                 && ( ! is_neighbour( $selected_atom_site,
                                      $atom_id,
                                      $neighbour_atom_id ) )
                 && ( ! is_second_neighbour( $selected_atom_site,
                                             $atom_id,
                                             $neighbour_atom_id ) ) ) {
                    my ( $neighbour_symbol, $neighbour_name,
                         $neighbour_residue_id, $neighbour_residue_name,
                         $neighbour_chain, $neighbour_entity, $neighbour_alt ) =
                        map { $selected_atom_site->{"$neighbour_atom_id"}{"$_"} }
                            ( "type_symbol", "label_atom_id", "label_seq_id",
                              "label_comp_id", "label_asym_id", "label_entity_id",
                              "label_alt_id" );

                    my $pairwise_potential_energy =
                        $potential_function->(
                            $selected_atom_site->{$atom_id},
                            $selected_atom_site->{$neighbour_atom_id},
                            \%parameters );

                    if( $do_pairwise ) {
                        if( $do_decompose ) {
                            for my $interaction (
                                grep { $_ ne 'composite' }
                                sort keys %{ $pairwise_potential_energy } ) {
                                push( @{ $pdbx_loops{"_[local]_pairwise_energy"}{"data"} },
                                      $calculation_id, $atom_id, $atom_symbol,
                                      $atom_name, $atom_residue_id,
                                      $atom_residue_name, $atom_chain,
                                      $atom_entity, $atom_alt,
                                      $neighbour_atom_id, $neighbour_symbol,
                                      $neighbour_name, $neighbour_residue_id,
                                      $neighbour_residue_name, $neighbour_chain,
                                      $neighbour_entity, $neighbour_alt,
                                      $interaction,
                                      sprintf( "%.3f", $pairwise_potential_energy->{$interaction} ) );
                                $calculation_id++;
                            }
                        } else {
                            push( @{ $pdbx_loops{"_[local]_pairwise_energy"}{"data"} },
                                  $calculation_id, $atom_id, $atom_symbol,
                                  $atom_name, $atom_residue_id,
                                  $atom_residue_name, $atom_chain, $atom_entity,
                                  $atom_alt,
                                  $neighbour_atom_id, $neighbour_symbol,
                                  $neighbour_name, $neighbour_residue_id,
                                  $neighbour_residue_name, $neighbour_chain,
                                  $neighbour_entity, $neighbour_alt,
                                  $options{'interactions'},
                                  sprintf( "%.3f", $pairwise_potential_energy ) );
                            $calculation_id++;
                        }
                    } elsif( $do_decompose ) {
                        for my $interaction (
                            grep { $_ ne 'composite' }
                            sort keys %{ $pairwise_potential_energy } ) {
                            if( $potential_energy{$interaction} ) {
                                $potential_energy{$interaction} =
                                    $pairwise_potential_energy->{$interaction};
                            } else {
                                $potential_energy{$interaction} +=
                                    $pairwise_potential_energy->{$interaction};
                            }
                        }
                    } else {
                        $potential_energy += $pairwise_potential_energy;
                    }
                }
            }

            if( ! $do_pairwise && ! $do_decompose ) {
                push( @{ $pdbx_loops{"_[local]_energy"}{"data"} },
                      $calculation_id, $atom_id, $atom_symbol, $atom_name,
                      $atom_residue_id, $atom_residue_name, $atom_chain,
                      $atom_entity, $atom_alt, $options{"interactions"},
                      sprintf( "%.3f", $potential_energy ) );
                $calculation_id++;
            }

            if( $do_decompose ) {
                for my $interaction (
                    grep { $_ ne 'composite' } sort keys %potential_energy ) {
                    push( @{ $pdbx_loops{"_[local]_energy"}{"data"} },
                          $calculation_id, $atom_id, $atom_symbol, $atom_name,
                          $atom_residue_id, $atom_residue_name, $atom_chain,
                          $atom_entity, $atom_alt, $interaction,
                          sprintf( "%.3f", $potential_energy{$interaction} ) );
                    $calculation_id++;
                }
            }
        }
    }

    to_pdbx( { "pdbx_loops" => \%pdbx_loops } );
}

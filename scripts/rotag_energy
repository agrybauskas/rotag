#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Clone qw( clone );
use Getopt::Long;
use List::MoreUtils qw( any
                        uniq );
use Try::Tiny;

use ConnectAtoms qw( connect_atoms
                     is_neighbour
                     is_second_neighbour );
use Measure qw( energy );
use ForceField::Parameters;
use Grid qw( grid_box
             identify_neighbour_cells );
use BondProperties qw( hybridization );
use Logging qw( error
                warning );
use PDBxParser qw( filter
                   mark_selection
                   obtain_atom_site
                   pdbx_loop_to_csv
                   split_by
                   to_pdbx );
use Version qw( $VERSION );

Getopt::Long::Configure qw( gnu_getopt );

our $VERSION = $VERSION;

#*rotag_energy [options] <file>...
#*    calculate potential energy of selected atoms.
#*
#*Usage:
#*    rotag_energy input.cif > output.cif
#*    rotag_energy -u hard_sphere input.cif > output.cif
#*    rotag_energy input.cif -p 'lj_k=0.01, c_k=0.4' > output.cif
#*
#*Options:
#*    -u, --potential <potential> uses potential energy function for determining
#*                                interactions between selected residues and
#*                                atoms that are reachable or described.
#*                                (default: composite | hard_sphere | soft_sphere
#*                                | lennard_jones | coulomb | h_bond)
#*
#*    -p, --parameters <str>      parameter values.
#*
#*                                Parameters for composite potential energy
#*                                function:
#*                                    lj_k         - Lennard-Jones constant;
#*                                    c_k          - Coulomb constant;
#*                                    h_k          - hydrogen bond constant;
#*                                    cutoff_start - x VdW where energy starts
#*                                                   to go to zero;
#*                                    cutoff_end   - x VdW where energy is at
#*                                                   zero.
#*
#*                                Parameters for soft-sphere potential energy
#*                                function:
#*                                    soft_epsilon - soft sphere epsilon;
#*                                    soft_n       - soft sphere n.
#*
#*                                E.g.: 'lj_k=0.01, c_k=0.4'.
#*
#*    -S, --side-chains           calculate energy of the side-chain atoms for
#*                                each selected residue.
#*
#*    -d, --decompose             decompose composite energy values into their
#*                                constituent energy values.
#*
#*    -P, --pairwise              check energy of the atoms in pairwise fashion.
#*
#*    -b, --b-factor              adds 'B_iso_or_equiv' as energy value to the
#*                                PDBx 'atom_site' loop.
#*
#*    -F, --format <format>       output format (default: pdbx | csv).
#*
#*    -n, --threads <int>         number of threads.
#*
#*    -v, --version               print version.

# --------------------------------- Options ----------------------------------- #

my $interactions = 'composite';
my $parameters = '';
my $do_sidechain = 0;
my $do_pairwise = 0;
my $do_decompose = 0;
my $add_B_iso = 0;
my $output_format = 'pdbx';
my $threads = 1;

local $SIG{__WARN__} = sub {
    warning( { 'program' => $0, 'message' => @_ } );
};

local $SIG{__DIE__} = sub {
    error( { 'program' => $0, 'message' => @_ } );
};

GetOptions(
    'potential|u=s' => \$interactions,
    'parameters|p=s' => \$parameters,
    'side-chains|S' => sub { $do_sidechain = 1 },
    'pairwise|P' => sub { $do_pairwise = 1 },
    'decompose|d' => sub { $do_decompose = 1 },
    'b-factor|b' => sub { $add_B_iso = 1 },
    'format|F=s' => \$output_format,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or error( { 'program' => $0,
              'message' => "mistake in command line argument.\n" } );

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

my $PARAMETERS = Parameters->new();
my $SIG_FIGS_MAX = $PARAMETERS->{'_[local]_constants'}{'sig_figs_max'};

# Parses parameter string.
$parameters =~ s/\s//g;
for my $parameter_pair ( split /,/sxm, $parameters ) {
    my ( $parameter, $value ) = split /=/sm, $parameter_pair;
    $PARAMETERS->set_parameter_values(
        { '_[local]_force_field' => { $parameter => $value } }
    );
}

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    $atom_site = obtain_atom_site( $pdbx_file );

    next if ! %{ $atom_site };

    my $selected_atom_site =
        filter( { 'atom_site' => $atom_site,
                  'include' => { '[local]_selection_state' => [ 'T', 'S' ] } } );

    # Selects all atoms if no specific atoms are selected.
    if( ! %{ $selected_atom_site } ) {
        $selected_atom_site = $atom_site;
        mark_selection( $selected_atom_site,
                        { 'target' => [ keys %{ $selected_atom_site } ] } );
    }

    # Splits atom site into groups by its uniqueness.
    my $atom_site_groups = split_by( { 'atom_site' => $selected_atom_site,
                                       'attributes' => [ 'pdbx_PDB_model_num',
                                                         'label_alt_id',
                                                         'label_asym_id' ],
                                       'append_dot' => 1 } );

    my @energies = ();
    my %energies = (); # For calculating energies for the whole sidechains.
    for my $atom_site_identifier ( sort keys %{ $atom_site_groups } ) {
        my $current_atom_site =
            clone( filter( { 'atom_site' => $atom_site,
                             'include' =>
                                 { 'id' =>
                                       $atom_site_groups->{$atom_site_identifier}
                                 } } ) );

        # Replace every alt id to one in order to determine which calculation
        # calculated what atom.
        my ( undef, $current_alt_id ) = split /,/, $atom_site_identifier;
        for my $atom_id ( keys %{ $current_atom_site } ) {
            $current_atom_site->{$atom_id}{'label_alt_id'} = $current_alt_id;
        }

        connect_atoms( $current_atom_site, $PARAMETERS );
        hybridization( $current_atom_site, $PARAMETERS );

        my $target_atom_ids =
            filter( { 'atom_site' => $current_atom_site,
                      'include' => { '[local]_selection_state' => [ 'T' ] },
                      'data' => [ 'id' ],
                      'is_list' => 1 } );

        my $energy = energy( $current_atom_site, $interactions, $PARAMETERS,
                             { 'target_atom_ids' => $target_atom_ids,
                               'only_sidechains' => $do_sidechain,
                               'decompose' => $do_decompose } );

        if( $do_sidechain && ! $do_pairwise ) {
            push @{ $energies{$atom_site_identifier} }, @{ $energy };
        } else {
            push @energies, @{ $energy };
        }
    }

    my %pdbx_loops;
    if( $do_pairwise ) {
        $pdbx_loops{'_[local]_pairwise_energy'}{'attributes'} =
            [ 'id', 'atom_1_id', 'type_symbol_1', 'label_atom_1_id',
              'label_seq_1_id', 'label_comp_1_id', 'label_asym_1_id',
              'label_entity_1_id', 'label_alt_1_id',
              'atom_2_id', 'type_symbol_2', 'label_atom_2_id',
              'label_seq_2_id', 'label_comp_2_id', 'label_asym_2_id',
              'label_entity_2_id', 'label_alt_2_id', 'calculation_method',
              'value' ];

        my $calculation_id = 1;
        for my $energy ( @energies ) {
            my $atom_1_id = $energy->atoms->[0];
            my $atom_2_id = $energy->atoms->[-1];
            my $atom_1 = $atom_site->{$atom_1_id};
            my $atom_2 = $atom_site->{$atom_2_id};
            my $calculation_method = $energy->energy_type;
            my $value = $energy->value;
            push @{ $pdbx_loops{'_[local]_pairwise_energy'}{'data'} },
                $calculation_id, $atom_1_id, $atom_1->{'type_symbol'},
                $atom_1->{'label_atom_id'}, $atom_1->{'label_seq_id'},
                $atom_1->{'label_comp_id'}, $atom_1->{'label_asym_id'},
                $atom_1->{'label_entity_id'}, $atom_1->{'label_alt_id'},
                $atom_2_id, $atom_2->{'type_symbol'},
                $atom_2->{'label_atom_id'}, $atom_2->{'label_seq_id'},
                $atom_2->{'label_comp_id'}, $atom_2->{'label_asym_id'},
                $atom_2->{'label_entity_id'}, $atom_2->{'label_alt_id'},
                $calculation_method, sprintf( $SIG_FIGS_MAX, $value );
            $calculation_id++;
        }
    } elsif( $do_sidechain ) {
        $pdbx_loops{'_[local]_rotamer_energy'}{'attributes'} =
            [ 'id', 'label_seq_id', 'label_asym_id', 'pdbx_PDB_model_num',
              'label_alt_id', 'calculation_method', 'value' ];

        my %rotamer_energies = ();
        for my $atom_site_identifier ( keys %energies ) {
            # Devides rotamer energies according to their unique residue
            # identifiers.
            for my $energy ( @{ $energies{$atom_site_identifier} } ) {
                my $atom_id = $energy->atoms->[0];
                my $atom = $atom_site->{$atom_id};
                my $label_seq_id = $atom->{'label_seq_id'};
                my $energy_type = $energy->energy_type;
                if( exists $rotamer_energies{"$label_seq_id,$atom_site_identifier"} ) {
                    $rotamer_energies{"$label_seq_id,$atom_site_identifier"}
                                     {$energy_type} += $energy->value;
                } else {
                    $rotamer_energies{"$label_seq_id,$atom_site_identifier"}
                                     {$energy_type} = $energy->value;
                }
            }
        }

        my $calculation_id = 1;
        for my $unique_residue_identifier ( sort keys %rotamer_energies ) {
            my ( $label_seq_id, $pdbx_PDB_model_num, $label_alt_id,
                 $label_asym_id ) = split /,/, $unique_residue_identifier;
            for my $calculation_method (
                sort keys %{ $rotamer_energies{$unique_residue_identifier} } ) {
                push @{ $pdbx_loops{'_[local]_rotamer_energy'}{'data'} },
                    $calculation_id, $label_seq_id, $label_asym_id,
                    $pdbx_PDB_model_num, $label_alt_id, $calculation_method,
                    sprintf( $SIG_FIGS_MAX,
                             $rotamer_energies{$unique_residue_identifier}
                                              {$calculation_method} );
                $calculation_id++;
            }
        }
    } else {
        $pdbx_loops{'_[local]_energy'}{'attributes'} =
            [ 'id', 'atom_id', 'type_symbol', 'label_atom_id', 'label_seq_id',
              'label_comp_id', 'label_asym_id', 'pdbx_PDB_model_num',
              'label_alt_id', 'calculation_method', 'value' ];
    }

    if( $output_format eq 'pdbx' ) {
        if( $add_B_iso ) {
            to_pdbx( { 'atom_site' => $atom_site,
                       'add_atom_attributes' => [ 'B_iso_or_equiv' ] } );
        } else {
            to_pdbx( { 'pdbx_loops' => \%pdbx_loops } );
        }
    } elsif( $output_format eq 'csv' ) {
        if( $do_pairwise ) {
            pdbx_loop_to_csv( $pdbx_loops{'_[local]_pairwise_energy'} );
        } elsif( $do_sidechain ) {
            pdbx_loop_to_csv( $pdbx_loops{'_[local]_rotamer_energy'} );
        } else {
            pdbx_loop_to_csv( $pdbx_loops{'_[local]_energy'} );
        }
    }
}

#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
Getopt::Long::Configure qw( gnu_getopt );
use List::MoreUtils qw( any
                        uniq );

use AtomProperties qw( %ATOMS
                       @MAINCHAIN_NAMES );
use AtomInteractions qw( hard_sphere
                         soft_sphere
                         leonard_jones
                         coulomb
                         h_bond
                         composite );
use ConnectAtoms qw( connect_atoms
                     is_neighbour
                     is_second_neighbour );
use Grid qw( grid_box
             identify_neighbour_cells );
use BondProperties qw( hybridization );
use PDBxParser qw( filter
                   obtain_atom_site
                   to_pdbx );
use PseudoAtoms qw( add_hydrogens );

#*rotag_energy [options] file1 [file2, ...]
#*    calculates potential energy of selected atoms.
#*
#*USAGE:
#*    rotag_energy input.cif > output.cif
#*    rotag_energy -u hard_sphere input.cif > output.cif
#*
#*OPTIONS:
#*    -u, --potential (default: composite | hard_sphere | soft_sphere |
#*                              leonard_jones | coulomb | h_bond)
#*        uses potential energy function for determining interactions between
#*        selected residues and atoms that are reachable or described.
#*    -r, --rotamer
#*        calculate energy of the side-chain atoms for each selected residue.
#*    -d, --decompose
#*        decompose composite energy values into their constituent energy values.
#*    -p, --pairwise
#*        check energy of the atoms in pairwise fashion.
#*    -n, --threads
#*        number of threads.
#*    -v, --version
#*        print version.

# --------------------------------- Options ----------------------------------- #

my %options;

my $version = '1.0.0';
my $do_rotamer = 0;
my $do_pairwise = 0;
my $do_decompose = 0;

GetOptions(
    'potential|u=s' => \$options{'interactions'},
    'rotamer|r' => sub { $do_rotamer = 1 },
    'pairwise|p' => sub { $do_pairwise = 1 },
    'decompose|d' => sub { $do_decompose = 1 },
    'help|h' => sub { open( my $fh, '<', $0 );
                    while( <$fh> ) {
                        my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                        $help_message =~ s/^\*$/ /g if $help_message;
                        $help_message =~ s/^\*//g if $help_message;
                        print( $help_message, "\n" ) if $help_message; }
                    close( $fh );
                    exit; },
    'version|v' => sub { print $version, "\n";
                       exit; } )
    or die 'Error in command line argument.';

# Defaults.
my %potential_functions = (
    'composite' => \&composite,
    'hard_sphere' => \&hard_sphere,
    'soft_sphere' => \&soft_sphere,
    'leonard_jones' => \&leonard_jones,
    'coulomb' => \&coulomb,
    'h_bond' => \&h_bond
);
$options{'interactions'} //= 'composite';
$options{'threads'} //= 1;

# ----------------------------------- Main ------------------------------------ #

@ARGV = ( '-' ) unless @ARGV;

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and "-" operator.
    my $atom_site;
    if( $pdbx_file ) {
        $atom_site = obtain_atom_site( $pdbx_file );
    } else {
        die( "Use command \"rotag_energy --help\" in order to see the manual.\n" );
    }

    # Adds hydrogens for calculations where h_bond might be present.
    my %parameters;
    if( $options{'interactions'} eq 'composite'
     || $options{'interactions'} eq 'h_bond' ) {
        my %atom_site_with_hydrogens =
            ( %{ $atom_site },
              %{ add_hydrogens( $atom_site,
                                { 'add_only_clear_positions' => 1 } ) } );
        connect_atoms( \%atom_site_with_hydrogens );
        hybridization( \%atom_site_with_hydrogens );
        $parameters{'atom_site'} = \%atom_site_with_hydrogens;
    } else {
        # TODO: look, how it will behave when pseudo atoms are introduced.
        connect_atoms( $atom_site );
    }

    if( $do_decompose ) {
        $parameters{'decompose'} = 1;
    }

    # If the attribute '[local]_selection_state' is absent, then every atom is
    # selected.
    my @atom_ids = sort keys %{ $atom_site };
    if( ! exists $atom_site->{$atom_ids[0]}{'[local]_selection_state'} ){
        for my $atom_id ( @atom_ids ) {
            $atom_site->{$atom_id}{'[local]_selection_state'} = 'T';
        }
    }

    my $selected_atom_site =
        filter( { 'atom_site' => $atom_site,
                  'include' => { '[local]_selection_state' => [ 'T', 'S' ] } } );
    my $target_atom_ids =
        filter( { 'atom_site' => $selected_atom_site,
                  'include' => { '[local]_selection_state' => [ 'T' ] },
                  'data' => [ 'id' ],
                  'is_list' => 1 } );

    my ( $grid_box, $target_cells ) =
        grid_box( $selected_atom_site, undef, $target_atom_ids );

    my $neighbour_cells = identify_neighbour_cells( $grid_box, $target_cells );

    my $potential_function = $potential_functions{$options{'interactions'}};

    my %pdbx_loops;
    my $calculation_id = 1;

    if( $do_pairwise ) {
        $pdbx_loops{'_[local]_pairwise_energy'}{'attributes'} =
            [ 'id', 'atom_1_id', 'type_symbol_1', 'label_atom_1_id',
              'label_seq_1_id', 'label_comp_1_id', 'label_asym_1_id',
              'label_entity_1_id', 'label_alt_1_id',
              'atom_2_id', 'type_symbol_2', 'label_atom_2_id',
              'label_seq_2_id', 'label_comp_2_id', 'label_asym_2_id',
              'label_entity_2_id', 'label_alt_2_id', 'calculation_method',
              'value' ];
    } elsif( $do_rotamer ) {
        $pdbx_loops{'_[local]_rotamer_energy'}{'attributes'} =
            [ 'id', 'label_seq_id', 'label_asym_id', 'label_entity_id',
              'label_alt_id', 'calculation_method', 'value' ];
    } else {
        $pdbx_loops{'_[local]_energy'}{'attributes'} =
            [ 'id', 'atom_id', 'type_symbol', 'label_atom_id', 'label_seq_id',
              'label_comp_id', 'label_asym_id', 'label_entity_id',
              'label_alt_id', 'calculation_method', 'value' ];
    }

    # Calculates the sum of pairwise interactions.
    my %residue_energy;
    for my $cell ( sort { $a cmp $b } keys %{ $target_cells } ) {
        for my $atom_id ( @{ $target_cells->{$cell} } ) {
            if( $do_rotamer ) {
                next if any { $selected_atom_site->{$atom_id}{'label_atom_id'} eq $_ }
                            @MAINCHAIN_NAMES;
            }

            my ( $atom_symbol, $atom_name,
                 $atom_residue_id, $atom_residue_name,
                 $atom_chain, $atom_entity, $atom_alt ) =
                     map { $selected_atom_site->{$atom_id}{$_} }
                         ( 'type_symbol', 'label_atom_id', 'label_seq_id',
                           'label_comp_id', 'label_asym_id', 'label_entity_id',
                           'label_alt_id' );
            my $residue_unique_key =
                join(',',$atom_residue_id, $atom_chain, $atom_entity, $atom_alt);

            my $potential_energy = 0;
            my %potential_energy; # Used when decomposing composite energy values.
            for my $neighbour_atom_id ( uniq @{ $neighbour_cells->{$cell} } ) {
                if( ( $atom_id ne $neighbour_atom_id )
                 && ( ! is_neighbour( $selected_atom_site,
                                      $atom_id,
                                      $neighbour_atom_id ) )
                 && ( ! is_second_neighbour( $selected_atom_site,
                                             $atom_id,
                                             $neighbour_atom_id ) ) ) {
                    my ( $neighbour_symbol, $neighbour_name,
                         $neighbour_residue_id, $neighbour_residue_name,
                         $neighbour_chain, $neighbour_entity, $neighbour_alt ) =
                        map { $selected_atom_site->{$neighbour_atom_id}{$_} }
                            ( 'type_symbol', 'label_atom_id', 'label_seq_id',
                              'label_comp_id', 'label_asym_id', 'label_entity_id',
                              'label_alt_id' );

                    my $pairwise_potential_energy =
                        $potential_function->(
                            $selected_atom_site->{$atom_id},
                            $selected_atom_site->{$neighbour_atom_id},
                            \%parameters );

                    if( $do_pairwise ) {
                        if( $do_decompose ) {
                            for my $interaction (
                                grep { $_ ne 'composite' }
                                sort keys %{ $pairwise_potential_energy } ) {
                                push( @{ $pdbx_loops{'_[local]_pairwise_energy'}{'data'} },
                                      $calculation_id, $atom_id, $atom_symbol,
                                      $atom_name, $atom_residue_id,
                                      $atom_residue_name, $atom_chain,
                                      $atom_entity, $atom_alt,
                                      $neighbour_atom_id, $neighbour_symbol,
                                      $neighbour_name, $neighbour_residue_id,
                                      $neighbour_residue_name, $neighbour_chain,
                                      $neighbour_entity, $neighbour_alt,
                                      $interaction,
                                      sprintf( "%.3f", $pairwise_potential_energy->{$interaction} ) );
                                $calculation_id++;
                            }
                        } else {
                            push( @{ $pdbx_loops{'_[local]_pairwise_energy'}{'data'} },
                                  $calculation_id, $atom_id, $atom_symbol,
                                  $atom_name, $atom_residue_id,
                                  $atom_residue_name, $atom_chain, $atom_entity,
                                  $atom_alt,
                                  $neighbour_atom_id, $neighbour_symbol,
                                  $neighbour_name, $neighbour_residue_id,
                                  $neighbour_residue_name, $neighbour_chain,
                                  $neighbour_entity, $neighbour_alt,
                                  $options{'interactions'},
                                  sprintf( "%.3f", $pairwise_potential_energy ) );
                            $calculation_id++;
                        }
                    } elsif( $do_decompose ) {
                        for my $interaction (
                            grep { $_ ne 'composite' }
                            sort keys %{ $pairwise_potential_energy } ) {
                            if( $potential_energy{$interaction} ) {
                                $potential_energy{$interaction} =
                                    $pairwise_potential_energy->{$interaction};
                            } else {
                                $potential_energy{$interaction} +=
                                    $pairwise_potential_energy->{$interaction};
                            }
                        }
                    } else {
                        $potential_energy += $pairwise_potential_energy;
                    }
                }
            }

            if( ! $do_pairwise && ! $do_decompose && ! $do_rotamer ) {
                push( @{ $pdbx_loops{"_[local]_energy"}{"data"} },
                      $calculation_id, $atom_id, $atom_symbol, $atom_name,
                      $atom_residue_id, $atom_residue_name, $atom_chain,
                      $atom_entity, $atom_alt, $options{'interactions'},
                      sprintf( "%.3f", $potential_energy ) );
                $calculation_id++;
            }

            if( $do_decompose && ! $do_rotamer ) {
                for my $interaction (
                    grep { $_ ne 'composite' } sort keys %potential_energy ) {
                    push( @{ $pdbx_loops{"_[local]_energy"}{"data"} },
                          $calculation_id, $atom_id, $atom_symbol, $atom_name,
                          $atom_residue_id, $atom_residue_name, $atom_chain,
                          $atom_entity, $atom_alt, $interaction,
                          sprintf( "%.3f", $potential_energy{$interaction} ) );
                    $calculation_id++;
                }
            }

            if( $do_rotamer ) {
                if( $do_decompose ) {
                    for my $interaction ( grep { $_ ne 'composite' }
                                          sort keys %potential_energy ) {
                        if( exists $residue_energy{$residue_unique_key}
                         && exists $residue_energy{$residue_unique_key}
                                                  {$interaction} ) {
                            $residue_energy{$residue_unique_key}{$interaction} +=
                                $potential_energy{$interaction};
                        } else {
                            $residue_energy{$residue_unique_key}{$interaction} =
                                $potential_energy{$interaction};
                        }
                    }
                } else {
                    if( exists $residue_energy{$residue_unique_key}
                     && exists $residue_energy{$residue_unique_key}
                                              {$options{'interactions'}} ) {
                        $residue_energy{$residue_unique_key}
                                       {$options{'interactions'}} +=
                            $potential_energy;
                    } else {
                        $residue_energy{$residue_unique_key}
                                       {$options{'interactions'}} =
                            $potential_energy;
                    }
                }
            }
        }
    }

    if( $do_rotamer ) {
        my $calculation_id = 1;
        for my $residue_unique_key ( sort keys %residue_energy ) {
            for my $interaction ( sort keys %{ $residue_energy{$residue_unique_key} } ) {
                push( @{ $pdbx_loops{"_[local]_rotamer_energy"}{"data"} },
                      $calculation_id, split( ',', $residue_unique_key ),
                      $interaction,
                      sprintf( "%.3f", $residue_energy{$residue_unique_key}{$interaction} ) );
                $calculation_id++;
            }
        }
    }

    to_pdbx( { "pdbx_loops" => \%pdbx_loops } );
}

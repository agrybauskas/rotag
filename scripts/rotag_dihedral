#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use File::Basename;
use Getopt::Long;
use List::MoreUtils qw( uniq );
use Try::Tiny;

use BondProperties qw( hybridization );
use ConnectAtoms qw( connect_atoms );
use ForceField::Parameters;
use Logging qw( error
                warning );
use Measure qw( all_dihedral
                dihedral_angle );
use PDBxParser qw( filter
                   filter_by_unique_residue_key
                   mark_selection
                   pdbx_loop_to_csv
                   obtain_atom_site
                   to_pdbx );
use Version qw( $VERSION );

Getopt::Long::Configure qw( gnu_getopt );

our $VERSION = $VERSION;

#*rotag_dihedral [options] <file>...
#*    calculate dihedral angles of residues or selected atoms.
#*
#*Usage:
#*    rotag_dihedral input.cif > output.cif
#*
#*Options:
#*    -S, --side-chains     calculates chi angles of the side-chain atoms.
#*
#*    -M, --main-chains     calculates phi and psi angles of the main-chain atoms.
#*
#*    -r, --radians         angles are in radians.
#*
#*    -F, --format <format> output format (default: pdbx | csv).
#*
#*    -v, --version         print version.

# --------------------------------- Options ----------------------------------- #

my $calc_sidechain = 0;
my $calc_mainchain = 0;
my $in_radians = 0;
my $output_format = 'pdbx';

local $SIG{__WARN__} = sub {
    warning( { 'message' => @_ } );
};

local $SIG{__DIE__} = sub {
    error( { 'program' => $0, 'message' => @_ } );
};

GetOptions(
    'side-chains|S' => sub { $calc_sidechain = 1 },
    'main-chains|M' => sub { $calc_mainchain = 1 },
    'radians|r' => sub { $in_radians = 1 },
    'format|F=s' => \$output_format,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or error( { 'program' => $0,
              'message' => "mistake in command line argument.\n" } );

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

my $PARAMETERS = Parameters->new();
my $PI = $PARAMETERS->{'_[local]_constants'}{'pi'};
my $SIG_FIGS_MAX = $PARAMETERS->{'_[local]_constants'}{'sig_figs_max'};

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    $atom_site = obtain_atom_site( $pdbx_file );

    if( ! %{ $atom_site } ) {
        warning( { 'message' => "$pdbx_file is empty.\n" } );
        exit;
    }

    # Calculates dihedral angles
    my %pdbx_loops;

    if( $calc_sidechain ) {
        $pdbx_loops{'_[local]_dihedral_angle'}{'attributes'} =
            [ 'id', 'label_comp_id', 'label_seq_id', 'label_asym_id',
              'pdbx_PDB_model_num', 'label_alt_id', 'atom_1_id', 'label_atom_1_id',
              'atom_2_id', 'label_atom_2_id', 'atom_3_id', 'label_atom_3_id',
              'atom_4_id', 'label_atom_4_id', 'type', 'value', 'units' ];

        my $dihedral_site =
            filter( { 'atom_site' => $atom_site,
                      'include' => { '[local]_selection_state' => [ 'T' ] } } );

        # Selects all atoms if no specific atoms are selected.
        if( ! %{ $dihedral_site } ) {
            $dihedral_site = $atom_site;
            mark_selection( $dihedral_site,
                            { 'target' => [ keys %{ $dihedral_site } ] } );
        }

        connect_atoms( $dihedral_site, $PARAMETERS );
        hybridization( $dihedral_site, $PARAMETERS );

        my $dihedral_angles = all_dihedral( $dihedral_site,
                                            { 'calc_mainchain' =>
                                                  ( $calc_mainchain ? 1 : 0 ) });

        my $dihedral_id = 1;
        for my $residue_unique_key ( sort keys %{ $dihedral_angles } ) {
            my $residue_site =
                filter_by_unique_residue_key( $dihedral_site,
                                              $residue_unique_key );
            my ( $residue_id ) = keys %{ $residue_site };
            my $residue_name = $residue_site->{$residue_id}{'label_comp_id'};

            for my $angle_name (
                sort keys %{ $dihedral_angles->{$residue_unique_key} } ) {
                my @atom_ids = @{ $dihedral_angles->{$residue_unique_key}
                                                    {$angle_name}{'atom_ids'} };
                push @{ $pdbx_loops{'_[local]_dihedral_angle'}{'data'} },
                     $dihedral_id, $residue_name,
                     split( /,/sxm, $residue_unique_key ),
                     $dihedral_site->{$atom_ids[0]}{'label_atom_id'},
                     $atom_ids[0],
                     $dihedral_site->{$atom_ids[1]}{'label_atom_id'},
                     $atom_ids[1],
                     $dihedral_site->{$atom_ids[2]}{'label_atom_id'},
                     $atom_ids[2],
                     $dihedral_site->{$atom_ids[3]}{'label_atom_id'},
                     $atom_ids[3],
                     $angle_name,
                     ( $in_radians ?
                       sprintf $SIG_FIGS_MAX,
                               $dihedral_angles->{$residue_unique_key}
                                                 {$angle_name}
                                                 {'value'} :
                       sprintf $SIG_FIGS_MAX,
                               $dihedral_angles->{$residue_unique_key}
                                                 {$angle_name}
                                                 {'value'} * 180 / $PI ),
                     ( $in_radians ? 'radians' : 'degrees' );
                $dihedral_id++;
            }
        }

    } else {
        $pdbx_loops{'_[local]_dihedral_angle'}{'attributes'} =
            [ 'id', 'label_atom_1_id', 'atom_1_id', 'label_atom_2_id',
              'atom_2_id', 'label_atom_3_id', 'atom_3_id', 'label_atom_4_id',
              'atom_4_id', 'value', 'units' ];

        my $dihedral_site =
            filter( { 'atom_site' => $atom_site,
                      'include' => { '[local]_selection_state' => [ 'T' ] },
                      'exclude' => { '[local]_selection_group' => [ q{?} ] } } );

        my @dihedral_atom_ids =
            sort { $dihedral_site->{"$a"}{'[local]_selection_group'} <=>
                   $dihedral_site->{"$b"}{'[local]_selection_group'} }
            keys %{ $dihedral_site };

        my $dihedral_id = 1;
        for( my $i = 0; $i <= $#dihedral_atom_ids; $i = $i + 4 ) {
            my $first_atom_id = $dihedral_atom_ids[$i];
            my $second_atom_id = $dihedral_atom_ids[$i+1];
            my $third_atom_id = $dihedral_atom_ids[$i+2];
            my $fourth_atom_id = $dihedral_atom_ids[$i+3];
            my $dihedral_angle =
                dihedral_angle(
                    [ map { [ $dihedral_site->{$_}{'Cartn_x'},
                              $dihedral_site->{$_}{'Cartn_y'},
                              $dihedral_site->{$_}{'Cartn_z'} ] }
                      ( $first_atom_id, $second_atom_id,
                        $third_atom_id, $fourth_atom_id ) ] );

            push @{ $pdbx_loops{'_[local]_dihedral_angle'}{'data'} },
                 $dihedral_id,
                 $dihedral_site->{$first_atom_id}{'label_atom_id'},
                 $first_atom_id,
                 $dihedral_site->{$second_atom_id}{'label_atom_id'},
                 $second_atom_id,
                 $dihedral_site->{$third_atom_id}{'label_atom_id'},
                 $third_atom_id,
                 $dihedral_site->{$fourth_atom_id}{'label_atom_id'},
                 $fourth_atom_id,
                 ( $in_radians ? sprintf $SIG_FIGS_MAX, $dihedral_angle
                               : sprintf $SIG_FIGS_MAX, $dihedral_angle * 180 / $PI ),
                 ( $in_radians ? 'radians' : 'degrees' );
            $dihedral_id++;
        }
    }

    if( $output_format eq 'pdbx' ) {
        to_pdbx( { 'pdbx_loops' => \%pdbx_loops } );
    } elsif( $output_format eq 'csv' ) {
        pdbx_loop_to_csv( $pdbx_loops{'_[local]_dihedral_angle'} );
    }
}

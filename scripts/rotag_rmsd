#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use List::MoreUtils qw( uniq );

use PDBxParser qw( filter
                   obtain_atom_site
                   to_pdbx );
use Measure qw( rmsd );

#*rotag_rmsd
#*    calculates rmsd between two groups of atoms.
#*
#*USAGE:
#*    rotag_rmsd --input input.cif > output.cif
#*
#*OPTIONS:
#*    --input <file> | <stdin>
#*        PDBx file.
#*    --strict
#*        uses atom names to validate the pairs of atoms. Otherwise, only
#*        coordinates are used and correct pairing is up to the PDBx file.
#*    --version
#*        print version.

# --------------------------------- Options ----------------------------------- #

my %options;

my $version = "1.0.0";
my $is_strict = 0;

GetOptions(
    "input=s" => \$options{"pdbx_file"},
    "strict" => sub { $is_strict = 1 },
    "help" => sub { open( my $fh, "<", $0 );
                    while( <$fh> ) {
                        my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                        $help_message =~ s/^\*$/ /g if $help_message;
                        $help_message =~ s/^\*//g if $help_message;
                        print( $help_message, "\n" ) if $help_message; }
                    close( $fh );
                    exit; },
    "version" => sub { print $version, "\n";
                       exit; } )
    or die "Error in command line argument.";

# ----------------------------------- Main ------------------------------------ #

# Reads file path, stdin and "-" operator.
my $atom_site;
if( $options{"pdbx_file"} ) {
    $atom_site = obtain_atom_site( $options{"pdbx_file"} );
} elsif( ! defined $options{"pdbx_file"} && ! -t STDIN ) {
    $atom_site = obtain_atom_site( '-' );
} else {
    die( "Use command \"rotag_rmsd --help\" in order to see the manual.\n" );
}

# Calculates RMSD.
my %pdbx_loops;
$pdbx_loops{"_[local]_dihedral_angle"}{"attributes"} =
    [ "id", "atom_1_id", "atom_2_id", "atom_3_id", "atom_4_id", "value" ];

my $rmsd_atom_site =
    filter( { "atom_site" => $atom_site,
              "include" => { "[local]_selection_state" => [ "T" ] },
              "exclude" => { "[local]_selection_group" => [ "?" ] } } );
my @group_ids =
    uniq( @{ filter( { "atom_site" => $rmsd_atom_site,
                       "data" => [ "[local]_selection_group" ],
                       "is_list" => 1 } ) } );

my @rmsd;
if( $is_strict ) {
    for( my $i = 0; $i <= $#group_ids; $i = $i + 2 ) {
        my $first_group_data =
            filter( { "atom_site" => $rmsd_atom_site,
                      "include" =>
                          { "[local]_selection_group" => [ $group_ids[$i] ] },
                      "data" => [ "label_atom_id",
                                  "Cartn_x", "Cartn_y", "Cartn_z" ] } );
        my $second_group_data =
            filter( { "atom_site" => $rmsd_atom_site,
                      "include" =>
                          { "[local]_selection_group" => [ $group_ids[$i+1] ] },
                            "data" => [ "label_atom_id",
                                        "Cartn_x", "Cartn_y", "Cartn_z" ] } );
        # Checks the length of the atom sets.
        # HACK: error message is duplicated in Measure::rmsd().
        die( "Comparing different sizes of sets of the atoms is not allowed." )
            if scalar(@{ $first_group_data }) ne scalar(@{ $second_group_data });

        # Sorts by residue name first by checking if their residue names are
        # correct.
        $first_group_data =
            [ sort { $a->[0] cmp $b->[0] } @{ $first_group_data } ];
        $second_group_data =
            [ sort { $a->[0] cmp $b->[0] } @{ $second_group_data } ];
        my @first_group_coord;
        my @second_group_coord;
        for( my $i = 0; $i <= $#{ $first_group_data }; $i++ ) {
            if( $first_group_data->[$i][0] ne $second_group_data->[$i][0] ) {
                die( "Atom names do not match: $first_group_data->[$i][0] and " .
                     "$second_group_data->[$i][0]." );
            } else {
                push( @first_group_coord,
                      [ (@{ $first_group_data->[$i] })[1..3] ] );
                push( @second_group_coord,
                      [ (@{ $second_group_data->[$i] })[1..3] ] );
            }
        }
        push( @rmsd, rmsd( \@first_group_coord, \@second_group_coord ) );
    }

} else {
    for( my $i = 0; $i <= $#group_ids; $i = $i + 2 ) {
        my $first_group_coord =
            filter( { "atom_site" => $rmsd_atom_site,
                      "include" =>
                          { "[local]_selection_group" => [ $group_ids[$i] ] },
                      "data" => [ "Cartn_x", "Cartn_y", "Cartn_z" ] } );
        my $second_group_coord =
            filter( { "atom_site" => $rmsd_atom_site,
                      "include" =>
                          { "[local]_selection_group" => [ $group_ids[$i+1] ] },
                      "data" => [ "Cartn_x", "Cartn_y", "Cartn_z" ] } );
        push( @rmsd, rmsd( $first_group_coord, $second_group_coord ) );
    }
}

# TODO: change to cif format.
foreach( @rmsd ) {
    printf( "%.3f\n", $_ );
}

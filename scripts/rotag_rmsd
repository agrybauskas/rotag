#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Carp;
use Getopt::Long;
use List::MoreUtils qw( uniq );
use List::Util qw( sum );
use Try::Tiny;

use ForceField::Parameters;
use Logging qw( error
                warning );
use PDBxParser qw( filter
                   obtain_atom_sites
                   pdbx_loop_to_csv
                   split_by
                   to_pdbx );
use Measure qw( rmsd );
use Version qw( $VERSION );

Getopt::Long::Configure qw( gnu_getopt );

our $VERSION = $VERSION;

#*rotag_rmsd [options] -c <groups> <file>...
#*    calculate rmsd between two groups of atoms.
#*
#*Usage:
#*    rotag_rmsd input.cif > output.cif
#*
#*Options:
#*    -c, --compare <str>   compares atoms of the defined groups.
#*
#*                          E.g.: -c '1, 2' or -c '3, 4; 5, 7'
#*
#*    -S, --side-chains     compares only side-chain atoms agains other
#*                          side-chain atoms.
#*
#*    -b, --best-case       chooses best RMSD value of side-chain comparison.
#*
#*    -d, --decompose       decompose RMSD value of the group to its
#*                          constituents.
#*
#*    -F, --format <format> output format (default: pdbx | csv).
#*
#*    -v, --version         print version.

# --------------------------------- Options ----------------------------------- #

my $comparison = q{};
my $rmsd_sidechains = 0;
my $rmsd_best_case = 0;
my $do_decompose = 0;
my $output_format = 'pdbx';

local $SIG{__WARN__} = sub {
    warning( { 'program' => $0, 'message' => @_ } );
};

local $SIG{__DIE__} = sub {
    error( { 'program' => $0, 'message' => @_ } );
};

GetOptions(
    'compare|c=s' => \$comparison,
    'side-chains|S' => sub { $rmsd_sidechains = 1; },
    'best-case|b' => sub { $rmsd_best_case = 1; },
    'decompose|d' => sub { $do_decompose = 1; },
    'format|F=s' => \$output_format,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
)  or error( { 'program' => $0,
               'message' => "mistake in command line argument.\n" } );

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

$comparison =~ s/ //g;
my @comparison_groups = map { [ split /,/, $_ ] } ( split /;/, $comparison );

error( { 'message' => "No comparison groups are selected. Use -c argument.\n" } )
    if ! @comparison_groups;

my %atom_site_groups = ();

my $parameters = Parameters->new();
my $sig_figs_max = $parameters->{'_[local]_constants'}{'sig_figs_max'};

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_sites;
    $atom_sites = obtain_atom_sites( $pdbx_file );

    for my $atom_site ( @{ $atom_sites } ) {
        # Assigns filters atoms and assigns to specified groups.
        my @group_ids =
            uniq( @{ filter( { 'atom_site' => $atom_site,
                               'data' => [ '[local]_selection_group' ],
                               'is_list' => 1 } ) } );

        for my $group_id ( @group_ids ) {
            if( ! exists $atom_site_groups{$group_id} ) {
                my $group_atom_site =
                    filter( { 'atom_site' => $atom_site,
                              'include' =>
                                  { '[local]_selection_state' => [ 'T' ],
                                    '[local]_selection_group' => [$group_id] }});
                $atom_site_groups{$group_id} = $group_atom_site;
            } else {
                confess 'there are multiple instances of the group in' .
                        ' different files';
            }
        }
    }
}

exit if ! %atom_site_groups;

# Calculates RMSD.
my %pdbx_loops;
if( $do_decompose ) {
    $pdbx_loops{'_[local]_rmsd'}{'attributes'} =
        [ 'id', 'group_1_id', 'atom_1_id', 'label_atom_1_id', 'label_seq_1_id',
          'label_comp_1_id', 'label_asym_1_id', 'pdbx_PDB_model_num_1',
          'label_alt_1_id', 'group_2_id', 'atom_2_id', 'label_atom_2_id',
          'label_seq_2_id', 'label_comp_2_id', 'label_asym_2_id',
          'pdbx_PDB_model_num_2', 'label_alt_2_id', 'value' ];
} else {
    $pdbx_loops{'_[local]_rmsd'}{'attributes'} =
        [ 'id', 'group_1_id', 'group_2_id', 'value' ];
}

my $rmsd_counter = 1;

for my $comparison_group ( @comparison_groups ) {
    if( scalar @{ $comparison_group } != 2 ) {
        confess 'there has to be two groups of atoms to be compared against';
    }

    # Checks if these groups exist.
    for my $group ( @{ $comparison_group } ) {
        if( ! exists $atom_site_groups{$group} ) {
            confess "group $group is not present in pdbx"
        }
    }

    # Generates the comparison pairs.
    my $first_atom_groups =
        split_by( { 'atom_site' => $atom_site_groups{$comparison_group->[0]},
                    'attributes' => [ 'label_seq_id', 'label_asym_id',
                                      'pdbx_PDB_model_num' ] } );
    my $second_atom_groups =
        split_by( { 'atom_site' => $atom_site_groups{$comparison_group->[1]},
                    'attributes' => [ 'label_seq_id', 'label_asym_id',
                                      'pdbx_PDB_model_num' ] } );

    for my $first_group_key ( sort keys %{ $first_atom_groups } ) {
        my ( $residue_id, $chain, $pdbx_model_num ) =
            split /,/,$first_group_key;
        my $first_group_atom_ids = $first_atom_groups->{$first_group_key};
        my $second_group_atom_ids = $second_atom_groups->{$first_group_key};
        my $first_group_atom_site =
            filter( { 'atom_site' => $atom_site_groups{$comparison_group->[0]},
                      'include' => { 'id' => $first_group_atom_ids } } );
        my $second_group_atom_site =
            filter( { 'atom_site' => $atom_site_groups{$comparison_group->[1]},
                      'include' => { 'id' => $second_group_atom_ids } } );

        if( $rmsd_sidechains ) {
            next if ( ! defined $second_group_atom_ids ||
                      ! @{ $second_group_atom_ids } ) &&
                    $rmsd_sidechains;

            my @first_alt_ids =
                uniq @{ filter( { 'atom_site' => $first_group_atom_site,
                                  'data' => [ 'label_alt_id' ],
                                  'is_list' => 1 } ) };
            my @second_alt_ids =
                uniq @{ filter( { 'atom_site' => $second_group_atom_site,
                                  'data' => [ 'label_alt_id' ],
                                  'is_list' => 1 } ) };

            for my $first_alt_id ( @first_alt_ids ) {
                my $first_sidechain_data =
                    filter( { 'atom_site' => $first_group_atom_site,
                              'include' =>
                                  { 'label_seq_id' => [ $residue_id ],
                                    'label_asym_id' => [ $chain ],
                                    'pdbx_PDB_model_num' => [ $pdbx_model_num ],
                                    'label_alt_id' => [ $first_alt_id ] },
                              'data' =>
                                  [ 'id', '[local]_selection_group',
                                    'label_atom_id', 'label_seq_id',
                                    'label_comp_id', 'label_asym_id',
                                    'pdbx_PDB_model_num', 'label_alt_id',
                                    'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );
                for my $second_alt_id ( @second_alt_ids ) {
                    my $second_sidechain_data =
                        filter( { 'atom_site' => $second_group_atom_site,
                                  'include' =>
                                      { 'label_seq_id' => [ $residue_id ],
                                        'label_asym_id' => [ $chain ],
                                        'pdbx_PDB_model_num' =>[$pdbx_model_num],
                                        'label_alt_id' => [ $second_alt_id ] },
                                  'data' =>
                                      [ 'id', '[local]_selection_group',
                                        'label_atom_id', 'label_seq_id',
                                        'label_comp_id', 'label_asym_id',
                                        'pdbx_PDB_model_num', 'label_alt_id',
                                        'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );

                    # Checks the length of the atom sets.
                    # TODO: error message is duplicated in Measure::rmsd().
                    if( scalar @{ $first_sidechain_data } ne
                        scalar @{ $second_sidechain_data } ) {
                        confess 'comparing different sizes of sets of the atoms ' .
                                'is not allowed';
                    }

                    # Sorts by residue name first by checking if their residue
                    # names are correct.
                    $first_sidechain_data  =
                        [ sort { $a->[2] cmp $b->[2] }
                              @{ $first_sidechain_data  } ];
                    $second_sidechain_data =
                        [ sort { $a->[2] cmp $b->[2] }
                              @{ $second_sidechain_data } ];

                    # my @first_sidechain_coord;
                    # my @second_sidechain_coord;
                    my @pairwise_sidechain_data;

                    for( my $i = 0; $i <= $#{ $first_sidechain_data }; $i++ ) {
                        if( $first_sidechain_data->[$i][2] ne
                            $second_sidechain_data->[$i][2] ) {
                            confess 'atom names do not match: ' .
                                    "$first_sidechain_data->[$i][2] and " .
                                    "$second_sidechain_data->[$i][2]";
                        }

                        push @pairwise_sidechain_data,
                            [ ( @{ $first_sidechain_data->[$i] } )[0..7],
                              ( @{ $second_sidechain_data->[$i] } )[0..7],
                              sprintf $sig_figs_max,
                              rmsd( [ [ ( @{$first_sidechain_data->[$i]} )
                                                                   [8..10] ] ],
                                    [ [ ( @{$second_sidechain_data->[$i]} )
                                                                    [8..10] ]])];
                    }

                    if( $rmsd_best_case ) {
                        my $best_pairwise_data; # By RMSD.
                        my $best_rmsd_average;

                        my $current_rmsd_sum = 0;
                        my $current_rmsd_count = 0;
                        foreach ( @pairwise_sidechain_data ) {
                            $current_rmsd_sum += $_->[16];
                            $current_rmsd_count++;
                        }

                        # } else {
                        #     $best_pairwise_data = $current_pairwise_data;
                        #     $best_rmsd_average = $current_rmsd_average;
                        # }

                        # @pairwise_sidechain_data =
                        #     sort { $a->[16] <=> $b->[16] }
                        #          @pairwise_sidechain_data;
                    }

                    last;
                        # elsif( $do_decompose ) {

                        # } else {
                        #     push @first_sidechain_coord,
                        #         [ ( @{ $first_sidechain_data->[$i] } )[8..10] ];
                        #     push @second_sidechain_coord,
                        #         [ ( @{ $second_sidechain_data->[$i] } )[8..10] ];
                        # }


                        # if( $do_decompose ) {
                        #     push @{ $pdbx_loops{'_[local]_rmsd'}{'data'} },
                        #         $rmsd_counter,
                        #         ( @{ $first_sidechain_data->[$i] } )[0..7],
                        #         ( @{ $second_sidechain_data->[$i] } )[0..7],
                        #         sprintf $sig_figs_max,
                        #         rmsd([[( @{$first_sidechain_data->[$i]} )[8..10]]],
                        #              [[( @{$second_sidechain_data->[$i]} )[8..10]]]);
                        # } else {
                        #     push @first_sidechain_coord,
                        #         [ ( @{ $first_sidechain_data->[$i] } )[8..10] ];
                        #     push @second_sidechain_coord,
                        #         [ ( @{ $second_sidechain_data->[$i] } )[8..10] ];
                        # }

                    # if( ! $do_decompose ) {
                    #     push @{ $pdbx_loops{'_[local]_rmsd'}{'data'} },
                    #         $rmsd_counter, $comparison_group->[0],
                    #         $comparison_group->[1], sprintf $sig_figs_max,
                    #         rmsd( \@first_sidechain_coord,
                    #               \@second_sidechain_coord );
                    # }

                    $rmsd_counter++;
                }
                last;
            }
        } else {
            my $first_group_data =
                filter( { 'atom_site' => $atom_site_groups{$comparison_group->[0]},
                          'data' =>
                              [ 'id', '[local]_selection_group', 'label_atom_id',
                                'label_seq_id', 'label_comp_id', 'label_asym_id',
                                'pdbx_PDB_model_num', 'label_alt_id', 'Cartn_x',
                                'Cartn_y', 'Cartn_z' ] } );
            my $second_group_data =
                filter( { 'atom_site' => $atom_site_groups{$comparison_group->[1]},
                          'data' =>
                              [ 'id', '[local]_selection_group', 'label_atom_id',
                                'label_seq_id', 'label_comp_id', 'label_asym_id',
                                'pdbx_PDB_model_num', 'label_alt_id', 'Cartn_x',
                                'Cartn_y', 'Cartn_z' ] } );

            # Checks the length of the atom sets.
            # TODO: error message is duplicated in Measure::rmsd().
            if( scalar @{ $first_group_data } ne scalar @{ $second_group_data }){
                confess 'comparing different sizes of sets of the atoms is not ' .
                        'allowed';
            }

            # Sorts by residue name first by checking if their residue names are
            # correct.
            $first_group_data  =
                [ sort { $a->[2] cmp $b->[2] } @{ $first_group_data  }];
            $second_group_data =
                [ sort { $a->[2] cmp $b->[2] } @{ $second_group_data }];

            my @first_group_coord;
            my @second_group_coord;

            for( my $i = 0; $i <= $#{ $first_group_data }; $i++ ) {
                if( $first_group_data->[$i][2] ne $second_group_data->[$i][2] ) {
                    confess "atom names do not match: $first_group_data->[$i][2] " .
                            "and $second_group_data->[$i][2]";
                }

                if( $do_decompose ) {
                    push @{ $pdbx_loops{'_[local]_rmsd'}{'data'} },
                        $rmsd_counter,
                        ( @{ $first_group_data->[$i] } )[0..7],
                        ( @{ $second_group_data->[$i] })[0..7],
                        sprintf $sig_figs_max,
                        rmsd( [ [ ( @{ $first_group_data->[$i] }  )[8..10] ] ],
                              [ [ ( @{ $second_group_data->[$i] } )[8..10] ] ] );
                } else {
                    push @first_group_coord,
                        [ ( @{ $first_group_data->[$i] } )[8..10] ];
                    push @second_group_coord,
                        [ ( @{ $second_group_data->[$i] } )[8..10] ];
                }
            }

            if( ! $do_decompose ) {
                push @{ $pdbx_loops{'_[local]_rmsd'}{'data'} },
                    $rmsd_counter, $comparison_group->[0], $comparison_group->[1],
                    sprintf $sig_figs_max,
                    rmsd( \@first_group_coord, \@second_group_coord );
            }

            $rmsd_counter++;
        }
    }
}

# Prints out cif or csv
# TODO: decide what to do when group data is empty.
if( $output_format eq 'pdbx' ) {
    to_pdbx( { 'pdbx_loops' => \%pdbx_loops } );
} elsif( $output_format eq 'csv' ) {
    pdbx_loop_to_csv( $pdbx_loops{'_[local]_rmsd'} );
}

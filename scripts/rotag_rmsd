#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Getopt::Long;
Getopt::Long::Configure qw( gnu_getopt );
use List::MoreUtils qw( uniq );

use Constants qw( $SIG_FIGS );
use PDBxParser qw( filter
                   obtain_atom_site
                   to_pdbx );
use Measure qw( rmsd );
use Version qw( $VERSION );

our $VERSION = $VERSION;

#*rotag_rmsd [options] file1 [file2, ...]
#*    calculates rmsd between two groups of atoms.
#*
#*USAGE:
#*    rotag_rmsd input.cif > output.cif
#*
#*OPTIONS:
#*    -s, --strict
#*        uses atom names to validate the pairs of atoms. Otherwise, only
#*        coordinates are used and correct pairing is up to the PDBx file.
#*    -v, --version
#*        print version.

# --------------------------------- Options ----------------------------------- #

my $is_strict = 0;

GetOptions(
    'strict|S' => sub { $is_strict = 1 },
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'Error in command line argument.';

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    if( $pdbx_file ) {
        $atom_site = obtain_atom_site( $pdbx_file );
    } else {
        die "Use command \"rotag_rmsd --help\" in order to see the manual.\n";
    }

    # Calculates RMSD.
    my %pdbx_loops;
    $pdbx_loops{'_[local]_rmsd'}{'attributes'} =
        [ 'id', 'group_1_id', 'group_2_id', 'value' ];

    my $rmsd_atom_site =
        filter( { 'atom_site' => $atom_site,
                  'include' => { '[local]_selection_state' => [ 'T' ] },
                  'exclude' => { '[local]_selection_group' => [ q{?} ] } } );
    my @group_ids =
        uniq( @{ filter( { 'atom_site' => $rmsd_atom_site,
                           'data' => [ '[local]_selection_group' ],
                           'is_list' => 1 } ) } );

    if( $is_strict ) {
        my $rmsd_counter = 1;
        for( my $i = 0; $i <= $#group_ids; $i = $i + 2 ) {
            my $first_group_data =
                filter( { 'atom_site' => $rmsd_atom_site,
                          'include' =>
                              { '[local]_selection_group' => [ $group_ids[$i] ]},
                          'data' => [ 'label_atom_id',
                                      'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );
            my $second_group_data =
                filter( { 'atom_site' => $rmsd_atom_site,
                          'include' =>
                              {'[local]_selection_group' => [ $group_ids[$i+1]]},
                               'data' => [ 'label_atom_id',
                                           'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );

            # Checks the length of the atom sets.
            # HACK: error message is duplicated in Measure::rmsd().
            if( scalar @{ $first_group_data } ne scalar @{ $second_group_data }){
                die 'Comparing different sizes of sets of the atoms is not ' .
                    'allowed.'
            }

            # Sorts by residue name first by checking if their residue names are
            # correct.
            $first_group_data =
                [ sort { $a->[0] cmp $b->[0] } @{ $first_group_data } ];
            $second_group_data =
                [ sort { $a->[0] cmp $b->[0] } @{ $second_group_data } ];
            my @first_group_coord;
            my @second_group_coord;
            for( my $i = 0; $i <= $#{ $first_group_data }; $i++ ) {
                if( $first_group_data->[$i][0] ne $second_group_data->[$i][0] ) {
                    die "Atom names do not match: $first_group_data->[$i][0] " .
                         "and $second_group_data->[$i][0].";
                } else {
                    push @first_group_coord,
                         [ (@{ $first_group_data->[$i] })[1..3] ];
                    push @second_group_coord,
                         [ (@{ $second_group_data->[$i] })[1..3] ];
                }
            }

            push @{ $pdbx_loops{'_[local]_rmsd'}{'data'} },
                 $rmsd_counter, $group_ids[$i], $group_ids[$i+1],
                 sprintf $SIG_FIGS,
                         rmsd( \@first_group_coord, \@second_group_coord );
            $rmsd_counter++;
        }
    } else {
        my $rmsd_counter = 1;
        for( my $i = 0; $i <= $#group_ids; $i = $i + 2 ) {
            my $first_group_coord =
                filter( { 'atom_site' => $rmsd_atom_site,
                          'include' =>
                              { '[local]_selection_group' => [ $group_ids[$i] ] },
                          'data' => [ 'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );
            my $second_group_coord =
                filter( { 'atom_site' => $rmsd_atom_site,
                          'include' =>
                              { '[local]_selection_group' => [ $group_ids[$i+1] ] },
                          'data' => [ 'Cartn_x', 'Cartn_y', 'Cartn_z' ] } );

            push @{ $pdbx_loops{'_[local]_rmsd'}{'data'} },
                 $rmsd_counter, $group_ids[$i], $group_ids[$i+1],
                 sprintf $SIG_FIGS,
                         rmsd( $first_group_coord, $second_group_coord );
            $rmsd_counter++;
        }
    }

    # Prints out cif.
    to_pdbx( { 'pdbx_loops' => \%pdbx_loops } );
}

#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use List::MoreUtils qw( uniq );
use List::Util qw( any );

use PDBxParser qw( filter
                   obtain_atom_site
                   obtain_pdbx_loop
                   to_pdbx );
use Grammar::SelectionParser;

#*nr-select
#*    select and mark atoms of interest by adding selection state [T|S|I] to
#*    _atom_site category in PDBx.
#*
#*USAGE:
#*    nr-select --input input.cif --target 'resname ASP' --select 'resid 1-10' \
#*              > output.cif
#*
#*OPTIONS:
#*    --input <file> | <stdin>
#*        PDBx file.
#*    --target  <str>
#*        command describing the residues that will be marked as target (T).
#*        Selection keywords (equivalent PDBx category data items in parentheses):
#*            all       - all atoms;
#*            atomid    - atom id number    (_atom_site.id);
#*            atomname  - atom name         (_atom_site.label_atom_id);
#*            atomtype  - atom symbol       (_atom_site.type_symbol);
#*            resid     - residue id number (_atom_site.label_seq_id);
#*            resname   - residue name      (_atom_site.label_comp_id);
#*            chain     - chain name        (_atom_site.label_asym_id);
#*            mainchain - mainchain atoms;
#*            sidechain - sidechain atoms;
#*            target    - target atoms (only for --select).
#*        Selection operators:
#*            around  - atoms around <int> angstroms;
#*            byresid - expands to residues.
#*        Logical operators:
#*            &  - and operator;
#*            |  - or operator;
#*            !  - negation operator;
#*            () - parentheses;
#*            ;  - group/order selection separator.
#*    --select <str> [default: target]
#*        command (same as --target) describing the atoms that will be marked as
#*        selected (S).
#*    --keep-ignored
#*        keeps ignored atoms.
#*    --version
#*        print version.

# --------------------------------- Options ----------------------------------- #

my %options;

my $version = "1.0.0";
my $keep_ignored = 0;

GetOptions(
    "input=s" => \$options{"pdbx_file"},
    "target=s" => \$options{"target_cl"},
    "select=s" => \$options{"select_cl"},
    "keep-ignored" => sub { $keep_ignored = 1 },
    "help" => sub { open( my $fh, "<", $0 );
		    while( <$fh> ) {
			my ( $help_message ) = $_ =~ m/^#(\*.*)/;
			$help_message =~ s/^\*$/ /g if $help_message;
			$help_message =~ s/^\*//g if $help_message;
			print( $help_message, "\n" ) if $help_message; }
		    close( $fh );
		    exit; },
    "version" => sub { print $version, "\n";
		       exit; } )
    or die "Error in command line argument.";

# Defaults.
$options{"select_cl"} //= "target";
$options{"select_cl"} = "all" if $options{"target_cl"} =~ m/^\s*all\s$/;
$options{"select_cl"} =~ s/(target)/$options{"target_cl"}/g;

# ----------------------------------- Main ------------------------------------ #

# Reads file path, stdin and "-" operator.
my $atom_site;
if( $options{"pdbx_file"} ) {
    $atom_site = obtain_atom_site( $options{"pdbx_file"} );
} elsif( ! defined $options{"pdbx_file"} && ! -t STDIN ) {
    $atom_site = obtain_atom_site( '-' );
} else {
    die( "Use command \"nr-select --help\" in order to see the manual.\n" );
}

# Parses command line arguments to select certain atoms in PDBx.
my $selection_parser = new SelectionParser();

my @target_cls = split( ";", $options{"target_cl"} );

my @target_atom_ids;
my $group_id = 1;
if( scalar( @target_cls ) > 1 ) {
    for my $target_cl ( @target_cls ) {
	push( @target_atom_ids,
	      @{ filter( { "atom_site" =>
			       $selection_parser->parser( $atom_site,
							  $target_cl,
							  "id" ),
			   "data" => [ "id" ],
			   "is_list" => 1,
			   "group_id" => $group_id } ) } );
	$group_id++;
    }
} else {
    @target_atom_ids =
	@{ filter( { "atom_site" =>
			 $selection_parser->parser( $atom_site,
						    $options{"target_cl"},
						    "id" ),
		     "data" => [ "id" ],
		     "is_list" => 1,
		     "group_id" => $group_id } ) };
}

my @selected_atom_ids =
    @{ filter( { "atom_site" => $selection_parser->parser( $atom_site,
							   $options{"select_cl"},
							   "id" ),
		 "data" => [ "id" ],
		 "is_list" => 1 } ) };

# Modifies PDBx entries by adding and/or changing selection states for atoms.
for my $atom_id ( keys %{ $atom_site } ) {
    if( any { $atom_id eq $_  } @target_atom_ids ) {
	$atom_site->{$atom_id}{"[local]_selection_state"} = "T";
    } elsif( any { $atom_id eq $_  } @selected_atom_ids ) {
	$atom_site->{$atom_id}{"[local]_selection_state"} = "S";
    } else {
	$atom_site->{$atom_id}{"[local]_selection_state"} = "I";
    }
}

if( ! $keep_ignored ) {
    $atom_site =
	filter( { "atom_site" => $atom_site,
		  "exclude" => { "[local]_selection_state" => [ "I" ] } } );
}

# Extracts rotamer angle data that will used to generate atom coordinates if
# available.
my $pdbx_loops;
if( $options{"pdbx_file"} ) {
    $pdbx_loops =
	obtain_pdbx_loop( $options{"pdbx_file"}, [ "_rotamer_angle" ] );
} elsif( ! defined $options{"pdbx_file"} && ! -t STDIN ) {
    $pdbx_loops =
	obtain_pdbx_loop( '-', [ "_rotamer_angle" ] );
}

# Prints out the PDBx.
to_pdbx( { "atom_site" => $atom_site,
	   $pdbx_loops ? ( "pdbx_loops", $pdbx_loops) : "",
	   "add_atom_attributes" => [ "[local]_selection_state",
				      "[local]_selection_group" ] } );

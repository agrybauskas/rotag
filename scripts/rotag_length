#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use File::Basename;
use Getopt::Long;
use List::MoreUtils qw( uniq );
use Try::Tiny;

use BondParameters qw( collect_bond_lengths
                       stretchable_bonds );
use ConnectAtoms qw( connect_atoms );
use ForceField::Parameters;
use Logging qw( error
                warning );
use Measure qw( bond_length );
use PDBxParser qw( filter
                   filter_by_unique_residue_key
                   mark_selection
                   obtain_pdbx_data
                   raw2indexed
                   split_by
                   to_csv
                   to_pdbx );
use Version qw( $VERSION );

Getopt::Long::Configure qw( gnu_getopt );

our $VERSION = $VERSION;

#*rotag_length [options] [--] <cif-file>...
#*    calculate distance between selected atoms or bonds in residues.
#*
#*Usage:
#*    rotag_length -S input.cif > output.cif
#*    rotag_length -c '1,2;3,4' > output.cif
#*
#*Options:
#*    -S, --side-chains
#*                        calculates bond lengths between the side-chain atoms.
#*    -M, --main-chains
#*                        calculates bond lengths between the main-chain atoms.
#*    -c, --compare <group>,<group>[;<group>,<group>;...]
#*                        calculates distances between selected groups of atoms.
#*                        If active, -S and -M options are ignored. Use
#*                        carefully, because it compares combinatorically.
#*
#*                        Example: --compare '1, 2' or --compare '3, 4; 5, 7'
#*    -F, --format <format>
#*                        output format (default: pdbx | csv).
#*    -v, --version
#*                        print version.

# --------------------------------- Options ----------------------------------- #

my $calc_sidechain = 0;
my $calc_mainchain = 0;
my $comparison = q{};
my $output_format = 'pdbx';

local $SIG{__WARN__} = sub {
    warning( { 'program' => $0,
               'message' => @_,
               'filename' => join( ', ', @ARGV ) } );
};

local $SIG{__DIE__} = sub {
    error( { 'program' => $0,
             'message' => @_,
             'filename' => join( ', ', @ARGV ) } );
};

GetOptions(
    'side-chains|S' => sub { $calc_sidechain = 1 },
    'main-chains|M' => sub { $calc_mainchain = 1 },
    'compare|c=s' => \$comparison,
    'format|F=s' => \$output_format,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {
                                $help_message =~ s/^\*$/ /smgx;
                                $help_message =~ s/^\*//smgx;
                                print $help_message, "\n";
                            }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or error( { 'program' => $0,
              'message' => "mistake in command line argument.\n" } );

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

$comparison =~ s/ //g;
my @comparison_groups = map { [ split /,/, $_ ] } ( split /;/, $comparison );

my $parameters = Parameters->new();
my $pi = $parameters->{'_[local]_constants'}{'pi'};
my $sig_figs_min = $parameters->{'_[local]_constants'}{'sig_figs_min'};
my $sig_figs_max = $parameters->{'_[local]_constants'}{'sig_figs_max'};

for my $pdbx_file ( @ARGV ) {
    my $pdbx = obtain_pdbx_data( $pdbx_file, [ '_atom_site' ] );
    raw2indexed( $pdbx, { 'attributes' => { '_atom_site' => [ 'id' ] } } );

    my $atom_site = $pdbx->{'_atom_site'}{'data'};

    if( ! defined $atom_site ) {
        warning( { 'program' => $0,
                   'message' => "no atom sites were detected.\n" } );
        next;
    }

    # Calculates distance between side-chain bonds.
    if( $comparison ) {
        $pdbx->{'_[local]_bond_length'}{'metadata'}{'attributes'} =
            [ 'id', 'group_1_id', 'atom_1_id', 'label_atom_1_id', 'label_seq_1_id',
              'label_comp_1_id', 'label_asym_1_id', 'pdbx_PDB_model_num_1',
              'label_alt_1_id', 'group_2_id', 'atom_2_id', 'label_atom_2_id',
              'label_seq_2_id', 'label_comp_2_id', 'label_asym_2_id',
              'pdbx_PDB_model_num_2', 'label_alt_2_id', 'type', 'value'];
        $pdbx->{'_[local]_bond_length'}{'metadata'}{'is_loop'} = 1;
        $pdbx->{'_[local]_bond_length'}{'metadata'}{'type'} = 'record';

        my %atom_site_groups = ();

        # Assigns filters atoms and assigns to specified groups.
        my @group_ids =
            uniq( @{ filter( { 'atom_site' => $atom_site,
                               'data' => [ '[local]_selection_group' ],
                               'is_list' => 1 } ) } );

        for my $group_id ( @group_ids ) {
            if( ! exists $atom_site_groups{$group_id} ) {
                my $group_atom_site =
                    filter( { 'atom_site' => $atom_site,
                              'include' =>
                                  { '[local]_selection_state' => [ 'T' ],
                                    '[local]_selection_group' => [$group_id] }});
                $atom_site_groups{$group_id} = $group_atom_site;
            } else {
                error( { 'program' => $0,
                         'message' => 'there are multiple instances of the group ' .
                                      "in different files.\n" } );
            }
        }

        exit if ! %atom_site_groups;

        for my $comparison_group ( @comparison_groups ) {
            if( scalar @{ $comparison_group } != 2 ) {
                error( { 'program' => $0,
                         'message' => 'there has to be two groups of atoms to ' .
                                      "be compared against.\n" } );
            }

            # Checks if these groups exist.
            for my $group ( @{ $comparison_group } ) {
                if( ! exists $atom_site_groups{$group} ) {
                    error( { 'program' => $0,
                             'message' =>
                                 "group $group is not present in pdbx.\n" } );
                }
            }

            # Generates the comparison pairs.
            my $first_atom_groups =
                split_by( { 'atom_site' =>
                                $atom_site_groups{$comparison_group->[0]},
                            'attributes' => [ 'label_seq_id', 'label_asym_id',
                                              'pdbx_PDB_model_num' ] } );
            my $second_atom_groups =
                split_by( { 'atom_site' =>
                                $atom_site_groups{$comparison_group->[1]},
                            'attributes' => [ 'label_seq_id', 'label_asym_id',
                                              'pdbx_PDB_model_num' ] } );

            my $bond_length_id = 1;
            for my $first_group_key ( sort keys %{ $first_atom_groups } ) {
                my $first_group_atom_ids =
                    $first_atom_groups->{$first_group_key};
                my $first_group_atom_site =
                    filter( { 'atom_site' =>
                                  $atom_site_groups{$comparison_group->[0]},
                              'include' => { 'id' => $first_group_atom_ids } } );

                for my $second_group_key ( sort keys %{ $second_atom_groups } ) {
                    my $second_group_atom_ids =
                        $second_atom_groups->{$second_group_key};
                    my $second_group_atom_site =
                        filter( { 'atom_site' =>
                                      $atom_site_groups{$comparison_group->[1]},
                                  'include' =>
                                      { 'id' => $second_group_atom_ids } } );

                    for my $first_group_atom_id ( @{ $first_group_atom_ids } ) {
                        for my $second_group_atom_id ( @{ $second_group_atom_ids } ) {
                            push @{ $pdbx->{'_[local]_bond_length'}{'data'} },
                                 { 'id' => $bond_length_id,
                                   'group_1_id' =>
                                       $first_group_atom_site->{$first_group_atom_id}
                                                               {'[local]_selection_group'},
                                   'atom_1_id' =>
                                       $first_group_atom_site->{$first_group_atom_id}
                                                               {'id'},
                                   'label_atom_1_id' =>
                                       $first_group_atom_site->{$first_group_atom_id}
                                                               {'label_atom_id'},
                                   'label_seq_1_id' =>
                                       $first_group_atom_site->{$first_group_atom_id}
                                                               {'label_seq_id'},
                                   'label_comp_1_id' =>
                                       $first_group_atom_site->{$first_group_atom_id}
                                                               {'label_comp_id'},
                                   'label_asym_1_id' =>
                                       $first_group_atom_site->{$first_group_atom_id}
                                                               {'label_asym_id'},
                                   'pdbx_PDB_model_num_1' =>
                                       $first_group_atom_site->{$first_group_atom_id}
                                                               {'pdbx_PDB_model_num'},
                                   'label_alt_1_id' =>
                                       $first_group_atom_site->{$first_group_atom_id}
                                                               {'label_alt_id'},
                                   'group_2_id' =>
                                       $second_group_atom_site->{$second_group_atom_id}
                                                               {'[local]_selection_group'},
                                   'atom_2_id' =>
                                       $second_group_atom_site->{$second_group_atom_id}
                                                                {'id'},
                                   'label_atom_2_id' =>
                                       $second_group_atom_site->{$second_group_atom_id}
                                                                {'label_atom_id'},
                                   'label_seq_2_id' =>
                                       $second_group_atom_site->{$second_group_atom_id}
                                                                {'label_seq_id'},
                                   'label_comp_2_id' =>
                                       $second_group_atom_site->{$second_group_atom_id}
                                                                {'label_comp_id'},
                                   'label_asym_2_id' =>
                                       $second_group_atom_site->{$second_group_atom_id}
                                                                {'label_asym_id'},
                                   'pdbx_PDB_model_num_2' =>
                                       $second_group_atom_site->{$second_group_atom_id}
                                                                {'pdbx_PDB_model_num'},
                                   'label_alt_2_id' =>
                                       $second_group_atom_site->{$second_group_atom_id}
                                                                {'label_alt_id'},
                                   'type' => '.',
                                   'value' =>
                                       sprintf $sig_figs_min,
                                       bond_length( [
                                           [ $first_group_atom_site->{$first_group_atom_id}
                                                                     {'Cartn_x'},
                                             $first_group_atom_site->{$first_group_atom_id}
                                                                     {'Cartn_y'},
                                             $first_group_atom_site->{$first_group_atom_id}
                                                                     {'Cartn_z'} ],
                                           [ $second_group_atom_site->{$second_group_atom_id}
                                                                      {'Cartn_x'},
                                             $second_group_atom_site->{$second_group_atom_id}
                                                                      {'Cartn_y'},
                                             $second_group_atom_site->{$second_group_atom_id}
                                                                      {'Cartn_z'} ]
                                       ] ) };
                            $bond_length_id++;
                        }
                    }
                }
            }
        }

    } elsif( $calc_sidechain ) {
        $pdbx->{'_[local]_bond_length'}{'metadata'}{'attributes'} =
            [ 'id', 'label_comp_id', 'label_seq_id', 'label_asym_id',
              'pdbx_PDB_model_num', 'label_alt_id', 'atom_1_id',
              'label_atom_1_id', 'atom_2_id', 'label_atom_2_id', 'type',
              'value' ];
        $pdbx->{'_[local]_bond_length'}{'metadata'}{'is_loop'} = 1;
        $pdbx->{'_[local]_bond_length'}{'metadata'}{'type'} = 'record';

        my $bond_length_site =
            filter( { 'atom_site' => $atom_site,
                      'include' => { '[local]_selection_state' => [ 'T' ] } } );

        # Selects all atoms if no specific atoms are selected.
        if( ! %{ $bond_length_site } ) {
            $bond_length_site = $atom_site;
            mark_selection( $bond_length_site,
                            { 'target' => [ keys %{ $bond_length_site } ] } );
        }

        connect_atoms( $parameters, $bond_length_site );

        stretchable_bonds( $parameters, $bond_length_site,
                           { 'include_mainchain' => $calc_mainchain } );
        my $bond_lengths = collect_bond_lengths( $bond_length_site );

        my $bond_length_id = 1;
        for my $residue_unique_key ( sort keys %{ $bond_lengths } ) {
            my $residue_site =
                filter_by_unique_residue_key( $bond_length_site,
                                              $residue_unique_key );
            my ( $residue_id ) = keys %{ $residue_site };
            my ( $label_seq_id, $chain_id, $model_id, $alt_id ) =
                split( /,/sxm, $residue_unique_key ),
            my $residue_name = $residue_site->{$residue_id}{'label_comp_id'};

            for my $bond_name (
                sort keys %{ $bond_lengths->{$residue_unique_key} } ) {
                my @atom_ids = @{ $bond_lengths->{$residue_unique_key}
                                                 {$bond_name}{'atom_ids'} };
                push @{ $pdbx->{'_[local]_bond_length'}{'data'} },
                    { 'id' => $bond_length_id,
                      'label_comp_id' => $residue_name,
                      'label_seq_id' => $label_seq_id,
                      'label_asym_id' => $chain_id,
                      'pdbx_PDB_model_num' => $model_id,
                      'label_alt_id' => $alt_id,
                      'atom_1_id' => $atom_ids[0],
                      'label_atom_1_id' =>
                          $bond_length_site->{$atom_ids[0]}{'label_atom_id'},
                      'atom_2_id' => $atom_ids[1],
                      'label_atom_2_id' =>
                          $bond_length_site->{$atom_ids[1]}{'label_atom_id'},
                      'type' => $bond_name,
                      'value' =>
                          sprintf $sig_figs_max,
                                  $bond_lengths->{$residue_unique_key}
                                                 {$bond_name}
                                                 {'value'} };
                $bond_length_id++;
            }
        }

    } else {
        $pdbx->{'_[local]_length'}{'metadata'}{'attributes'} =
            [ 'id', 'label_atom_1_id', 'atom_1_id', 'label_comp_1_id',
              'label_seq_1_id', 'label_asym_1_id', 'pdbx_PDB_model_num_1',
              'label_alt_1_id', 'label_atom_1_id', 'atom_2_id', 'label_comp_2_id',
              'label_seq_2_id', 'label_asym_2_id', 'pdbx_PDB_model_num_2',
              'value' ];
        $pdbx->{'_[local]_length'}{'metadata'}{'is_loop'} = 1;
        $pdbx->{'_[local]_length'}{'metadata'}{'type'} = 'record';

        my $length_site =
            filter( { 'atom_site' => $atom_site,
                      'include' => { '[local]_selection_state' => [ 'T' ] },
                      'exclude' => { '[local]_selection_group' => [ q{?} ] } } );

        if( ! %{ $length_site } ) {
            warning( { 'program' => $0,
                       'message' => 'no atoms were selected for calculating ' .
                                    "bond lengths.\n" } );
            next;
        }

        my @length_atom_ids =
            sort { $length_site->{"$a"}{'[local]_selection_group'} <=>
                   $length_site->{"$b"}{'[local]_selection_group'} ||
                   $length_site->{"$a"}{'id'} <=>
                   $length_site->{"$b"}{'id'}  }
            keys %{ $length_site };

        my $length_id = 1;
        my %visited_comparisons = ();
        for( my $i = 0; $i <= $#length_atom_ids; $i++ ) {
            for( my $j = 0; $j <= $#length_atom_ids; $j++ ) {
                my $first_atom_id = $length_atom_ids[$i];
                my $second_atom_id = $length_atom_ids[$j];

                next if $first_atom_id eq $second_atom_id;
                next if defined $visited_comparisons{$first_atom_id}{$second_atom_id};

                $visited_comparisons{$first_atom_id}{$second_atom_id} = 1;
                $visited_comparisons{$second_atom_id}{$first_atom_id} = 1;

                my $length =
                    bond_length(
                        [ map { [ $length_site->{$_}{'Cartn_x'},
                                  $length_site->{$_}{'Cartn_y'},
                                  $length_site->{$_}{'Cartn_z'} ] }
                          ( $first_atom_id, $second_atom_id ) ] );

                push @{ $pdbx->{'_[local]_length'}{'data'} },
                      { 'id' => $length_id,
                        'label_atom_1_id' => $first_atom_id,
                        'atom_1_id' =>
                            $length_site->{$first_atom_id}{'label_atom_id'},
                        'label_comp_1_id' =>
                            $length_site->{$first_atom_id}{'label_comp_id'},
                        'label_seq_1_id' =>
                            $length_site->{$first_atom_id}{'label_seq_id'},
                        'label_asym_1_id' =>
                            $length_site->{$first_atom_id}{'label_asym_id'},
                        'pdbx_PDB_model_num_1' =>
                            $length_site->{$first_atom_id}{'pdbx_PDB_model_num'},
                        'label_atom_2_id' => $second_atom_id,
                        'atom_2_id' =>
                            $length_site->{$second_atom_id}{'label_atom_id'},
                        'label_comp_2_id' =>
                            $length_site->{$second_atom_id}{'label_comp_id'},
                        'label_seq_2_id' =>
                            $length_site->{$second_atom_id}{'label_seq_id'},
                        'label_asym_2_id' =>
                            $length_site->{$second_atom_id}{'label_asym_id'},
                        'pdbx_PDB_model_num_2' =>
                            $length_site->{$second_atom_id}{'pdbx_PDB_model_num'},
                        'value' =>
                            sprintf $sig_figs_max, $length };

                $length_id++;
            }
        }
    }

    if( $output_format eq 'pdbx' ) {
        to_pdbx( $pdbx, { 'tags' => [ '_[local]_bond_length',
                                      '_[local]_length' ] } );
    } elsif( $output_format eq 'csv' ) {
        if( $comparison || $calc_sidechain ) {
            to_csv( $pdbx, { 'category' => '_[local]_bond_length' } );
        } else {
            to_csv( $pdbx, { 'category' => '_[local]_length' } );
        }
    } else {
        error(
            { 'program' => $0,
              'message' => "output format '${output_format}'" .
                           " is not supported.\n" } );
    }
}

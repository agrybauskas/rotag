#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Getopt::Long;
Getopt::Long::Configure qw( gnu_getopt );
use List::MoreUtils qw( uniq );
use List::Util qw( any );

use PDBxParser qw( filter
                   mark_selection
                   obtain_atom_site
                   obtain_pdbx_loop
                   to_pdbx );
use Grammar::SelectionParser;
use Version qw( $VERSION );

our $VERSION = $VERSION;

#*rotag_select [options] file1 [file2, ...]
#*    select and mark atoms of interest by adding selection state [T|S|I] to
#*    _atom_site category in PDBx.
#*
#*USAGE:
#*    rotag_select -t 'resname ASP' -s 'resid 1-10' input.cif > output.cif
#*
#*OPTIONS:
#*    -t, --target  <str>
#*        command describing the residues that will be marked as target (T).
#*        Selection keywords (equivalent PDBx category data items in parentheses):
#*            all       - all atoms;
#*            atomid    - atom id number    (_atom_site.id);
#*            atomname  - atom name         (_atom_site.label_atom_id);
#*            atomtype  - atom symbol       (_atom_site.type_symbol);
#*            resid     - residue id number (_atom_site.label_seq_id);
#*            resname   - residue name      (_atom_site.label_comp_id);
#*            chain     - chain name        (_atom_site.label_asym_id);
#*            mainchain - mainchain atoms;
#*            sidechain - sidechain atoms;
#*            target    - target atoms (only for --select).
#*        Selection operators:
#*            around  - atoms around <int> angstroms;
#*            byresid - expands to residues;
#*            rand    - selects <int> number of atoms randomly.
#*        Logical operators:
#*            &  - and operator;
#*            |  - or operator;
#*            !  - negation operator;
#*            () - parentheses;
#*            ;  - group/order selection separator.
#*    -s, --select <str> (default: target)
#*        command (same as --target) describing the atoms that will be marked as
#*        selected (S).
#*    -k, --keep-ignored
#*        keeps ignored atoms.
#*    -x, --rand-seed <int>
#*        sets a seed for random (rand) selection.
#*    -v, --version
#*        print version.

# --------------------------------- Options ----------------------------------- #

my $target_cmd;
my $select_cmd;
my $keep_ignored = 0;
my $random_seed = 23;

GetOptions(
    'target|t=s' => \$target_cmd,
    'select|s=s' => \$select_cmd,
    'keep-ignored|k' => sub { $keep_ignored = 1 },
    'random-seed|x=s' => \$random_seed,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'Error in command line argument.';

$target_cmd //= 'all';
$select_cmd //= $target_cmd;
$select_cmd =~ s/(target)/$target_cmd/smgx;

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    if( $pdbx_file ) {
        $atom_site = obtain_atom_site( $pdbx_file );
    } else {
        die "Use command \"rotag_select --help\" in order to see the manual.\n";
    }

    # Parses command line arguments to select certain atoms in PDBx.
    my $group_id = 1;
    my $selection_parser = SelectionParser->new();
    my @target_atom_ids;
    my @target_cmds = split /;/smx, $target_cmd;

    if( scalar @target_cmds > 1 ) {
        for my $target_cmd ( @target_cmds ) {
            push @target_atom_ids,
                 @{ filter( { 'atom_site' =>
                                  $selection_parser->parser(
                                      $atom_site,
                                      $target_cmd,
                                      'id',
                                      { 'seed' => $random_seed }
                                  ),
                              'data' => [ 'id' ],
                              'is_list' => 1,
                              'group_id' => $group_id } ) };
            $group_id++;
        }
    } else {
        @target_atom_ids =
            @{ filter( { 'atom_site' =>
                             $selection_parser->parser(
                                 $atom_site,
                                 $target_cmd,
                                 'id',
                                 { 'seed' => $random_seed }
                             ),
                             'data' => [ 'id' ],
                             'is_list' => 1,
                             'group_id' => $group_id } ) };
    }

    my @selected_atom_ids =
        @{ filter( { 'atom_site' =>
                         $selection_parser->parser(
                             $atom_site,
                             $select_cmd,
                             'id',
                             { 'seed' => $random_seed }
                         ),
                     'data' => [ 'id' ],
                     'is_list' => 1 } ) };

    # Modifies PDBx entries by adding and/or changing selection states for atoms.
    mark_selection( $atom_site,
                    { 'target' => \@target_atom_ids,
                      'select' => \@selected_atom_ids } );

    if( ! $keep_ignored ) {
        $atom_site =
            filter( { 'atom_site' => $atom_site,
                      'exclude' => { '[local]_selection_state' => [ 'I' ] } } );
    }

    # Extracts rotamer angle data that will used to generate atom coordinates if
    # available.
    my $pdbx_loops;
    if( $pdbx_file ) {
        $pdbx_loops = obtain_pdbx_loop( $pdbx_file,
                                        [ '_\[local\]_rotamer_angle' ] );
    }

    # Prints out the PDBx.
    to_pdbx( { 'atom_site' => $atom_site,
               $pdbx_loops ? ( 'pdbx_loops', $pdbx_loops ) : (),
               'add_atom_attributes' => [ '[local]_selection_state',
                                          '[local]_selection_group' ] } );
}

#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Getopt::Long;
Getopt::Long::Configure qw( gnu_getopt );

use AtomSite;
use PDBxParser qw( obtain_pdbx_loop
                   to_pdbx );
use Grammar::SelectionParser;
use ErrorHandling qw( parse_errors );
use Version qw( $VERSION );

our $VERSION = $VERSION;

#*rotag_select [options] <file>...
#*    select and mark atoms of interest by adding selection state [T|S|I] to
#*    _atom_site category in PDBx.
#*
#*Usage:
#*    rotag_select -t 'resname ASP' -s 'resid 1-10' input.cif > output.cif
#*
#*Options:
#*    -t, --target <str>    command describing the residues that will be marked
#*                          as target (T) [default: all].
#*
#*                          Selection keywords (equivalent PDBx category data
#*                          items in parentheses):
#*                              all       - all atoms;
#*                              atomid    - atom id number;
#*                              atomname  - atom name;
#*                              atomtype  - atom symbol;
#*                              resid     - residue id number;
#*                              resname   - residue name;
#*                              chain     - chain name;
#*                              altid     - alt atom id;
#*                              model     - pdbx model num;
#*                              mainchain - mainchain atoms;
#*                              sidechain - sidechain atoms;
#*                              target    - target atoms (--select uses
#*                                          --target atoms and --target uses
#*                                          target atoms described in a file).
#*
#*                          Selection operators:
#*                              around - atoms around <int> angstroms;
#*                              byres  - expands to residues;
#*                              rand   - selects <int> number of atoms randomly.
#*
#*                          List operators:
#*                              - - range of integers (e.g. 2-5 is 2,3,4,5);
#*                              , - list of integers or keywords (e.g. 2,3 or
#*                                  A,B).
#*
#*                          Logical operators:
#*                              && - and operator;
#*                              || - or operator;
#*                              !  - negation operator;
#*                              () - parentheses;
#*                              ;  - group/order selection separator.
#*
#*    -s, --select <str>    command (same as --target) describing the atoms that
#*                          will be marked as selected (S) [default: target].
#*
#*    -k, --keep-ignored    keeps ignored atoms.
#*
#*    -x, --rand-seed <int> sets a seed for random (rand) selection.
#*
#*    -v, --version         print version.

# --------------------------------- Options ----------------------------------- #

my $target_cmd;
my $select_cmd;
my $keep_ignored = 0;
my $random_seed = 23;

GetOptions(
    'target|t=s' => \$target_cmd,
    'select|s=s' => \$select_cmd,
    'keep-ignored|k' => sub { $keep_ignored = 1 },
    'random-seed|x=s' => \$random_seed,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'Error in command line argument.';

$target_cmd //= 'all';

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    if( $pdbx_file ) {
        $atom_site = AtomSite->new();
        $atom_site->open( $pdbx_file );
    } else {
        die "Use command \"rotag_select --help\" in order to see the manual.\n";
    }

    # Parses command line arguments to select certain atoms in PDBx.
    my $selection_parser = SelectionParser->new();
    my @target_cmds = split /;/smx, $target_cmd;

    # Replaces 'target' keyword with previously selected target ids.
    if( $target_cmd =~ m/target/ ) {
        my @previous_target_atoms;
        for my $atom_id ( keys %{ $atom_site->{'_atoms'} } ) {
            if( exists $atom_site->{'_atoms'}{"$atom_id"}{'[local]_selection_state'} &&
                $atom_site->{'_atoms'}{"$atom_id"}{'[local]_selection_state'} eq 'T' ) {
                push @previous_target_atoms, $atom_id;
            }
        }

        if( @previous_target_atoms ) {
            my $previous_target_cmd =
                'atomid ' . join ',', @previous_target_atoms;
            $target_cmd =~ s/target/${previous_target_cmd}/g;
        } else {
            parse_errors( { 'program' => $0,
                            'filename' => $pdbx_file,
                            'type' => 'ERROR',
                            'message' => 'no target atoms where previously ' .
                                         "selected.\n" } );
        }
    }

    # By default, target atoms are used for surrounding atom selection.
    $select_cmd //= $target_cmd;
    $select_cmd =~ s/(target)/$target_cmd/smgx;

    my @target_atom_ids;
    my $group_id = 1;

    for my $target_cmd ( @target_cmds ) {
        push @target_atom_ids,
            @{ $selection_parser->
                   parser( $atom_site,
                           $target_cmd,
                           'id',
                           { 'seed' => $random_seed,
                             'group_id' => $group_id } ) };
        $group_id++;
    }

    my @selected_atom_ids =
        @{ $selection_parser->
               parser( $atom_site,
                       $select_cmd,
                       'id',
                       { 'seed' => $random_seed } ) };

    mark_selection( $atom_site, { 'target' => \@target_atom_ids,
                                  'select' => \@selected_atom_ids } );

    if( ! $keep_ignored ) {
        $atom_site =
            filter( $atom_site,
                    { 'exclude' => { '[local]_selection_state' => [ 'I' ] } } );
    }

    # Extracts rotamer angle data that will used to generate atom coordinates if
    # available.
    my $pdbx_loops;
    if( $pdbx_file ) {
        $pdbx_loops = obtain_pdbx_loop( $pdbx_file,
                                        [ '_\[local\]_rotamer_angle' ] );
    }

    # Prints out the PDBx.
    to_pdbx( { 'atom_site' => $atom_site->{'_atoms'},
               $pdbx_loops ? ( 'pdbx_loops', $pdbx_loops ) : (),
               'add_atom_attributes' => [ '[local]_selection_state',
                                          '[local]_selection_group' ] } );
}

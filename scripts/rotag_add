#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use ErrorHandling qw( parse_errors );
use File::Basename;
use Getopt::Long;
Getopt::Long::Configure qw( gnu_getopt );
use List::Util qw( max );
use List::MoreUtils qw( any );

use AtomProperties qw( @MAINCHAIN_NAMES );
use PDBxParser qw( filter
                   filter_by_unique_residue_key
                   mark_selection
                   obtain_atom_site
                   obtain_pdbx_loop
                   pdbx_loop_unique
                   split_by
                   to_pdbx
                   unique_residue_key );
use PseudoAtoms qw( add_hydrogens
                    generate_pseudo );
use SidechainModels qw( rotation_only  );
use Version qw( $VERSION );

our $VERSION = $VERSION;

#*rotag_add [options] file1 [file2, ...]
#*    adds pseudo atoms.
#*
#*USAGE:
#*    rotag_add -r input.cif > output.cif
#*
#*OPTIONS:
#*    -r, --rotamer-atoms
#*        adds pseudo atoms of defined rotamers. Input .cif has to contain
#*        _[local]_rotamer_angle category (can be produced with rotag_library).
#*    -H, --hydrogens
#*        adds hydrogen atoms to selected atoms.
#*    -v, --version
#*        print version.

# --------------------------------- Options ----------------------------------- #

my $add_rotamer_atoms = 0;
my $add_hydrogens = 0;
my @attribute_list =
    ( 'label_seq_id', 'label_comp_id', 'label_entity_id', 'label_alt_id',
      'rotamer_id', 'type', 'value', );

GetOptions(
    'rotamer-atoms|r' => sub { $add_rotamer_atoms = 1 },
    'hydrogens|H' => sub { $add_hydrogens = 1 },
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'ERROR: ' . basename( $0 ) . ": mistake in command line argument.\n";

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    if( $pdbx_file ) {
        $atom_site = obtain_atom_site( $pdbx_file );
    } else {
        die "Use command \"rotag_add --help\" in order to see the manual.\n";
    }

    my $selected_atom_site =
        filter( { 'atom_site' => $atom_site,
                  'include' => { '[local]_selection_state' => [ 'T', 'S' ] } } );

    my $target_atom_ids =
        filter( { 'atom_site' => $selected_atom_site,
                  'include' => { '[local]_selection_state' => [ 'T' ] },
                  'exclude' => { 'label_atom_id' => \@MAINCHAIN_NAMES },
                  'data' => [ 'id' ],
                  'is_list' => 1 } );

    if( $add_rotamer_atoms ) {
        # Extracts rotamer angle data that will used to generate atom
        # coordinates.
        my $pdbx_loops =
            obtain_pdbx_loop( $pdbx_file, [ '_\[local\]_rotamer_angle' ] );
        if( ! %{ $pdbx_loops } ) {
            parse_errors(
                { 'program' => $0,
                  'filename' => $pdbx_file,
                  'message' => 'no rotamer library was detected. Generate '.
                               "library with 'rotag_library' script.\n" } );
        }

        # Generates data structure from $pdbx_loops.
        my $pdbx_loop_unique = pdbx_loop_unique( $pdbx_loops, [ 'id' ] );
        my $pdbx_loop_split_groups =
            # TODO: 'atom_site' should be changed to 'loop_site' in the future.
            split_by( { 'atom_site' => $pdbx_loop_unique } );

        my %rotamer_angles;
        for my $residue_unique_key ( sort keys %{ $pdbx_loop_split_groups } ) {
            my $residue_site =
                filter_by_unique_residue_key( $selected_atom_site,
                                              $residue_unique_key, 1 );

            # Generates rotational model.
            rotation_only( $residue_site );

            for my $id ( sort { $a <=> $b }
                             @{$pdbx_loop_split_groups->{$residue_unique_key} }){
                my $rotamer_id = $pdbx_loop_unique->{$id}{'rotamer_id'};
                my $angle_name = $pdbx_loop_unique->{$id}{'type'};
                my $angle_value = $pdbx_loop_unique->{$id}{'value'};
                $rotamer_angles{$residue_unique_key}
                               {"$rotamer_id"}
                               {$angle_name} = [ $angle_value ];
            }
        }

        my %rotamer_atom_site;
        my $last_atom_id = max( keys %{ $atom_site } );
        for my $atom_id ( @{ $target_atom_ids } ) {
            my $residue_unique_key =
                unique_residue_key( $selected_atom_site->{$atom_id} );
            for my $rotamer_id ( sort keys %{ $rotamer_angles{$residue_unique_key} } ){
                my $rotamer_angles =
                    $rotamer_angles{$residue_unique_key}{$rotamer_id};
                %rotamer_atom_site =
                    ( %rotamer_atom_site,
                      %{ generate_pseudo(
                             { 'atom_site' => $selected_atom_site,
                               'atom_specifier' => { 'id' => [ $atom_id ] },
                               'angle_values' => $rotamer_angles,
                               'last_atom_id' => $last_atom_id,
                                # TODO: check if it is a good idea to have
                                # $rotamer_id as 'label_alt_id'.
                               'alt_group_id' => $rotamer_id } ) } );
                $last_atom_id++;
            }
        }

        # Prints out cif.
        to_pdbx( { 'atom_site' => { %{ $atom_site }, %rotamer_atom_site },
                   'add_atom_attributes' => [ '[local]_selection_state' ] } );
    } elsif( $add_hydrogens ) {
        # Selects all atoms if no specific atoms are selected.
        if( ! %{ $selected_atom_site } ) {
            $selected_atom_site = $atom_site;
            mark_selection( $selected_atom_site,
                            { 'target' => [ keys %{ $selected_atom_site } ] } );
        }

        my $atom_site_split_groups =
            split_by({ 'atom_site' => $selected_atom_site, 'append_dot' => 1 });

        my %atom_site;
        my $last_atom_id = max( keys %{ $selected_atom_site } );
        my @visited_atom_ids;
        for my $residue_unique_key ( sort keys %{ $atom_site_split_groups } ) {
            my $residue_site =
                filter_by_unique_residue_key( $selected_atom_site,
                                              $residue_unique_key, 1 );
            my $hydrogen_site =
                add_hydrogens( $residue_site ,
                               { 'last_atom_id' => $last_atom_id,
                                 'use_origins_alt_group_id' => 1,
                                 'exclude_by_atom_ids' => \@visited_atom_ids } );
            %atom_site = ( %atom_site, %{ $hydrogen_site } );

            push @visited_atom_ids, keys %{ $residue_site };

            $last_atom_id = max( keys %{ $hydrogen_site } );
        }

        # Prints out cif.
        to_pdbx( { 'atom_site' => { %{ $selected_atom_site }, %atom_site },
                   'add_atom_attributes' => [ '[local]_selection_state' ] } );
    } else {
        parse_errors(
            { 'program' => $0,
              'filename' => $pdbx_file,
              'message' => "no options were chosen for atom additions.\n" } );
    }
}

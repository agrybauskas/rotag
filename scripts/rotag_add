#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use ErrorHandling qw( parse_errors );
use File::Basename;
use Getopt::Long;
Getopt::Long::Configure qw( gnu_getopt );
use List::Util qw( max );
use List::MoreUtils qw( any );

use AtomProperties qw( @MAINCHAIN_NAMES );
use PDBxParser qw( filter
                   mark_selection
                   obtain_atom_site
                   obtain_pdbx_loop
                   to_pdbx );
use PseudoAtoms qw( add_hydrogens
                    generate_pseudo );
use SidechainModels qw( rotation_only  );
use Version qw( $VERSION );

our $VERSION = $VERSION;

#*rotag_add [options] file1 [file2, ...]
#*    adds pseudo atoms.
#*
#*USAGE:
#*    rotag_add -r input.cif > output.cif
#*
#*OPTIONS:
#*    -r, --rotamer-atoms
#*        adds pseudo atoms of defined rotamers. Input .cif has to contain
#*        _[local]_rotamer_angle category (can be produced with rotag_library).
#*    -H, --hydrogens
#*        adds hydrogen atoms to selected atoms.
#*    -v, --version
#*        print version.

# --------------------------------- Options ----------------------------------- #

my $add_rotamer_atoms = 0;
my $add_hydrogens = 0;
my @attribute_list =
    ( 'label_seq_id', 'label_comp_id', 'label_entity_id', 'label_alt_id',
      'rotamer_id', 'type', 'value', );

GetOptions(
    'rotamer-atoms|r' => sub { $add_rotamer_atoms = 1 },
    'hydrogens|H' => sub { $add_hydrogens = 1 },
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'ERROR: ' . basename( $0 ) . ": mistake in command line argument.\n";

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    if( $pdbx_file ) {
        $atom_site = obtain_atom_site( $pdbx_file );
    } else {
        die "Use command \"rotag_add --help\" in order to see the manual.\n";
    }

    my $selected_atom_site =
        filter( { 'atom_site' => $atom_site,
                  'include' => { '[local]_selection_state' => [ 'T', 'S' ] } } );

    my $target_atom_ids =
        filter( { 'atom_site' => $selected_atom_site,
                  'include' => { '[local]_selection_state' => [ 'T' ] },
                  'exclude' => { 'label_atom_id' => \@MAINCHAIN_NAMES },
                  'data' => [ 'id' ],
                  'is_list' => 1 } );

    if( $add_rotamer_atoms ) {
        # Extracts rotamer angle data that will used to generate atom
        # coordinates.
        my $pdbx_loops =
            obtain_pdbx_loop( $pdbx_file, [ '_\[local\]_rotamer_angle' ] );
        if( ! %{ $pdbx_loops } ) {
            parse_errors(
                { 'program' => $0,
                  'filename' => $pdbx_file,
                  'message' => 'no library was detected. Generate library with '.
                               "'rotag_library' script.\n" } );
        }

        # Generates data structure from $pdbx_loops.
        # TODO: maybe generate general data structure that can be created through
        # unique id.
        my $current_attributes =
            $pdbx_loops->{'_[local]_rotamer_angle'}{'attributes'};
        my $data = $pdbx_loops->{'_[local]_rotamer_angle'}{'data'};

        my %attribute_pos;
        for( my $i = 0; $i <= $#{ $current_attributes }; $i++ ) {
            if( any { $current_attributes->[$i] eq $_ } @attribute_list ) {
                $attribute_pos{$current_attributes->[$i]} = $i;
            }
        }

        my %rotamer_angles;
        for(my $i = 0; $i <= $#{ $data }; $i = $i + $#{ $current_attributes }+1){
            my $residue_unique_key =
                join q{,},
                     ( $data->[$i+$attribute_pos{'label_seq_id'}],
                       $data->[$i+$attribute_pos{'label_comp_id'}],
                       $data->[$i+$attribute_pos{'label_entity_id'}],
                       $data->[$i+$attribute_pos{'label_alt_id'}] );
            $rotamer_angles{$residue_unique_key}
                           {$data->[$i+$attribute_pos{'rotamer_id'}]}
                           {$data->[$i+$attribute_pos{'type'}]} =
                [ $data->[$i+$attribute_pos{'value'}] ];
        }

        rotation_only( $selected_atom_site ); # Generates rotational model.

        my $last_atom_id = max( keys %{ $atom_site } );
        my %rotamer_atom_site;
        for my $atom_id ( @{ $target_atom_ids } ) {
            my $residue_unique_key =
                join q{,}, ( $selected_atom_site->{$atom_id}{'label_seq_id'},
                             $selected_atom_site->{$atom_id}{'label_comp_id'},
                             $selected_atom_site->{$atom_id}{'label_entity_id'},
                             $selected_atom_site->{$atom_id}{'label_alt_id'} );
            my $alt_group_id = 1;
            for my $rotamer_id ( sort keys %{ $rotamer_angles
                                                  {$residue_unique_key} } ){
                my $rotamer_angles =
                    $rotamer_angles{$residue_unique_key}{$rotamer_id};
                %rotamer_atom_site =
                  ( %rotamer_atom_site,
                      %{ generate_pseudo( $selected_atom_site,
                                          { 'id' => [ $atom_id ] },
                                          $rotamer_angles,
                                          $last_atom_id,
                                          $alt_group_id ) } );
                $last_atom_id++;
                $alt_group_id++;
            }
        }

        # Prints out cif.
        to_pdbx( { 'atom_site' => { %{ $atom_site }, %rotamer_atom_site },
                   'add_atom_attributes' => [ '[local]_selection_state' ],
                   'pdbx_loops' => $pdbx_loops } );
    } elsif( $add_hydrogens ) {
        # Selects all atoms if no specific atoms are selected.
        if( ! %{ $selected_atom_site } ) {
            $selected_atom_site = $atom_site;
            mark_selection( $selected_atom_site,
                            { 'target' => [ keys %{ $selected_atom_site } ] } );
        }

        # Prints out cif.
        to_pdbx( { 'atom_site' =>
                   { %{ $selected_atom_site },
                     %{ add_hydrogens( $selected_atom_site,
                                       { 'use_origins_alt_group_id' => 1 } ) } },
                   'add_atom_attributes' => [ '[local]_selection_state' ] } );
    } else {
        parse_errors(
            { 'program' => $0,
              'filename' => $pdbx_file,
              'message' => "no options were chosen for atom additions.\n" } );
    }
}

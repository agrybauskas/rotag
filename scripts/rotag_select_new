#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Getopt::Long;
Getopt::Long::Configure qw( gnu_getopt );
use List::MoreUtils qw( uniq );
use List::Util qw( any );

use AtomSite;
use PDBxParser qw( obtain_atom_site
                   obtain_pdbx_loop
                   to_pdbx );
use Grammar::SelectionParser_new;
use ErrorHandling qw( parse_errors );
use Version qw( $VERSION );

our $VERSION = $VERSION;

#*rotag_select [options] file1 [file2, ...]
#*    select and mark atoms of interest by adding selection state [T|S|I] to
#*    _atom_site category in PDBx.
#*
#*USAGE:
#*    rotag_select -t 'resname ASP' -s 'resid 1-10' input.cif > output.cif
#*
#*OPTIONS:
#*    -t, --target  <str>
#*        command describing the residues that will be marked as target (T).
#*        Selection keywords (equivalent PDBx category data items in parentheses):
#*            all       - all atoms;
#*            atomid    - atom id number    (_atom_site.id);
#*            atomname  - atom name         (_atom_site.label_atom_id);
#*            atomtype  - atom symbol       (_atom_site.type_symbol);
#*            resid     - residue id number (_atom_site.label_seq_id);
#*            resname   - residue name      (_atom_site.label_comp_id);
#*            chain     - chain name        (_atom_site.label_asym_id);
#*            altid     - alt atom id       (_atom_site.label_alt_id);
#*            model     - pdbx model num    (_atom_site.pdbx_PDB_model_num);
#*            mainchain - mainchain atoms;
#*            sidechain - sidechain atoms;
#*            target    - target atoms (--select uses --target atoms and --target
#*                        uses target atoms described in a file).
#*        Selection operators:
#*            around  - atoms around <int> angstroms;
#*            byres   - expands to residues;
#*            rand    - selects <int> number of atoms randomly.
#*        Logical operators:
#*            &  - and operator;
#*            |  - or operator;
#*            !  - negation operator;
#*            () - parentheses;
#*            ;  - group/order selection separator.
#*    -s, --select <str> (default: target)
#*        command (same as --target) describing the atoms that will be marked as
#*        selected (S).
#*    -k, --keep-ignored
#*        keeps ignored atoms.
#*    -x, --rand-seed <int>
#*        sets a seed for random (rand) selection.
#*    -v, --version
#*        print version.

# --------------------------------- Options ----------------------------------- #

my $target_cmd;
my $select_cmd;
my $keep_ignored = 0;
my $random_seed = 23;

GetOptions(
    'target|t=s' => \$target_cmd,
    'select|s=s' => \$select_cmd,
    'keep-ignored|k' => sub { $keep_ignored = 1 },
    'random-seed|x=s' => \$random_seed,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'Error in command line argument.';

$target_cmd //= 'all';

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    if( $pdbx_file ) {
        $atom_site = AtomSite->new();
        $atom_site->open( $pdbx_file );
    } else {
        die "Use command \"rotag_select --help\" in order to see the manual.\n";
    }

    # Parses command line arguments to select certain atoms in PDBx.
    my $selection_parser = SelectionParser_new->new();
    my @target_atom_ids;
    my @target_cmds = split /;/smx, $target_cmd;

    # Replaces 'target' keyword with previously selected target ids.
    if( $target_cmd =~ m/target/ ) {
        my @previous_target_atoms;
        for my $atom_id ( keys %{ $atom_site } ) {
            if( exists $atom_site->{"$atom_id"}{'[local]_selection_state'} &&
                $atom_site->{"$atom_id"}{'[local]_selection_state'} eq 'T' ) {
                push @previous_target_atoms, $atom_id;
            }
        }

        if( @previous_target_atoms ) {
            my $previous_target_cmd =
                'atomid ' . join ',', @previous_target_atoms;
            $target_cmd =~ s/target/${previous_target_cmd}/g;
        } else {
            parse_errors( { 'program' => $0,
                            'filename' => $pdbx_file,
                            'type' => 'ERROR',
                            'message' => 'no target atoms where previously ' .
                                         "selected.\n" } );
        }
    }

    # By default, target atoms are used for surrounding atom selection.
    $select_cmd //= $target_cmd;
    $select_cmd =~ s/(target)/$target_cmd/smgx;

    if( scalar @target_cmds > 1 ) {
        my $group_id = 1;
        for my $target_cmd ( @target_cmds ) {
            @target_atom_ids =
                keys %{ $selection_parser->
                            parser( $atom_site,
                                    $target_cmd,
                                    'id',
                                    { 'seed' => $random_seed } )->{'_atoms'} };

            # Marks group ids by introducing _atom_site.[local]_selection_group.
            foreach( @target_atom_ids ) {
                $atom_site->{'_atoms'}{$_}{'[local]_selection_group'}= $group_id;
            }

            $group_id++;
        }
    } else {
        @target_atom_ids =
            keys %{ $selection_parser->
                        parser( $atom_site,
                                $target_cmd,
                                'id',
                                { 'seed' => $random_seed } )->{'_atoms'} };
    }

    my @selected_atom_ids =
        keys %{ $selection_parser->
                    parser( $atom_site,
                            $select_cmd,
                            'id',
                            { 'seed' => $random_seed } )->{'_atoms'} };

    # Modifies PDBx entries by adding and/or changing selection states for atoms.
    mark_selection( $atom_site,
                    { 'target' => \@target_atom_ids,
                      'select' => \@selected_atom_ids } );

    if( ! $keep_ignored ) {
        $atom_site =
            filter( $atom_site,
                    { 'exclude' => { '[local]_selection_state' => [ 'I' ] } } );
    }

    # Extracts rotamer angle data that will used to generate atom coordinates if
    # available.
    my $pdbx_loops;
    if( $pdbx_file ) {
        $pdbx_loops = obtain_pdbx_loop( $pdbx_file,
                                        [ '_\[local\]_rotamer_angle' ] );
    }

    # Prints out the PDBx.
    to_pdbx( { 'atom_site' => $atom_site->{'_atoms'},
               $pdbx_loops ? ( 'pdbx_loops', $pdbx_loops ) : (),
               'add_atom_attributes' => [ '[local]_selection_state',
                                          '[local]_selection_group' ] } );
}

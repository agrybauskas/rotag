#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use ErrorHandling qw( parse_errors );
use Getopt::Long;
use List::MoreUtils qw( uniq );
Getopt::Long::Configure qw( gnu_getopt );

use Moieties qw( %SIDECHAINS
                 replace_with_moiety );
use PDBxParser qw( filter
                   obtain_atom_site
                   to_pdbx
                   unique_residue_key );
use Version qw( $VERSION );

our $VERSION = $VERSION;

#*rotag_mutate [options] file1 [file2, ...]
#*    replace side-chain with specified moiety. Groups are needed to be specified
#*    with rotag_select.
#*
#*USAGE:
#*    rotag_mutate -m 'Arg' input.cif > output.cif
#*    rotag_mutate -m 'Ala; Lys' input.cif > output.cif
#*    rotag_mutate -m 'ASP' -a 'chi1=120, chi2=60' input.cif > output.cif
#*    rotag_mutate -m 'ASP' -a 'chi1=0.12, chi2=3.10' -r input.cif > output.cif
#*    rotag_mutate -m 'ALA; SER' -a '_; chi1=134.0' input.cif > output.cif
#*
#*OPTIONS:
#*    -m, --mutate <str>
#*        replaces selected side-chain with specified moiety.
#*    -a, --angles <str>
#*        replaces selected side-chain by rotating selected moiety at certain
#*        angle.
#*    -r, --radians
#*        radians are used in --angles argument.
#*    -R, --repeat
#*        repeats pattern of selected mutations.
#*    -v, --version
#*        print version.

# --------------------------------- Options ----------------------------------- #

my $mutations = '';
my $angles = '';
my $in_degrees = 1;
my $do_repeat = 0;

GetOptions(
    'mutate|m=s' => \$mutations,
    'angles|a=s' => \$angles,
    'radians|r=s' => sub { $in_degrees = 0; },
    'repeat|R' => sub { $do_repeat = 1; },
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'Error in command line argument.';

my @mutations;
my @angles;
$mutations =~ s/\s//smxg;
$angles =~ s/\s//smxg;
@mutations = split q{;}, $mutations;
@angles = split q{;}, $angles;

for( my $i = 0; $i <= $#mutations; $i++ ) {
    my $mutation_amino_acid = $mutations[$i];
    if( @angles ) {
        my $angles = { map { ( $_->[0], $_->[1]) }
                       map { [ split /=/ ] }
                       split /,/, $angles[$i] };
        $mutations[$i] = { 'amino_acid' => $mutation_amino_acid,
                           'angles'     => $angles };
    } else {
        $mutations[$i] = { 'amino_acid' => $mutation_amino_acid,
                           'angles'     => {} };
    }
}

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    if( $pdbx_file ) {
        $atom_site = obtain_atom_site( $pdbx_file );
    } else {
        die "Use command \"rotag_mutate --help\" in order to see the manual.\n";
    }

    my $selected_atom_site =
        filter( { 'atom_site' => $atom_site,
                  'include' => { '[local]_selection_state' => [ 'T' ] },
                  'exclude' => { '[local]_selection_group' => [ q{?} ] } } );
    my @group_ids =
        uniq( @{ filter( { 'atom_site' => $selected_atom_site,
                           'data' => [ '[local]_selection_group' ],
                           'is_list' => 1 } ) } );

    if( ! @group_ids ) {
        parse_errors( { 'program' => $0,
                        'filename' => $pdbx_file,
                        'type' => 'ERROR',
                        'message' =>
                            "No residues were selected. Use " .
                            "rotag_select script to select residue(-s).\n" } );
    }

    if( @mutations ) {
        for( my $i = 0; $i <= $#mutations; $i++ ) {
            my $ca_atom_id =
                filter( { 'atom_site' => $selected_atom_site,
                          'include' =>
                              { 'label_atom_id' => [ 'CA' ],
                                '[local]_selection_group' => [ $group_ids[$i] ]},
                          'data' => [ 'id' ],
                          'is_list' => 1 } )->[0];
            my $unique_residue_key =
                unique_residue_key( $selected_atom_site->{$ca_atom_id} );

            replace_with_moiety( $selected_atom_site,
                                 $unique_residue_key,
                                 $mutations[$i]->{'amino_acid'},
                                 { 'angles' => $mutations[$i]->{'angles'}} );

            to_pdbx( { 'atom_site' => $selected_atom_site } );
        }
    } else {
        parse_errors( { 'program' => $0,
                        'filename' => $pdbx_file,
                        'type' => 'ERROR',
                        'message' => "No mutations were specified. Use -m " .
                                     "option to achieve that.\n" } );

    }
}

#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Getopt::Long;
Getopt::Long::Configure qw( gnu_getopt );
use List::MoreUtils qw( uniq );

use Constants qw( $PI
                  $SIG_FIGS_MAX );
use ErrorHandling qw( parse_errors );
use PDBxParser qw( determine_residue_keys
                   filter
                   mark_selection
                   obtain_atom_site
                   split_by
                   to_pdbx );
use PseudoAtoms qw( generate_library );
use Version qw( $VERSION );

our $VERSION = $VERSION;

#*rotag_library [options] <file>...
#*    generate rotamer library.
#*
#*Usage:
#*    rotag_library -u combined input.cif > output.cif
#*    rotag_library -c 0.005 input.cif > output.cif
#*
#*Options:
#*    -m, --model <str>            rules (model) that are used to move side-chains
#*                                 (default: rotation_only).
#*
#*    -a, --angle-step <float>     angle ratio that each dihedral angle is turned
#*                                 by (default: 0.1).
#*
#*    -u, --potential <potential>  uses potential energy function for determining
#*                                 interactions between selected residues and
#*                                 atoms that are reachable or described
#*                                 (default: composite | hard_sphere
#*                                 | soft_sphere).
#*
#*    -p, --parameters <str>       parameter values.
#*
#*                                 Parameters for composite potential energy
#*                                 function:
#*                                     lj_k         - Leonard-Jones constant;
#*                                     c_k          - Coulomb constant;
#*                                     h_k          - hydrogen bond constant;
#*                                     cutoff_start - x VdW where energy starts
#*                                                    to go to zero;
#*                                     cutoff_end   - x VdW where energy is at
#*                                                    zero.
#*
#*                                 Parameters for soft-sphere potential energy
#*                                 function:
#*                                     soft_epsilon - soft sphere epsilon;
#*                                     soft_n       - soft sphere n.
#*
#*                                 E.g.: 'lj_k = 0.01, c_k = 0.4'.
#*
#*    -c, --cutoff-atom <float>    the maximum value of energy potential for each
#*                                 atom that allows for further rotamer search
#*                                 (default: 0.4).
#*
#*    -H, --explicit-hydrogens     adds explicit hydrogens for calculating full
#*                                 atom energies. Otherwise, implicit hydrogen
#*                                 model is used.
#*
#*    -t, --top-rank <int>         top rotamers according to the value of
#*                                 energies.
#*
#*    -T, --top-ratio <float>      top rotamers according to the value of
#*                                 energies (default: 1.0).
#*
#*    -n, --threads <int>          number of threads.
#*
#*    -v, --version                print version.

# --------------------------------- Options ----------------------------------- #

my $conf_model = 'rotation_only';
my $interactions = 'composite';
my $small_angle_ratio = 0.1;
my $small_angle_step;
my $energy_cutoff_atom;
my $is_hydrogen_explicit = 0;
my $threads = 1;
my $top_rank;
my $top_ratio;
my $parameters = q{};

GetOptions(
    'model|m=s' => \$conf_model,
    'potential|u=s' => \$interactions,
    'parameters|p=s' => \$parameters,
    'angle-ratio|a=s' => \$small_angle_ratio,
    'angle-step|A=s' => \$small_angle_step,
    'cutoff-atom|c=s' => \$energy_cutoff_atom,
    'explicit-hydrogens|H' => sub { $is_hydrogen_explicit = 1 },
    'top-rank|t=s' => \$top_rank,
    'top-ratio|T=s' => \$top_ratio,
    'threads|n=s' => \$threads,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'Error in command line argument.';

$parameters =~ s/\s//g;
$parameters = {
    map { $_->[0] => $_->[1] }
    map { [ split /=/sm, $_ ] }
    split /,/sxm, $parameters
};

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    if( $pdbx_file ) {
        $atom_site = obtain_atom_site( $pdbx_file );
    } else {
        die "Use command \"rotag_library --help\" in order to see the manual.\n";
    }

    my $selected_atom_site =
        filter( { 'atom_site' => $atom_site,
                  'include' => { '[local]_selection_state' => [ 'T', 'S' ] } } );

    # Selects all atoms if no specific atoms are selected.
    if( ! %{ $selected_atom_site } ) {
        $selected_atom_site = $atom_site;
        mark_selection( $selected_atom_site,
                        { 'target' => [ keys %{ $selected_atom_site } ] } );
    }

    # Splits atom site into groups by its uniqueness.
    my $atom_site_groups = split_by( { 'atom_site' => $selected_atom_site,
                                       'attributes' => [ 'pdbx_PDB_model_num',
                                                         'label_alt_id' ],
                                       'append_dot' => 1 } );

    my %rotamer_library;
    for my $atom_site_identifier ( sort keys %{ $atom_site_groups } ) {
        my $current_atom_site =
            filter( { 'atom_site' => $atom_site,
                      'include' =>
                          { 'id' =>
                                $atom_site_groups->{$atom_site_identifier} } } );
        my $current_target_site =
            filter( { 'atom_site' => $current_atom_site,
                      'include' => { '[local]_selection_state' => [ 'T' ] } } );

        my $residue_unique_keys =
            determine_residue_keys( $current_target_site,
                                    { 'exclude_dot' => 1 } );

        # Starts generating rotamer library.
        my $rotamer_library;
        eval {
            $rotamer_library =
                generate_library(
                    { 'atom_site' => $current_atom_site,
                      'residue_unique_keys' => $residue_unique_keys,
                      'include_interactions' =>
                          { 'id' => [ keys %{ $current_atom_site } ] },
                      'small_angle' => (
                          defined $small_angle_step ?
                          $small_angle_step :
                          $small_angle_ratio * 2 * $PI
                      ),
                      'conf_model' => $conf_model,
                      'interactions' => $interactions,
                      'parameters' => $parameters,
                      'energy_cutoff_atom' => $energy_cutoff_atom,
                      'is_hydrogen_explicit' => $is_hydrogen_explicit,
                      'threads' => $threads,
                    } );
        };
        if( $@ ) {
            parse_errors( { 'program' => $0,
                            'filename' => $pdbx_file,
                            'type' => 'WARNING',
                            'message' => $@ } );
        }

        for my $residue_unique_key ( keys %{ $rotamer_library } ) {
            $rotamer_library{$residue_unique_key} =
                $rotamer_library->{$residue_unique_key};
        }
    }

    # Collects residue angle and energy data.
    my %pdbx_loops;

    $pdbx_loops{'_[local]_rotamer_angle'}{'attributes'} =
        [ 'id', 'rotamer_id', 'label_seq_id', 'label_comp_id', 'label_asym_id',
          'pdbx_PDB_model_num', 'label_alt_id', 'type', 'value' ];
    $pdbx_loops{'_[local]_rotamer_energy'}{'attributes'} =
        [ 'id', 'rotamer_id', 'calculation_method', 'value'];

    my $angle_id = 1;
    my $energy_id = 1;
    my $rotamer_id = 1;
    for my $residue_unique_key ( sort { $a cmp $b } keys %rotamer_library ){
        my ( $residue_id, $residue_chain, $pdbx_model, $residue_alt ) =
            split /,/sxm, $residue_unique_key;
        my @residue_name =
            uniq( @{ filter( { 'atom_site' => $selected_atom_site,
                               'include' =>
                                   { 'label_seq_id' => [ $residue_id ],
                                     'label_asym_id' => [ $residue_chain ],
                                     'label_alt_id' => [ $residue_alt ],
                                     'pdbx_PDB_model_num' => [ $pdbx_model ] },
                               'data' => [ 'label_comp_id' ],
                               'is_list' => 1 } ) } );

        # Checks if 'top' option is int or float and filters rotamers accordingly.
        my @rotamers;
        if( defined $top_rank ) {
            $top_rank =
                $top_rank <= scalar @{$rotamer_library{$residue_unique_key}} ?
                $top_rank :
                scalar @{ $rotamer_library{$residue_unique_key} };
            @rotamers =
                sort { $a->{'potential_energy_value'} <=>
                       $b->{'potential_energy_value'} }
                    @{ $rotamer_library{$residue_unique_key} };
            @rotamers = @rotamers[0..$top_rank-1];
        } elsif( defined $top_ratio ) {
            $top_rank =
                int( scalar( @{ $rotamer_library{$residue_unique_key} } )
              * $top_ratio );
            @rotamers =
                sort { $a->{'potential_energy_value'} <=>
                       $b->{'potential_energy_value'} }
                    @{ $rotamer_library{$residue_unique_key} };
            @rotamers = @rotamers[0..$top_rank-1];
        } else {
            @rotamers = @{ $rotamer_library{$residue_unique_key} };
        }

        for my $rotamer ( @rotamers ) {
            # Colects rotamer angle data.
            for my $angle_name (sort { $a cmp $b } keys %{$rotamer->{'angles'}}){
                my $angle_value = $rotamer->{'angles'}{$angle_name};
                push @{ $pdbx_loops{'_[local]_rotamer_angle'}{'data'} },
                     $angle_id, $rotamer_id, $residue_id, $residue_name[0],
                     $residue_chain, $pdbx_model, $residue_alt, $angle_name,
                     sprintf $SIG_FIGS_MAX, $angle_value;
                $angle_id++;
            }

            # Colects rotamer energy data.
            push @{ $pdbx_loops{'_[local]_rotamer_energy'}{'data'} },
                 $energy_id, $rotamer_id, $rotamer->{'potential'},
                 sprintf $SIG_FIGS_MAX, $rotamer->{'potential_energy_value'};

            $energy_id++;
            $rotamer_id++;
        }
    }

    # Prints out cif.
    to_pdbx( { 'atom_site' => $selected_atom_site,
               'add_atom_attributes' => [ '[local]_selection_state' ],
               'pdbx_loops' => \%pdbx_loops } );
}

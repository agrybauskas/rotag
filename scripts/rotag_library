#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Getopt::Long;
Getopt::Long::Configure qw( gnu_getopt );
use List::MoreUtils qw( uniq );

use ConnectAtoms qw( connect_atoms );
use Constants qw( $PI
                  $SIG_FIGS );
use ErrorHandling qw( parse_errors
                      parse_warnings );
use BondProperties qw( hybridization );
use PDBxParser qw( determine_residue_keys
                   filter
                   mark_selection
                   obtain_atom_site
                   split_by
                   to_pdbx );

use PseudoAtoms qw( add_hydrogens
                    generate_library );
use Version qw( $VERSION );

our $VERSION = $VERSION;

#*rotag_library [options] file1 [file2, ...]
#*    generate rotamer library.
#*
#*USAGE:
#*    rotag_library -u combined input.cif > output.cif
#*    rotag_library -c 0.005 input.cif > output.cif
#*
#*OPTIONS:
#*    -m, --model <str> (default: rotation_only)
#*        rules (model) that will be used to move side-chains.
#*    -a, --angle-step <float> (default: 0.1)
#*        angle ratio that each dihedral angle is turned by.
#*    -u, --potential (default: composite | hard_sphere | soft_sphere)
#*        uses potential energy function for determining interactions between
#*        selected residues and atoms that are reachable or described.
#*    -p, --parameters <str>
#*        parameters for composite potential energy function:
#*            lj_epsilon   - Leonard-Jones epsilon;
#*            c_k          - Coulomb constant;
#*            h_epsilon    - hydrogen bond epsilon;
#*            cutoff_start - x VdW where energy starts to go to zero;
#*            cutoff_end   - x VdW where energy is at zero.
#*        parameters for soft-sphere potential energy function:
#*            soft_epsilon - soft sphere epsilon;
#*            soft_n       - soft sphere n.
#*        Example: 'lj_epsilon = 0.01, c_k = 0.4'.
#*    -c, --cutoff-atom <float> (default: 0.4)
#*        the maximum value of energy potential for each atom that allows for
#*        further rotamer search.
#*    -C, --cutoff-residue <float> (default: 1.0)
#*        filters out rotamers which has the potential energy greater than the
#*        cutoff value.
#*    -H, --explicit-hydrogens
#*        adds explicit hydrogens for calculating full atom energies. Otherwise,
#*        implicit hydrogen model is used.
#*    -t, --top-rank <int>
#*        top rotamers according to the value of energies.
#*    -T, --top-ratio <float>
#*        top rotamers according to the value of energies.
#*    -n, --threads
#*        number of threads.
#*    -v, --version
#*        print version.

# --------------------------------- Options ----------------------------------- #

my $conf_model = 'rotation_only';
my $interactions = 'composite';
my $small_angle_ratio = 0.1;
my $small_angle_step;
my $energy_cutoff_atom = 0.4;
my $energy_cutoff_residue = 1.0;
my $is_hydrogen_explicit = 0;
my $threads = 1;
my $top_rank;
my $top_ratio;
my $parameters = q{};

GetOptions(
    'model|m=s' => \$conf_model,
    'potential|u=s' => \$interactions,
    'parameters|p=s' => \$parameters,
    'angle-ratio|a=s' => \$small_angle_ratio,
    'angle-step|A=s' => \$small_angle_step,
    'cutoff-atom|c=s' => \$energy_cutoff_atom,
    'cutoff-residue|C=s' => \$energy_cutoff_residue,
    'explicit-hydrogens|H' => sub { $is_hydrogen_explicit = 1 },
    'top-rank|t=s' => \$top_rank,
    'top-ratio|T=s' => \$top_ratio,
    'threads|n=s' => \$threads,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'Error in command line argument.';

$parameters =~ s/\s//g;
$parameters = {
    map { $_->[0] => $_->[1] }
    map { [ split /=/sm, $_ ] }
    split /,/sxm, $parameters
};

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    if( $pdbx_file ) {
        $atom_site = obtain_atom_site( $pdbx_file );
    } else {
        die "Use command \"rotag_library --help\" in order to see the manual.\n";
    }

    my $selected_atom_site =
        filter( { 'atom_site' => $atom_site,
                  'include' => { '[local]_selection_state' => [ 'T', 'S' ] } } );

    # Selects all atoms if no specific atoms are selected.
    if( ! %{ $selected_atom_site } ) {
        $selected_atom_site = $atom_site;
        mark_selection( $selected_atom_site,
                        { 'target' => [ keys %{ $selected_atom_site } ] } );
    }

    # Splits atom site into groups by its uniqueness.
    my $atom_site_groups = split_by( { 'atom_site' => $atom_site,
                                       'attributes' => [ 'pdbx_PDB_model_num',
                                                         'label_alt_id' ],
                                       'append_dot' => 1 } );

    my $rotamer_library;
    for my $atom_site_identifier ( sort keys %{ $atom_site_groups } ) {
        my $current_atom_site =
            filter( { 'atom_site' => $atom_site,
                      'include' =>
                          { 'id' =>
                                $atom_site_groups->{$atom_site_identifier} } } );
        my $residue_unique_key =
            determine_residue_keys( $current_atom_site,
                                    { 'exclude_dot' => 1 } )->[0];

        # Starts generating rotamer library.
        eval {
            $rotamer_library =
                generate_library(
                    { 'atom_site' => $current_atom_site,
                      'residue_unique_keys' => [ $residue_unique_key ],
                      'small_angle' => (
                          defined $small_angle_step ?
                          $small_angle_step :
                          $small_angle_ratio * 2 * $PI
                      ),
                      'conf_model' => $conf_model,
                      'interactions' => $interactions,
                      'parameters' => $parameters,
                      'energy_cutoff_atom' => $energy_cutoff_atom,
                      'energy_cutoff_residue' => $energy_cutoff_residue,
                      'is_hydrogen_explicit' => $is_hydrogen_explicit,
                      'threads' => $threads,
                    } );
        };
        if( $@ ) {
            parse_errors( { 'program' => $0,
                            'filename' => $pdbx_file,
                            'type' => 'WARNING',
                            'message' => $@ } );
        }
    }

    # # Collects residue angle and energy data.
    # my %pdbx_loops;

    # $pdbx_loops{'_[local]_rotamer_angle'}{'attributes'} =
    #     [ 'id', 'rotamer_id', 'label_seq_id', 'label_comp_id', 'label_asym_id',
    #       'label_entity_id', 'label_alt_id', 'type', 'value' ];
    # $pdbx_loops{'_[local]_rotamer_energy'}{'attributes'} =
    #     [ 'id', 'rotamer_id', 'calculation_method', 'value'];

    # my $angle_id = 1;
    # my $energy_id = 1;
    # my $rotamer_id = 1;
    # for my $residue_unique_key ( sort { $a cmp $b } keys %{ $rotamer_library } ){
    #     my ( $residue_id, $residue_chain, $residue_entity, $residue_alt ) =
    #         split /,/sxm, $residue_unique_key;
    #     my @residue_name =
    #         uniq( @{ filter( { 'atom_site' => $selected_atom_site,
    #                            'include' =>
    #                                { 'label_seq_id' => [ $residue_id ],
    #                                  'label_asym_id' => [ $residue_chain ],
    #                                  'label_alt_id' => [ $residue_alt ],
    #                                  'label_entity_id' => [ $residue_entity ] },
    #                            'data' => [ 'label_comp_id' ],
    #                            'is_list' => 1 } ) } );

    #     # Checks if 'top' option is int or float and filters rotamers accordingly.
    #     my @rotamers;
    #     if( defined $top_rank ) {
    #         $top_rank =
    #             $top_rank <= scalar @{$rotamer_library->{$residue_unique_key}} ?
    #             $top_rank :
    #             scalar @{ $rotamer_library->{$residue_unique_key} };
    #         @rotamers =
    #             sort { $a->{'potential_energy_value'} <=>
    #                    $b->{'potential_energy_value'} }
    #                 @{ $rotamer_library->{$residue_unique_key} };
    #         @rotamers = @rotamers[0..$top_rank-1];
    #     } elsif( defined $top_ratio ) {
    #         $top_rank =
    #             int( scalar( @{ $rotamer_library->{$residue_unique_key} } )
    #           * $top_ratio );
    #         @rotamers =
    #             sort { $a->{'potential_energy_value'} <=>
    #                    $b->{'potential_energy_value'} }
    #                 @{ $rotamer_library->{$residue_unique_key} };
    #         @rotamers = @rotamers[0..$top_rank-1];
    #     } else {
    #         @rotamers = @{ $rotamer_library->{$residue_unique_key} };
    #     }

    #     for my $rotamer ( @rotamers ) {
    #         # Colects rotamer angle data.
    #         for my $angle_name (sort { $a cmp $b } keys %{$rotamer->{'angles'}}){
    #             my $angle_value = $rotamer->{'angles'}{$angle_name};
    #             push @{ $pdbx_loops{'_[local]_rotamer_angle'}{'data'} },
    #                  $angle_id, $rotamer_id, $residue_id, $residue_name[0],
    #                  $residue_chain, $residue_entity, $residue_alt, $angle_name,
    #                  sprintf $SIG_FIGS, $angle_value;
    #             $angle_id++;
    #         }

    #         # Colects rotamer energy data.
    #         push @{ $pdbx_loops{'_[local]_rotamer_energy'}{'data'} },
    #              $energy_id, $rotamer_id, $rotamer->{'potential'},
    #              $rotamer->{'potential_energy_value'};

    #         $energy_id++;
    #         $rotamer_id++;
    #     }
    # }

    # # Prints out cif.
    # to_pdbx( { 'atom_site' => $selected_atom_site,
    #            'add_atom_attributes' => [ '[local]_selection_state' ],
    #            'pdbx_loops' => \%pdbx_loops } );
}

#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Getopt::Long;
Getopt::Long::Configure qw( gnu_getopt );
use List::MoreUtils qw( uniq );

use ConnectAtoms qw( connect_atoms );
use Constants qw( $PI
                  $SIG_FIGS );
use ErrorHandling qw( parse_errors
                      parse_warnings );
use BondProperties qw( hybridization );
use PDBxParser qw( filter
                   obtain_atom_site
                   to_pdbx );

use PseudoAtoms qw( add_hydrogens
                    generate_library );
use Version qw( $VERSION );

our $VERSION = $VERSION;

#*rotag_library [options] file1 [file2, ...]
#*    generate rotamer library.
#*
#*USAGE:
#*    rotag_library -u combined input.cif > output.cif
#*    rotag_library -c 0.005 input.cif > output.cif
#*
#*OPTIONS:
#*    -m, --model <str> (default: rotation_only)
#*        rules (model) that will be used to move side-chains.
#*    -a, --angle-step <float> (default: 0.1) (in radians)
#*        angle that each dihedral angle is turned by.
#*    -u, --potential (default: composite | hard_sphere | soft_sphere)
#*        uses potential energy function for determining interactions between
#*        selected residues and atoms that are reachable or described.
#*    -p, --parameters <str>
#*        parameters for composite potential energy function:
#*            lj_epsilon   - Leonard-Jones epsilon;
#*            c_epsilon    - Coulomb epsilon;
#*            h_epsilon    - hydrogen bond epsilon;
#*            cutoff_start - x VdW where energy starts to go to zero;
#*            cutoff_end   - x VdW where energy is at zero.
#*        parameters for soft-sphere potential energy function:
#*            soft_epsilon - soft sphere epsilon;
#*            soft_n       - soft sphere n.
#*        Example: 'lj_epsilon 0.01;c_epsilon 0.4'.
#*    -c, --cutoff-atom <float> (default: 0.4)
#*        the maximum value of energy potential for each atom that allows for
#*        further rotamer search.
#*    -C, --cutoff-residue <float> (default: 1.0)
#*        filters out rotamers which has the potential energy greater than the
#*        cutoff value.
#*    -t, --top-rank <int>
#*        top rotamers according to the value of energies.
#*    -T, --top-ratio <float>
#*        top rotamers according to the value of energies.
#*    -n, --threads
#*        number of threads.
#*    -v, --version
#*        print version.

# --------------------------------- Options ----------------------------------- #

my $conf_model = 'rotation_only';
my $interactions = 'composite';
my $small_angle = 0.1;
my $energy_cutoff_atom = 0.4;
my $energy_cutoff_residue = 1.0;
my $threads = 1;
my $top_rank;
my $top_ratio;
my $parameters = q{};

GetOptions(
    'model|m=s' => \$conf_model,
    'potential|u=s' => \$interactions,
    'parameters|p=s' => \$parameters,
    'angle-step|a=s' => \$small_angle,
    'cutoff-atom|c=s' => \$energy_cutoff_atom,
    'cutoff-residue|C=s' => \$energy_cutoff_residue,
    'top-rank|t=s' => \$top_rank,
    'top-ratio|T=s' => \$top_ratio,
    'threads|n=s' => \$threads,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'Error in command line argument.';

$parameters = {
    map { $_->[0] => $_->[1] }
    map { [ split / /sm, $_ ] }
    split /;/sxm, $parameters
};

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    if( $pdbx_file ) {
        $atom_site = obtain_atom_site( $pdbx_file );
    } else {
        die "Use command \"rotag_library --help\" in order to see the manual.\n";
    }

    my $selected_atom_site =
        filter( { 'atom_site' => $atom_site,
                  'include' => { '[local]_selection_state' => [ 'T', 'S' ] } } );
    my @residue_unique_keys =
        uniq (
            map { join q{,}, @{ $_ } }
            @{ filter( { 'atom_site' => $selected_atom_site,
                         'include' => { '[local]_selection_state' => [ 'T' ] },
                         'data' =>
                             [ 'label_seq_id', 'label_asym_id','label_entity_id',
                               'label_alt_id' ] } ) } );

    # Starts generating rotamer library.
    my $rotamer_library =
        generate_library(
            { 'atom_site' => $selected_atom_site,
              'residue_unique_keys' => \@residue_unique_keys,
              'small_angle' => $small_angle * $PI,
              'conf_model' => $conf_model,
              'interactions' => $interactions,
              'parameters' => $parameters,
              'energy_cutoff_atom' => $energy_cutoff_atom,
              'energy_cutoff_residue' => $energy_cutoff_residue,
              'threads' => $threads
            } );

    # Collects residue angle and energy data.
    # TODO: should not forget adding atoms that make up dihedral angles.
    my %pdbx_loops; # PDBx loop data structure (see PDBxParser.pm to_pdbx)

    $pdbx_loops{'_[local]_rotamer_angle'}{'attributes'} =
        [ 'id', 'rotamer_id', 'label_seq_id', 'label_comp_id', 'label_asym_id',
          'label_entity_id', 'label_alt_id', 'type', 'value' ];
    $pdbx_loops{'_[local]_rotamer_energy'}{'attributes'} =
        [ 'id', 'rotamer_id', 'calculation_method', 'value'];

    my $angle_id = 1;
    my $energy_id = 1;
    my $rotamer_id = 1;
    for my $residue_unique_key ( sort { $a cmp $b } keys %{ $rotamer_library } ){
        my ( $residue_id, $residue_chain, $residue_entity, $residue_alt ) =
            split /,/sxm, $residue_unique_key;
        my @residue_name =
            uniq( @{ filter( { 'atom_site' => $selected_atom_site,
                               'include' =>
                                   { 'label_seq_id' => [ $residue_id ],
                                     'label_asym_id' => [ $residue_chain ],
                                     'label_alt_id' => [ $residue_alt ],
                                     'label_entity_id' => [ $residue_entity ] },
                               'data' => [ 'label_comp_id' ],
                               'is_list' => 1 } ) } );

        # Checks if 'top' option is int or float and filters rotamers accordingly.
        my @rotamers;
        if( defined $top_rank ) {
            $top_rank =
                $top_rank <= scalar @{$rotamer_library->{$residue_unique_key}} ?
                $top_rank :
                scalar @{ $rotamer_library->{$residue_unique_key} };
            @rotamers =
                sort { $a->{'potential_energy_value'} <=>
                       $b->{'potential_energy_value'} }
                    @{ $rotamer_library->{$residue_unique_key} };
            @rotamers = @rotamers[0..$top_rank-1];
        } elsif( defined $top_ratio ) {
            $top_rank =
                int( scalar( @{ $rotamer_library->{$residue_unique_key} } )
              * $top_ratio );
            @rotamers =
                sort { $a->{'potential_energy_value'} <=>
                       $b->{'potential_energy_value'} }
                    @{ $rotamer_library->{$residue_unique_key} };
            @rotamers = @rotamers[0..$top_rank-1];
        } else {
            @rotamers = @{ $rotamer_library->{$residue_unique_key} };
        }

        for my $rotamer ( @rotamers ) {
            # Colects rotamer angle data.
            for my $angle_name (sort { $a cmp $b } keys %{$rotamer->{'angles'}}){
                my $angle_value = $rotamer->{'angles'}{$angle_name};
                push @{ $pdbx_loops{'_[local]_rotamer_angle'}{'data'} },
                     $angle_id, $rotamer_id, $residue_id, $residue_name[0],
                     $residue_chain, $residue_entity, $residue_alt, $angle_name,
                     sprintf $SIG_FIGS, $angle_value;
                $angle_id++;
            }

            # Colects rotamer energy data.
            push @{ $pdbx_loops{'_[local]_rotamer_energy'}{'data'} },
                 $energy_id, $rotamer_id, $rotamer->{'potential'},
                 $rotamer->{'potential_energy_value'};

            $energy_id++;
            $rotamer_id++;
        }
    }

    # Prints out cif.
    to_pdbx( { 'atom_site' => $selected_atom_site,
               'add_atom_attributes' => [ '[local]_selection_state' ],
               'pdbx_loops' => \%pdbx_loops } );
}

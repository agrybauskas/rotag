#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Getopt::Long;
use List::Util qw( any
                   uniq );
use Try::Tiny;

use ForceField::Parameters;
use Logging qw( error
                warning );
use PDBxParser qw( filter
                   obtain_atom_site
                   obtain_pdbx_loop
                   pdbx_loop_to_csv
                   pdbx_loop_unique
                   split_by
                   to_pdbx );
use Version qw( $VERSION );

Getopt::Long::Configure qw( gnu_getopt );

our $VERSION = $VERSION;

#*rotag_library [options] <file>...
#*    generate rotamer library.
#*
#*Usage:
#*    rotag_library -t 5 input.cif > output.cif
#*    rotag_library -T 0.2 input.cif > output.cif
#*
#*Options:
#*    -t, --top-rank <int>        top rotamers according to the value of
#*                                energies.
#*
#*    -T, --top-ratio <float>     top rotamers according to the value of
#*                                energies (default: 1.0).
#*
#*    --tags <tag>[,<tag>...]     output only specified PDBx tags.
#*
#*    -F, --format <format>       output format. Only one category can be
#*                                present if csv is select (default: pdbx | csv).
#*
#*    -v, --version               print version.

# --------------------------------- Options ----------------------------------- #

my $top_rank;
my $top_ratio;
my $tags = '';
my $output_format = 'pdbx';

local $SIG{__WARN__} = sub {
    warning( { 'message' => @_ } );
};

local $SIG{__DIE__} = sub {
    error( { 'program' => $0, 'message' => @_ } );
};

GetOptions(
    'top-rank|t=s' => \$top_rank,
    'top-ratio|T=s' => \$top_ratio,
    'tags=s' => \$tags,
    'format|F=s' => \$output_format,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or error( { 'program' => $0,
              'message' => "mistake in command line argument.\n" } );

# Parses tag string.
$tags =~ s/\s//g;
$tags = [
    split /,/sxm, $tags
];

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

my $parameters = Parameters->new();
my $pi = $parameters->{'_[local]_constants'}{'pi'};
my $sig_figs_max = $parameters->{'_[local]_constants'}{'sig_figs_max'};

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    $atom_site = obtain_atom_site( $pdbx_file );

    my $pdbx_loops =
        obtain_pdbx_loop( $pdbx_file,
                          [ '_[local]_rotamer_angle',
                            '_[local]_rotamer_energy' ],
                          { 'read_until_end' => 1 } );

    if( ! exists $pdbx_loops->[0]{'_[local]_rotamer_angle'} ||
        ! exists $pdbx_loops->[0]{'_[local]_rotamer_energy'} ) {
        warning( { 'message' => 'no rotamer angles and energies were ' .
                                "detected.\n" } );
        exit;
    }

    my $rotamer_angles =
        pdbx_loop_unique( { '_[local]_rotamer_angle' =>
                                $pdbx_loops->[0]{'_[local]_rotamer_angle'} } );
    my $rotamer_energy =
        pdbx_loop_unique( { '_[local]_rotamer_energy' =>
                                $pdbx_loops->[0]{'_[local]_rotamer_energy'} },
                          [ 'rotamer_id' ] );

    # Generates a new collection of residue angles with defined frequencies.
    my $residue_angle_groups = split_by( { 'atom_site' => $rotamer_angles } );
    my @rotamers;

    my %frequencies = ();
    for my $residue_unique_key ( sort keys %{ $residue_angle_groups } ) {
        my @angle_ids = @{ $residue_angle_groups->{$residue_unique_key} };
        my @rotamer_ids =
            uniq map { $rotamer_angles->{$_}{'rotamer_id'} } @angle_ids;

        my $current_top_rank;
        if( $top_rank ) {
            $current_top_rank =
                $top_rank <= scalar @rotamer_ids ?
                $top_rank :
                scalar @rotamer_ids;
        } elsif( $top_ratio ) {
            $current_top_rank = int( scalar( @rotamer_ids ) * $top_ratio );
            $current_top_rank = $current_top_rank == 0 ? 1 : $current_top_rank;
        } else {
            push @rotamers, @rotamer_ids;
            next;
        }

        my @current_rotamers =
            sort { $rotamer_energy->{$a}{'value'} <=>
                   $rotamer_energy->{$b}{'value'} }
                 @rotamer_ids;
        @current_rotamers = @current_rotamers[0..$current_top_rank-1];

        next if ! @current_rotamers;

        # TODO: frequency part will change in the future, because it can change
        # according to different strategies of calculations.
        for my $rotamer_id ( @current_rotamers ) {
            $frequencies{$rotamer_id} =
                sprintf( $sig_figs_max, 1 / scalar @current_rotamers );
        }

        push @rotamers, @current_rotamers;
    }

    my %pdbx_loops;
    my @attributes =
        ( 'id', 'rotamer_id', 'label_seq_id', 'label_comp_id', 'label_asym_id',
          'pdbx_PDB_model_num', 'label_alt_id', 'frequency', 'type', 'value' );
    $pdbx_loops{'_[local]_rotamer_angle'}{'attributes'} = \@attributes;

    for my $angle_id ( sort { $a <=> $b } keys %{ $rotamer_angles } ) {
        my $rotamer_id = $rotamer_angles->{$angle_id}{'rotamer_id'};
        if( any { $rotamer_id eq $_ } @rotamers ) {
            my @rotamer_data = ();
            for my $attribute ( @attributes ) {
                if( exists $rotamer_angles->{$angle_id}{$attribute} ) {
                    push @rotamer_data, $rotamer_angles->{$angle_id}{$attribute};
                }
            }

            push @{ $pdbx_loops{'_[local]_rotamer_angle'}{'data'} },
                 @rotamer_data[0..6],
                 $frequencies{$rotamer_id},
                 $rotamer_data[8],
                 $rotamer_data[7];
        }
    }

    if( @{ $tags } ) {
        # TODO: quick fix, but should be standardized. How to handle atom site?
        # Maybe after the data structure unification this problem will be solved,
        # because now it is quite messy.
        if( $output_format eq 'pdbx' ) {
            to_pdbx( { ( ( any { $_ eq '_atom_site' } @{ $tags } ) ?
                         ( 'atom_site' => $atom_site,
                           'add_atom_attributes' =>
                               [ '[local]_selection_state' ] ) :
                         () ),
                       'pdbx_loops' => { map { $_ => $pdbx_loops{$_} }
                                            @{ $tags } } } );
        } elsif( $output_format eq 'csv' ) {
            if( scalar @{ $tags } == 1 ) {
                # TODO: decide if 'atom_site' can be chosen as tag option.
                pdbx_loop_to_csv( $pdbx_loops{$tags->[0]} );
            } else {
                warning( { 'message' => "only one tag has to be chosen for " .
                                        "CSV format.\n" } );
                exit;
            }
        }
    } else {
        if( $output_format eq 'pdbx' ) {
            to_pdbx( { 'atom_site' => $atom_site,
                       'add_atom_attributes' => [ '[local]_selection_state' ],
                       'pdbx_loops' => \%pdbx_loops } );
        } elsif( $output_format eq 'csv' ) {
                warning( { 'message' => "tag has to be chosen for CSV " .
                                        "format.\n" } );
                exit;
        }
    }
}

#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use List::MoreUtils qw( uniq );

use ConnectAtoms qw( connect_atoms );
use LinearAlgebra qw( pi );
use PDBxParser qw( filter
                   obtain_atom_site
                   to_pdbx );

use PseudoAtoms qw( generate_library );

#*rotag_library
#*    generate rotamer library.
#*
#*USAGE:
#*    rotag_library --input input.cif --potential combined > output.cif
#*    rotag_library --input input.cif --cutoff 0.005 > output.cif
#*
#*OPTIONS:
#*    --input <file> | <stdin>
#*        PDBx file.
#*    --model <str> (default: rotation_only)
#*        rules (model) that will be used to move side-chains.
#*    --angle-step <float> (default: 0.1) (in radians)
#*        angle that each dihedral angle is turned by.
#*    --potential (default: composite | hard_sphere | soft_sphere)
#*        uses potential energy function for determining interactions between
#*        selected residues and atoms that are reachable or described.
#*    --parameters <str>
#*        parameters for composite potential energy function:
#*            lj_epsilon   - Leonard-Jones epsilon;
#*            c_epsilon    - Coulomb epsilon;
#*            h_epsilon    - hydrogen bond epsilon;
#*            cutoff_start - x VdW where energy starts to go to zero;
#*            cutoff_end   - x VdW where energy is at zero.
#*        parameters for soft-sphere potential energy function:
#*            soft_epsilon - soft sphere epsilon;
#*            soft_n       - soft sphere n.
#*        Example: 'lj_epsilon 0.01;c_epsilon 0.4'.
#*    --cutoff-atom <float> (default: 0.4)
#*        the maximum value of energy potential for each atom that allows for
#*        further rotamer search.
#*    --cutoff-residue <float> (default: 1.0)
#*        filters out rotamers which has the potential energy greater than the
#*        cutoff value.
#*    --top-rank <int>
#*        top rotamers according to the value of energies.
#*    --top-ratio <float>
#*        top rotamers according to the value of energies.
#*    --threads
#*        number of threads.
#*    --version
#*        print version.

# --------------------------------- Options ----------------------------------- #

my %options;

my $version = "1.0.0";

GetOptions(
    "input=s" => \$options{"pdbx_file"},
    "model=s" => \$options{"conf_model"},
    "potential=s" => \$options{"interactions"},
    "parameters=s" => \$options{"parameters"},
    "angle-step=s" => \$options{"small_angle"},
    "cutoff-atom=s" => \$options{"energy_cutoff_atom"},
    "cutoff-residue=s" => \$options{"energy_cutoff_residue"},
    "top-rank=s" => \$options{"top_rank"},
    "top-ratio=s" => \$options{"top_ratio"},
    "threads=s" => \$options{"threads"},
    "help" => sub { open( my $fh, "<", $0 );
		    while( <$fh> ) {
			my ( $help_message ) = $_ =~ m/^#(\*.*)/;
			$help_message =~ s/^\*$/ /g if $help_message;
			$help_message =~ s/^\*//g if $help_message;
			print( $help_message, "\n" ) if $help_message; }
		    close( $fh );
		    exit; },
    "version" => sub { print $version, "\n";
		       exit; } )
    or die "Error in command line argument.";

# Default options.
$options{"conf_model"} = "rotation_only" unless $options{"conf_model"};
$options{"interactions"} = "composite" unless $options{"interactions"};
$options{"small_angle"} = 0.1 unless $options{"small_angle"};
$options{"energy_cutoff_atom"} = 0.4 unless $options{"energy_cutoff_atom"};
$options{"energy_cutoff_residue"} = 1.0 unless $options{"energy_cutoff_residue"};
$options{"threads"} = 1 unless $options{"threads"};

# ----------------------------------- Main ------------------------------------ #

# Reads file path, stdin and "-" operator.
my $atom_site;
if( $options{"pdbx_file"} ) {
    $atom_site = obtain_atom_site( $options{"pdbx_file"} );
} elsif( ! defined $options{"pdbx_file"} && ! -t STDIN ) {
    $atom_site = obtain_atom_site( '-' );
} else {
    die( "Use command \"rotag_library --help\" in order to see the manual.\n" );
}

my $selected_atom_site =
    filter( { "atom_site" => $atom_site,
	      "include" => { "[local]_selection_state" => [ "T", "S" ] } } );
my @residue_ids =
    uniq( @{ filter( { "atom_site" => $selected_atom_site,
		       "include" => { "[local]_selection_state" => [ "T" ] },
		       "data" => [ "label_seq_id" ],
		       "is_list" => 1 } ) } );

# Starts generating rotamer library.
my $rotamer_library =
    generate_library(
        { "atom_site" => $selected_atom_site,
          "residue_ids" => \@residue_ids,
          "small_angle" => $options{"small_angle"} * pi(),
          "conf_model" => $options{"conf_model"},
          "interactions" => $options{"interactions"},
	  "parameters" => $options{"parameters"},
          "energy_cutoff_atom" => $options{"energy_cutoff_atom"},
          "energy_cutoff_residue" => $options{"energy_cutoff_residue"},
	  "top" => $options{"top"},
	  "threads" => $options{"threads"}
        } );

# Collects residue angle and energy data.
# TODO: should not forget adding atoms that make up dihedral angles.
my %pdbx_loops; # PDBx loop data structure (see PDBxParser.pm to_pdbx)

$pdbx_loops{"_[local]_rotamer_angle"}{"attributes"} =
    [ "id", "rotamer_id", "residue_id", "residue_type", "type", "value" ];
$pdbx_loops{"_[local]_rotamer_energy"}{"attributes"} =
    [ "id", "rotamer_id", "calculation_method", "value"];

my $angle_id = 1;
my $energy_id = 1;
my $rotamer_id = 1;
for my $residue_id ( sort { $a cmp $b } keys %{ $rotamer_library } ) {
    my @residue_name =
    	uniq( @{ filter( { "atom_site" => $selected_atom_site,
			   "include" => { "label_seq_id" => [ $residue_id ] },
    			   "data" => [ "label_comp_id" ],
    			   "is_list" => 1 } ) } );

    # Checks if 'top' option is int or float and filters rotamers accordingly.
    my @rotamers;
    if( defined $options{"top_rank"} ) {
	my $top_rank =
	    $options{"top_rank"} <= scalar(@{$rotamer_library->{$residue_id}}) ?
	    $options{"top_rank"} :
	    scalar( @{ $rotamer_library->{$residue_id} } );
	@rotamers =
	    sort { $a->{'potential_energy_value'}
	       <=> $b->{'potential_energy_value'} }
	        @{ $rotamer_library->{$residue_id} };
	@rotamers = @rotamers[0..$top_rank-1];
    } elsif( defined $options{"top_ratio"} ) {
	my $top_rank =
	    int( scalar( @{ $rotamer_library->{$residue_id} } )
	       * $options{"top_ratio"} );
	@rotamers =
	    sort { $a->{'potential_energy_value'}
	       <=> $b->{'potential_energy_value'} }
	        @{ $rotamer_library->{$residue_id} };
	@rotamers = @rotamers[0..$top_rank-1];
    } else {
	@rotamers = @{ $rotamer_library->{$residue_id} };
    }

    for my $rotamer ( @rotamers ) {
	# Colects rotamer angle data.
    	for my $angle_name ( sort { $a cmp $b } keys %{ $rotamer->{"angles"} } ){
    	    my $angle_value = $rotamer->{"angles"}{$angle_name};
    	    push( @{ $pdbx_loops{"_[local]_rotamer_angle"}{"data"} },
    		  $angle_id, $rotamer_id, $residue_id, $residue_name[0],
                  $angle_name, sprintf( "%.3f", $angle_value ) );
    	    $angle_id++;
    	}

	# Colects rotamer energy data.
	push( @{ $pdbx_loops{"_[local]_rotamer_energy"}{"data"} },
              $energy_id, $rotamer_id, $rotamer->{"potential"},
              $rotamer->{"potential_energy_value"} );

	$energy_id++;
    	$rotamer_id++;
    }
}

# Prints out cif.
to_pdbx( { "atom_site" => $selected_atom_site,
	   "add_atom_attributes" => [ "[local]_selection_state" ],
	   "pdbx_loops" => \%pdbx_loops } );

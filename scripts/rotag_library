#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Getopt::Long;
use List::MoreUtils qw( uniq );
use List::Util qw( any );

use Constants qw( $PI
                  $SIG_FIGS_MAX );
use Logging qw( warning );
use PDBxParser qw( determine_residue_keys
                   filter
                   mark_selection
                   obtain_atom_site
                   split_by
                   pdbx_loop_to_csv
                   to_pdbx );
use PseudoAtoms qw( generate_library );
use Sampling qw( sample_angles_qs_parsing );
use Version qw( $VERSION );

Getopt::Long::Configure qw( gnu_getopt );

our $VERSION = $VERSION;

#*rotag_library [options] <file>...
#*    generate rotamer library.
#*
#*Usage:
#*    rotag_library -u composite input.cif > output.cif
#*    rotag_library -c 0.005 input.cif > output.cif
#*    rotag_library -c 0.005 -p 'lj_k=1.05, c_k=0.4' input.cif > output.cif
#*
#*Options:
#*    -u, --potential <potential> uses potential energy function for determining
#*                                interactions between selected residues and
#*                                atoms that are reachable or described
#*                                (default: composite | hard_sphere
#*                                | soft_sphere).
#*
#*    -p, --parameters <str>      parameter values.
#*
#*                                Parameters for composite potential energy
#*                                function:
#*                                    lj_k         - Leonard-Jones constant;
#*                                    c_k          - Coulomb constant;
#*                                    h_k          - hydrogen bond constant;
#*                                    cutoff_start - x VdW where energy starts
#*                                                   to go to zero;
#*                                    cutoff_end   - x VdW where energy is at
#*                                                   zero.
#*
#*                                Parameters for soft-sphere potential energy
#*                                function:
#*                                    soft_epsilon - soft sphere epsilon;
#*                                    soft_n       - soft sphere n.
#*
#*                                E.g.: -p 'lj_k=0.01, c_k=0.4'.
#*
#*    -a, --angles <str>          angles that each dihedral angle is turned
#*                                by in degrees expressed in special grammar:
#*                                    <float>..<float>..<float>
#*                                        - defined steps that are performed by
#*                                          defined range;
#*                                    <angle> = <float>...[,...]
#*                                        - defined steps that are performed by
#*                                          defined range for specific angle;
#*
#*                                E.g.: '0..36.0..360.0', '0..18.0..180.0',
#*                                      '0..90.0', 'chi1=0..36.0',
#*                                      'chi1=90.0..90.0, chi2=0.0..10.0..360.0'.
#*
#*    -r, --radians               angle value is in radians.
#*
#*    -c, --cutoff-atom <float>   the maximum value of energy potential for each
#*                                atom that allows for further rotamer search
#*                                (default: 0.4).
#*
#*    -t, --top-rank <int>        top rotamers according to the value of
#*                                energies.
#*
#*    -T, --top-ratio <float>     top rotamers according to the value of
#*                                energies (default: 1.0).
#*
#*    --tags <tag>[,<tag>...]     output only specified PDBx tags.
#*
#*    -n, --threads <int>         number of threads.
#*
#*    -v, --version               print version.

# --------------------------------- Options ----------------------------------- #

my $interactions = 'composite';
my $angles = '-180.0..36.0..180.0';
my $in_radians = 0;
my $energy_cutoff_atom;
my $threads = 1;
my $top_rank;
my $top_ratio;
my $tags = '';
my $parameters = '';

GetOptions(
    'potential|u=s' => \$interactions,
    'parameters|p=s' => \$parameters,
    'angles|a=s' => \$angles,
    'radians|r' => sub { $in_radians = 1 },
    'cutoff-atom|c=s' => \$energy_cutoff_atom,
    'top-rank|t=s' => \$top_rank,
    'top-ratio|T=s' => \$top_ratio,
    'tags=s' => \$tags,
    'threads|n=s' => \$threads,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or die 'Error in command line argument.';

# Parses parameter string.
$parameters =~ s/\s//g;
$parameters = {
    map { $_->[0] => $_->[1] }
    map { [ split /=/sm, $_ ] }
    split /,/sxm, $parameters
};

# Parses tag string.
$tags =~ s/\s//g;
$tags = [
    split /,/sxm, $tags
];

# Parses string describing angles.
my %angles = %{ sample_angles_qs_parsing( $angles ) };

# Checks the names of the parameters.
my @allowed_parameters =
    qw( lj_k c_k h_k t_k cutoff_start cutoff_end soft_epsilon soft_n );

for my $parameter ( keys %{ $parameters } ) {
    if( ! any { $parameter eq $_ } @allowed_parameters ) {
        die "'$parameter' parameter is not valid.\n";
    }
}

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

for my $pdbx_file ( @ARGV ) {
    # Reads file path, stdin and '-' operator.
    my $atom_site;
    if( $pdbx_file ) {
        $atom_site = obtain_atom_site( $pdbx_file );
    } else {
        die "Use command \"rotag_library --help\" in order to see the manual.\n";
    }

    my $selected_atom_site =
        filter( { 'atom_site' => $atom_site,
                  'include' => { '[local]_selection_state' => [ 'T', 'S' ] } } );

    # Selects all atoms if no specific atoms are selected.
    if( ! %{ $selected_atom_site } ) {
        $selected_atom_site = $atom_site;
        mark_selection( $selected_atom_site,
                        { 'target' => [ keys %{ $selected_atom_site } ] } );
    }

    # Splits atom site into groups by its uniqueness.
    my $atom_site_groups = split_by( { 'atom_site' => $selected_atom_site,
                                       'attributes' => [ 'pdbx_PDB_model_num',
                                                         'label_alt_id' ],
                                       'append_dot' => 1 } );

    my %rotamer_library;
    for my $atom_site_identifier ( sort keys %{ $atom_site_groups } ) {
        my $current_atom_site =
            filter( { 'atom_site' => $atom_site,
                      'include' =>
                          { 'id' =>
                                $atom_site_groups->{$atom_site_identifier} } } );
        my $current_target_site =
            filter( { 'atom_site' => $current_atom_site,
                      'include' => { '[local]_selection_state' => [ 'T' ] } } );

        my $residue_unique_keys =
            determine_residue_keys( $current_target_site,
                                    { 'exclude_dot' => 1 } );

        # Starts generating rotamer library.
        my $rotamer_library;
        eval {
            $rotamer_library =
                generate_library(
                    { 'atom_site' => $current_atom_site,
                      'residue_unique_keys' => $residue_unique_keys,
                      'include_interactions' =>
                          { 'id' => [ keys %{ $current_atom_site } ] },
                      'angles' => \%angles,
                      'interactions' => $interactions,
                      'parameters' => $parameters,
                      'energy_cutoff_atom' => $energy_cutoff_atom,
                      'threads' => $threads,
                    } );
        };
        if( $@ ) {
            warning( { 'program' => $0,
                       'filename' => $pdbx_file,
                       'message' => $@ } );
            exit;
        }

        for my $residue_unique_key ( keys %{ $rotamer_library } ) {
            $rotamer_library{$residue_unique_key} =
                $rotamer_library->{$residue_unique_key};
        }
    }

    # Collects residue angle and energy data.
    my %pdbx_loops;

    $pdbx_loops{'_[local]_rotamer_angle'}{'attributes'} =
        [ 'id', 'rotamer_id', 'label_seq_id', 'label_comp_id', 'label_asym_id',
          'pdbx_PDB_model_num', 'label_alt_id', 'type', 'value' ];
    $pdbx_loops{'_[local]_rotamer_energy'}{'attributes'} =
        [ 'id', 'rotamer_id', 'calculation_method', 'value'];

    my $angle_id = 1;
    my $energy_id = 1;
    my $rotamer_id = 1;
    for my $residue_unique_key ( sort { $a cmp $b } keys %rotamer_library ){
        my ( $residue_id, $residue_chain, $pdbx_model, $residue_alt ) =
            split /,/sxm, $residue_unique_key;
        my @residue_name =
            uniq( @{ filter( { 'atom_site' => $selected_atom_site,
                               'include' =>
                                   { 'label_seq_id' => [ $residue_id ],
                                     'label_asym_id' => [ $residue_chain ],
                                     'label_alt_id' => [ $residue_alt ],
                                     'pdbx_PDB_model_num' => [ $pdbx_model ] },
                               'data' => [ 'label_comp_id' ],
                               'is_list' => 1 } ) } );

        # Checks if 'top' option is int or float and filters rotamers accordingly.
        my @rotamers;
        if( defined $top_rank ) {
            $top_rank =
                $top_rank <= scalar @{$rotamer_library{$residue_unique_key}} ?
                $top_rank :
                scalar @{ $rotamer_library{$residue_unique_key} };
            @rotamers =
                sort { $a->{'potential_energy_value'} <=>
                       $b->{'potential_energy_value'} }
                    @{ $rotamer_library{$residue_unique_key} };
            @rotamers = @rotamers[0..$top_rank-1];
        } elsif( defined $top_ratio ) {
            $top_rank =
                int( scalar( @{ $rotamer_library{$residue_unique_key} } )
              * $top_ratio );
            @rotamers =
                sort { $a->{'potential_energy_value'} <=>
                       $b->{'potential_energy_value'} }
                    @{ $rotamer_library{$residue_unique_key} };
            @rotamers = @rotamers[0..$top_rank-1];
        } else {
            @rotamers = @{ $rotamer_library{$residue_unique_key} };
        }

        for my $rotamer ( @rotamers ) {
            # Colects rotamer angle data.
            for my $angle_name (sort { $a cmp $b } keys %{$rotamer->{'angles'}}){
                my $angle_value = $rotamer->{'angles'}{$angle_name};
                push @{ $pdbx_loops{'_[local]_rotamer_angle'}{'data'} },
                     $angle_id, $rotamer_id, $residue_id, $residue_name[0],
                     $residue_chain, $pdbx_model, $residue_alt, $angle_name,
                     sprintf $SIG_FIGS_MAX, $angle_value;
                $angle_id++;
            }

            # Colects rotamer energy data.
            push @{ $pdbx_loops{'_[local]_rotamer_energy'}{'data'} },
                 $energy_id, $rotamer_id, $rotamer->{'potential'},
                 sprintf $SIG_FIGS_MAX, $rotamer->{'potential_energy_value'};

            $energy_id++;
            $rotamer_id++;
        }
    }

    if( @{ $tags } ) {
        # TODO: quick fix, but should be standardized. How to handle atom site?
        # Maybe after the data structure unification this problem will be solved,
        # because now it is quite messy.
        to_pdbx({ ( ( any { $_ eq '_atom_site' } @{ $tags } ) ?
                    ( 'atom_site' => $selected_atom_site,
                      'add_atom_attributes' => [ '[local]_selection_state' ] ) :
                    () ),
                  'pdbx_loops' => { map { $_ => $pdbx_loops{$_} } @{ $tags } }});
    } else {
        to_pdbx( { 'atom_site' => $selected_atom_site,
                   'add_atom_attributes' => [ '[local]_selection_state' ],
                   'pdbx_loops' => \%pdbx_loops } );
    }
}

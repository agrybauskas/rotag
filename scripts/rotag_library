#!/usr/bin/perl

use strict;
use warnings;

use autodie;
use Getopt::Long;
use List::Util qw( any
                   uniq );
use Try::Tiny;

use ForceField::Parameters;
use Logging qw( error
                warning );
use PDBxParser qw( filter
                   obtain_pdbx_data
                   raw2indexed
                   split_by
                   to_csv
                   to_pdbx );
use Version qw( $VERSION );

Getopt::Long::Configure qw( gnu_getopt );

our $VERSION = $VERSION;

#*rotag_library [options] <file>...
#*    generate rotamer library.
#*
#*Usage:
#*    rotag_library -t 5 input.cif > output.cif
#*    rotag_library -T 0.2 input.cif > output.cif
#*
#*Options:
#*    -t, --top-rank <int>        top rotamers according to the value of
#*                                energies.
#*
#*    -T, --top-ratio <float>     top rotamers according to the value of
#*                                energies (default: 1.0).
#*
#*    --tags <tag>[,<tag>...]     output only specified PDBx tags.
#*
#*    -F, --format <format>       output format. Only one category can be
#*                                present if csv is select (default: pdbx | csv).
#*
#*    -v, --version               print version.

# --------------------------------- Options ----------------------------------- #

my $top_rank;
my $top_ratio;
my $tags = '_atom_site,_[local]_rotamer_angle';
my $output_format = 'pdbx';

local $SIG{__WARN__} = sub {
    warning( { 'message' => @_ } );
};

local $SIG{__DIE__} = sub {
    error( { 'program' => $0, 'message' => @_ } );
};

GetOptions(
    'top-rank|t=s' => \$top_rank,
    'top-ratio|T=s' => \$top_ratio,
    'tags=s' => \$tags,
    'format|F=s' => \$output_format,
    'help|h' => sub {
                        open my $fh, '<', $0;
                        while( <$fh> ) {
                            my ( $help_message ) = $_ =~ m/^#(\*.*)/;
                            if( $help_message ) {$help_message =~ s/^\*$/ /smgx;}
                            if( $help_message ) { $help_message =~ s/^\*//smgx; }
                            if( $help_message ) { print $help_message, "\n"; }
                        }
                        close $fh;
                        exit;
                    },
    'version|v' => sub { print $VERSION, "\n"; exit; }
) or error( { 'program' => $0,
              'message' => "mistake in command line argument.\n" } );

# Parses tag string.
$tags =~ s/\s//g;
my @tags = split /,/sxm, $tags;

# ----------------------------------- Main ------------------------------------ #

local @ARGV = ( q{-} ) unless @ARGV;

my $parameters = Parameters->new();
my $pi = $parameters->{'_[local]_constants'}{'pi'};
my $sig_figs_max = $parameters->{'_[local]_constants'}{'sig_figs_max'};

for my $pdbx_file ( @ARGV ) {
    my $pdbx = obtain_pdbx_data( $pdbx_file,
                                 [ '_atom_site',
                                   '_[local]_rotamer_angle',
                                   '_[local]_rotamer_energy' ] );

    next if ! defined $pdbx || ! %{ $pdbx };

    raw2indexed( $pdbx,
                 { 'attributes' =>
                       { '_atom_site' => [ 'id' ],
                         '_[local]_rotamer_angle' => [ 'id' ],
                         '_[local]_rotamer_energy' => [ 'rotamer_id' ] },
                   'read_until_end' => 1 } );

    my $atom_site = $pdbx->{'_atom_site'}{'data'};

    if( ! exists $pdbx->{'_[local]_rotamer_angle'} ||
        ! exists $pdbx->{'_[local]_rotamer_energy'} ) {
        warning( { 'message' => 'no rotamer angles and energies were ' .
                                "detected.\n" } );
        exit;
    }

    my $rotamer_angles = $pdbx->{'_[local]_rotamer_angle'}{'data'};
    my $rotamer_energy = $pdbx->{'_[local]_rotamer_energy'}{'data'};

    # Generates a new collection of residue angles with defined frequencies.
    my $residue_angle_groups = split_by( { 'atom_site' => $rotamer_angles } );
    my @rotamers;

    my %frequencies = ();
    for my $residue_unique_key ( sort keys %{ $residue_angle_groups } ) {
        my @angle_ids = @{ $residue_angle_groups->{$residue_unique_key} };
        my @rotamer_ids =
            uniq map { $rotamer_angles->{$_}{'rotamer_id'} } @angle_ids;

        my $current_top_rank;
        if( $top_rank ) {
            $current_top_rank =
                $top_rank <= scalar @rotamer_ids ?
                $top_rank :
                scalar @rotamer_ids;
        } elsif( $top_ratio ) {
            $current_top_rank = int( scalar( @rotamer_ids ) * $top_ratio );
            $current_top_rank = $current_top_rank == 0 ? 1 : $current_top_rank;
        } else {
            push @rotamers, @rotamer_ids;
            next;
        }

        my @current_rotamers =
            sort { $rotamer_energy->{$a}{'value'} <=>
                   $rotamer_energy->{$b}{'value'} }
                 @rotamer_ids;
        @current_rotamers = @current_rotamers[0..$current_top_rank-1];

        next if ! @current_rotamers;

        # TODO: frequency part will change in the future, because it can change
        # according to different strategies of calculations.
        for my $rotamer_id ( @current_rotamers ) {
            $frequencies{$rotamer_id} =
                sprintf( $sig_figs_max, 1 / scalar @current_rotamers );
        }

        push @rotamers, @current_rotamers;
    }

    my %pdbx_data;
    $pdbx_data{'_atom_site'} = $pdbx->{'_atom_site'};
    my @attributes =
        ( 'id', 'rotamer_id', 'label_seq_id', 'label_comp_id', 'label_asym_id',
          'pdbx_PDB_model_num', 'label_alt_id', 'frequency', 'type', 'value' );
    $pdbx_data{'_[local]_rotamer_angle'}{'metadata'}{'attributes'}=\@attributes;
    $pdbx_data{'_[local]_rotamer_angle'}{'metadata'}{'is_loop'} = 1;
    $pdbx_data{'_[local]_rotamer_angle'}{'metadata'}{'is_indexed'} = 0;

    for my $angle_id ( sort { $a <=> $b } keys %{ $rotamer_angles } ) {
        my $rotamer_id = $rotamer_angles->{$angle_id}{'rotamer_id'};
        if( any { $rotamer_id eq $_ } @rotamers ) {
            my @rotamer_data = ();
            for my $attribute ( @attributes ) {
                if( exists $rotamer_angles->{$angle_id}{$attribute} ) {
                    push @rotamer_data, $rotamer_angles->{$angle_id}{$attribute};
                }
            }

            push @{ $pdbx_data{'_[local]_rotamer_angle'}{'data'} },
                 @rotamer_data[0..6],
                 $frequencies{$rotamer_id},
                 $rotamer_data[8],
                 $rotamer_data[9];
        }
    }

    if( $output_format eq 'pdbx' ) {
        to_pdbx( \%pdbx_data,
                 { 'add_attributes' =>
                       { '_atom_site' => [ '[local]_selection_state' ] },
                   'tags' => \@tags } );
    } elsif( $output_format eq 'csv' ) {
        if( scalar @{ $tags } == 1 ) {
            to_csv( %pdbx_data, { 'category' => $tags[0] } );
        } else {
            warning( { 'message' => "only one tag has to be chosen for " .
                           "CSV format.\n" } );
            exit;
        }
    }
}

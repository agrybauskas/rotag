#!perl
%{
    use warnings;

    use PDBxParser qw( filter );
%}

%left ','
%left '-'

%%

exp
    : 'resid' ope     { push @{ $_[0]->{'include'}{'resid'} }, @{ $_[2] }; }
;

ope
    : ope ',' ope { [ @{ $_[1] }, @{ $_[3] } ] }
    | ope '-' ope { [ $_[1]->[0]..$_[3]->[0] ] }
    | NUM         { [ int( $_[1] ) ] }
;

%%

sub lexer
{
    my( $parser ) = shift;

    $parser->YYData->{INPUT} || return( '',undef );
    $parser->YYData->{INPUT} =~ s/^[ \t]//;

    # Returns tokens to parser.
    for( $parser->YYData->{INPUT} ){
        if( s/^(resid)// ) {
            return ( 'resid', $1 );
        } elsif( s/^([0-9]+)// ) {
            return ( 'NUM', $1 );
	} elsif( s/^(,)// ) {
            return ( ',', $1 );
	} elsif( s/^(-)// ) {
            return ( '-', $1 );
	}
    }
}

sub debugger
{
    exists $_[0]->YYData->{ERRMSG}

    and do {
        print $_[0]->YYData->{ERRMSG};
        return;
    };

    print "Syntax error\n";
}

sub parser
{
    my ( $self, $input ) = @_;

    $self->YYData->{INPUT} = $input;
    my $result = $self->YYParse( yylex => \&lexer,
                                 yyerror => \&debugger,
				 yydebug=>0x00 );

    return $result;
}
